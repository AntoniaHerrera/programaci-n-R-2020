[["index.html", "Programación en Ciencias Sociales Inicio Links importantes Cronograma y materiales del curso", " Programación en Ciencias Sociales Andrés Cruz 2021-05-03 Inicio Este es el sitio web del curso Programación en Ciencias Sociales (CPO3523), dictado en el Escuela de Ciencia Política UDP durante el primer semestre de 2021. El objetivo del sitio es servir como material de consulta. Todos los proyectos que ejecutemos en RStudio Cloud estarán también compilados aquí, para facilitar su revisión. Links importantes Programa del curso Clases grabadas (acceso con cuenta UDP) RStudio Cloud (acceso con cuenta UDP) Cronograma y materiales del curso I. Introducción L 2021-03-08 Presentación del programa Ciencia de datos y programación Introducción a R, RStudio y R Markdown Material mínimo Material complementario RStudio. 2018a. Introducción al Lenguaje R: Guía Rápida. RStudio. 2018b. RStudio IDE: Guía Rápida. RStudio. 2014. RMarkdown: Hoja de Referencia. II. Manejo de bases de datos L 2021-03-15, L 2021-03-22 Introducción al tidyverse Carga de bases de datos Manejo de bases de datos Limpieza de bases Material mínimo Material complementario Cruz, A. 2020. Manejo de Datos. RStudio. 2017. Importar Datos: Guía Rápida RStudio. 2018. Transformación de Datos con dplyr: Hoja de referencia. III. Visualización de datos L 2021-03-29, L 2021-04-05 Principios de visualización de datos Introducción a la gramática de gráficos Generación de gráficos en ggplot2 Material mínimo Material complementario Healy, K. 2018. Data Visualization: A Practical Introduction. Cap. 1. Araya, S. 2020. Visualización de Datos. RStudio. 2016. Visualización de Datos usando ggplot2: Guía Rápida. Semana de receso 1: L 2021-04-12 IV. Búsqueda efectiva de ayuda L 2021-04-19 Archivos de ayuda en R. Recursos de apoyo: Google, StackOverflow, GitHub. Construcción de ejemplos mínimos reproducibles (reprex). Material mínimo Material complementario Healy, K. 2018. Data Visualization: A Practical Introduction. Anexo 1.1 Wickham, H. y Grolemund, G. 2017. R for Data Science. Sección 1.6. Mostipak, J. 2018. So Youve Been Asked to Make a Reprex. Entrega Solemne 1: L 2021-04-26 V. Manejo avanzado de bases de datos L 2021-05-03 Reformulación (pivot) de bases de datos. Recodificación de variables. Combinación (merge) de bases. Material mínimo Material complementario Urdinez, F. y Cruz, A. 2020. Manejo Avanzado de Datos Políticos. RStudio. 2017b. Importar Datos: Guía Rápida. Pág. 2. Bryan, J. 2018. Cheatsheet for dplyr join functions. VI. Análisis de texto L 2021-05-10, L 2021-05-17 Manipulación de cadenas de texto. Expresiones regulares. Introducción al análisis cuantitativo de textos (QTA). Material mínimo Material complementario Wickham, H., y Grolemund, G. 2017. R for Data Science. Cap. 14. Silge, J. y Robinson, D. 2018. Text Mining with R. Caps. 1-3. RStudio. 2017c. Trabajar con Cadenas con stringr: Guía Rápida VII. Minería de datos web y R avanzado L 2021-05-24 Tipos de objeto en R Funciones personalizadas. Iteraciones Material mínimo Material complementario Wickham, H., y Grolemund, G. 2017. R for Data Science. Caps. 19 y 21. Barría, G. 2021. Minería de Datos Web. Densmore, J. 2017. Ethics in web scraping. RStudio. 2017a. Aplicar Funciones con purrr: Guía Rápida. Entrega Ensayo Breve: L 2021-05-24 [Instrucciones y pauta] Semana de receso 2: L 2021-05-31 VIII. Replicación y generación de reportes L 2021-06-07 Replicación en ciencias sociales. R Markdown para reportes y presentaciones. Material mínimo Material complementario King, G. 1995. Replication, Replication. RStudio. 2014. RMarkdown: Hoja de Referencia. Entrega Solemne 2: L 2021-06-14 Presentaciones y retroalimentación para el trabajo final: L 2021-06-21 Feriado: L 2021-06-28 Prueba recuperativa: A fijar entre M 2021-06-29 y V 2021-07-02 IX. Datos espaciales y mapas / X. Cierre L 2021-07-05 Introducción a los datos espaciales con sf. Mapas en ggplot2. Ciencia social computacional. La comunidad de R. RStudio de escritorio. Material mínimo Material complementario Escobar, A. y Ortiz, G. 2021. Mapas y Datos Espaciales. Grimmer, J. 2015. We Are All Social Scientists Now. Frick, H., y Daish, A. 2017. R-Ladies Global Community. Garnett, R. 2018. Spatial Manipulation with sf: Cheatsheet. Entrega del trabajo escrito final: M 2021-07-06 Examen: L 2021-07-12 "],["rbasico.html", "01A - R básico Introducción: comandos y código Paquetes Comandos básicos y tipos de objeto en R Sintaxis de R Markdown Título de prueba Siguiente script", " 01A - R básico Diapositivas de introducción Si quieres correr este script localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar: tidyverse. Este es un script de R Markdown, una forma de registrar nuestro código de R. Sabemos esto por por la extensión .Rmd y todas las opciones que están fijadas más arriba (por ahora no nos concentraremos demasiado en ellas). Antes de comenzar, juguemos un poco con las opciones de RStudio. Vamos a Tools &gt; Global Options &gt; Appearance. Introducción: comandos y código En los scripts de R Markdown el texto plano (como este) nos permite añadir comentarios, explicaciones, etc. Cuando ocupemos código debemos insertarlo en chunks o bloques de código, como veremos a continuación. Haremos un bloque de código para ocupar R como una calculadora simple. Podemos correr el código línea por línea con Ctrl/Cmd + Enter, si nuestro teclado está en dicha parte del script. Para correr el chunk completo puedes presionar en el pequeño botón de Play en la parte superior derecha o presionar Ctrl/Cmd + Shift + Enter. 1 + 5 ## [1] 6 78878.12 * 8e05 / (12 - 7 + 87.2) # este es un comentario &quot;en línea&quot;, se antecede con un # ## [1] 684408850 Para crear un chunk, debes presionar Ctrl/Cmd + Alt + i. Prueba a crear un chunk y calcula alguna operación aritmética. Tu código: En R podemos crear objetos, que guardarán información para ser utilizada en operaciones siguientes: mi_objeto &lt;- 5 mi_objeto # poner su nombre lo imprime, sin más ## [1] 5 Por ejemplo, podemos hacer aritmética con este nuevo objeto: mi_objeto - 17 ## [1] -12 ¿Cuál es la diferencia entre este último comando y el siguiente? mi_objeto_b &lt;- mi_objeto - 17 Eliminemos este segundo objeto, utilizando la funcion rm() (remove): rm(mi_objeto_b) Si quisiéramos reiniciar la sesión (comenzando todo desde cero), podríamos presionar Session &gt; Restart R) y clickear en la escoba del panel Environment de RStudio (superior derecho). Paquetes Los paquetes añaden nuevas funciones a R. Hay que cargarlos en cada nueva sesión, con el comando library(). library(tidyverse) El tidyverse es un paquete que ocuparemos en todas nuestras clases, que añade una gran cantidad de funciones al lenguaje. Ojo! library() solo nos permite cargar paquetes que hayamos instalado. Aquí en RStudio Cloud yo instalé el tidyverse para todas/os, pero por defecto habría que instalarlo. Probemos a utilizar otro paquete, fun: library(fun) Debemos instalarlo. Basta con instalar los paquetes una vez, luego podremos cargarlos en cada sesión que queramos. La mayoría de los paquetes se instalan con el comando install.packages(\"paquete\"): install.packages(&quot;fun&quot;) Por cierto, podemos saber que R está trabajando gracias a RStudio. Mientras el paquete se instala, fíjate que hay una pequeña línea (¿color?) en la parte izquierda del código. Terminada la instalación, carguemos el nuevo paquete: library(fun) # ahora el paquete está instalado, por lo que carga sin problemas (Ejercicio A) Prueba a instalar un paquete llamado fun. Luego, cárgalo y corre el siguiente comando: random_password(). ¿Qué hace? Recuerda registrar todo el proceso en el script! Tu código: Comandos básicos y tipos de objeto en R En esta sección veremos vectores, data frames (marcos de datos) y listas. Vectores Lo siguiente es un vector numérico: c(7, 9, 19, 2, 9) ## [1] 7 9 19 2 9 El siguiente comando creará un objeto (mi_vector). ¿Qué contendrá este nuevo objeto? mi_vector &lt;- c(2, -3, mi_objeto, 6:9) Veamos algunos comandos básicos a aplicar en números y vectores numéricos. mi_vector[2] # acceder al segundo elemento del vector ## [1] -3 sqrt(x = mi_objeto) # la raíz cuadrada es una función! ## [1] 2.236068 log(x = mi_objeto) # logaritmo natural ## [1] 1.609438 mean(x = mi_vector) # media del vector ## [1] 4.857143 media_mi_vector &lt;- mean(x = mi_vector) # si quisiéramos guardarla como objeto! median(x = mi_vector) # mediana del vector ## [1] 6 quantile(x = mi_vector, probs = c(0.25, 0.5, 0.75)) # q1, q2, q3 ## 25% 50% 75% ## 3.5 6.0 7.5 sd(x = mi_vector) # desviación estándar del vector ## [1] 4.140393 length(x = mi_vector) # número de elementos del vector ## [1] 7 sum(x = mi_vector) # suma del vector ## [1] 34 min(x = mi_vector) # ¿qué hace esta función? ## [1] -3 max(x = mi_vector) # ¿y esta? ## [1] 9 Todas las funciones que hemos visto simplemente tomaban un objeto, sin más. La mayoría de las funciones son más complejas: requieren más de un objeto o nos permiten integrar más opciones. Les damos instrucciones específicas a las funciones por medio de argumentos (hasta ahora, solo vimos funciones con el inicio de argumento x =). sort(x = mi_vector) # ordena el vector de menor a mayor ## [1] -3 2 5 6 7 8 9 sort(x = mi_vector, decreasing = TRUE) # ¿qué cambia con este argumento? ## [1] 9 8 7 6 5 2 -3 Nota que podemos añadir saltos de línea entre argumentos: sort(x = mi_vector, decreasing = TRUE) ## [1] 9 8 7 6 5 2 -3 Importante. Si ponemos los valores de los argumentos en orden, podemos evitar escribir los argumentos mismos: sort(mi_vector, TRUE) # igual resultado que nuestros comandos anteriores ## [1] 9 8 7 6 5 2 -3 Por cierto, podemos consultar el archivo de ayuda de una función fácilmente. Ahí encontraremos los distintos argumentos explicados: ?sort Los vectores también pueden ser de otros tipos: c(&quot;Manzana&quot;, &quot;Pera&quot;, &quot;Naranja&quot;, &quot;Damasco&quot;) # vector de caracteres. Nota las comillas! ## [1] &quot;Manzana&quot; &quot;Pera&quot; &quot;Naranja&quot; &quot;Damasco&quot; nchar(&quot;Manzana&quot;) # cuenta los caracteres de un elemento ## [1] 7 c(TRUE, FALSE, TRUE, TRUE) # vector lógico ## [1] TRUE FALSE TRUE TRUE c(T, F, T, T) ## [1] TRUE FALSE TRUE TRUE (Ejercicio B) De nuevo ocupa la función random_password() del paquete fun, pero esta vez con el argumento length = 10. Prueba con diferentes valores del argumento! Tu código: Data frames (marcos de datos) Los data frames son objetos centrales en R, sin duda los que más utilizaremos. Vamos a cargar uno simple: df_trump_scores &lt;- read_csv(&quot;datos/trump_scores_202003_cong116.csv&quot;) # esta función es del tidyverse! ## Parsed with column specification: ## cols( ## last_name = col_character(), ## state = col_character(), ## party = col_character(), ## trump_score = col_double(), ## trump_margin = col_double() ## ) El Trump Score es el porcentaje de votaciones en las que un senador/a ha estado alineado/a con Donald Trump. El Trump Margin es el margen que Trump obtuvo en el estado del senador/a en cuestión. Fuente: FiveThirtyEight (2020). Descargado el 11 de marzo de 2020. df_trump_scores # imprime un vistazo rápido ## # A tibble: 100 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 ## 7 Blackburn TN R 93.9 26.0 ## 8 Barrasso WY R 91.2 46.3 ## 9 Bennet CO D 15.4 -4.91 ## 10 Blumenthal CT D 11.8 -13.6 ## # ... with 90 more rows head(df_trump_scores) # imprime solo las seis primeras filas ## # A tibble: 6 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 También podemos inspeccionar un data frame clickeando su nombre en el panel superior derecho, pestaña Environment. Las columnas de un data frame son vectores! df_trump_scores$last_name ## [1] &quot;Alexander&quot; &quot;Blunt&quot; &quot;Brown&quot; ## [4] &quot;Burr&quot; &quot;Baldwin&quot; &quot;Boozman&quot; ## [7] &quot;Blackburn&quot; &quot;Barrasso&quot; &quot;Bennet&quot; ## [10] &quot;Blumenthal&quot; &quot;Booker&quot; &quot;Braun&quot; ## [13] &quot;Cantwell&quot; &quot;Cardin&quot; &quot;Carper&quot; ## [16] &quot;Crapo&quot; &quot;Collins&quot; &quot;Capito&quot; ## [19] &quot;Cornyn&quot; &quot;Casey&quot; &quot;Cassidy&quot; ## [22] &quot;Coons&quot; &quot;Cotton&quot; &quot;Cramer&quot; ## [25] &quot;Cruz&quot; &quot;Cortez Masto&quot; &quot;Durbin&quot; ## [28] &quot;Daines&quot; &quot;Duckworth&quot; &quot;Enzi&quot; ## [31] &quot;Ernst&quot; &quot;Feinstein&quot; &quot;Fischer&quot; ## [34] &quot;Graham&quot; &quot;Grassley&quot; &quot;Gillibrand&quot; ## [37] &quot;Gardner&quot; &quot;Hirono&quot; &quot;Heinrich&quot; ## [40] &quot;Hoeven&quot; &quot;Harris&quot; &quot;Hassan&quot; ## [43] &quot;Hyde-Smith&quot; &quot;Hawley&quot; &quot;Inhofe&quot; ## [46] &quot;Johnson&quot; &quot;Jones&quot; &quot;Klobuchar&quot; ## [49] &quot;King&quot; &quot;Kaine&quot; &quot;Kennedy&quot; ## [52] &quot;Leahy&quot; &quot;Lankford&quot; &quot;Lee&quot; ## [55] &quot;Loeffler&quot; &quot;Markey&quot; &quot;McConnell&quot; ## [58] &quot;Menendez&quot; &quot;Moran&quot; &quot;Murray&quot; ## [61] &quot;Murkowski&quot; &quot;Murphy&quot; &quot;Merkley&quot; ## [64] &quot;Manchin&quot; &quot;McSally&quot; &quot;Portman&quot; ## [67] &quot;Peters&quot; &quot;Paul&quot; &quot;Perdue&quot; ## [70] &quot;Reed&quot; &quot;Roberts&quot; &quot;Risch&quot; ## [73] &quot;Rubio&quot; &quot;Rounds&quot; &quot;Rosen&quot; ## [76] &quot;Romney&quot; &quot;Sanders&quot; &quot;Schumer&quot; ## [79] &quot;Shelby&quot; &quot;Stabenow&quot; &quot;Shaheen&quot; ## [82] &quot;Scott&quot; &quot;Sinema&quot; &quot;Schatz&quot; ## [85] &quot;Sasse&quot; &quot;Sullivan&quot; &quot;Smith&quot; ## [88] &quot;Scott&quot; &quot;Thune&quot; &quot;Toomey&quot; ## [91] &quot;Tester&quot; &quot;Tillis&quot; &quot;Udall&quot; ## [94] &quot;Van Hollen&quot; &quot;Wicker&quot; &quot;Wyden&quot; ## [97] &quot;Whitehouse&quot; &quot;Warner&quot; &quot;Warren&quot; ## [100] &quot;Young&quot; df_trump_scores$trump_score ## [1] 80.000000 84.848485 14.705882 90.322581 ## [5] 14.705882 88.235294 93.939394 91.176471 ## [9] 15.384615 11.764706 4.166667 94.117647 ## [13] 15.151515 15.151515 11.764706 93.548387 ## [17] 41.176471 93.939394 91.176471 20.588235 ## [21] 84.848485 14.705882 82.352941 90.909091 ## [25] 93.750000 11.764706 18.181818 79.411765 ## [29] 16.129032 90.909091 91.176471 14.705882 ## [33] 88.235294 76.666667 91.176471 7.692308 ## [37] 83.870968 14.705882 20.588235 91.176471 ## [41] 4.545455 14.705882 91.176471 85.294118 ## [45] 90.909091 91.176471 21.212121 7.692308 ## [49] 17.647059 14.705882 88.235294 14.705882 ## [53] 88.235294 63.636364 100.000000 8.823529 ## [57] 91.176471 11.764706 57.575758 14.705882 ## [61] 56.250000 17.647059 11.764706 32.352941 ## [65] 91.176471 84.848485 14.705882 60.714286 ## [69] 92.857143 8.823529 91.176471 90.625000 ## [73] 81.250000 92.857143 12.500000 79.411765 ## [77] 5.263158 11.764706 91.176471 14.705882 ## [81] 14.705882 87.500000 24.242424 11.764706 ## [85] 87.500000 90.322581 17.647059 91.176471 ## [89] 91.176471 84.375000 11.764706 88.235294 ## [93] 17.647059 14.705882 85.294118 8.823529 ## [97] 9.375000 14.705882 9.090909 64.705882 Producto de esto, podemos operar en ellas usando las funciones que aprendimos antes. (Ejercicio C) Calcula la mediana de los Trumps Scores y la mediana de los Trump Margins. Tu código: Ejemplos de análisis con data frames En general, la forma de data frame nos es útil para correr análisis. Aquí un gráfico exploratorio (no miraremos demasiado la sintaxis): ggplot(data = df_trump_scores, mapping = aes(x = trump_margin, trump_score, color = party)) + geom_point() + scale_color_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) Aquí una regresión lineal, que busca estimar el Trump Score de un senador/a de acuerdo a dos predictores: el margen de Trump en su estado y su partido político: mi_modelo &lt;- lm(trump_score ~ trump_margin + party, data = df_trump_scores) summary(mi_modelo) ## ## Call: ## lm(formula = trump_score ~ trump_margin + party, data = df_trump_scores) ## ## Residuals: ## Min 1Q Median 3Q Max ## -40.151 -1.952 1.599 4.487 17.239 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 15.71390 1.40190 11.209 &lt; 2e-16 *** ## trump_margin 0.17650 0.06248 2.825 0.00574 ** ## partyR 66.13619 2.50530 26.399 &lt; 2e-16 *** ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.623 on 97 degrees of freedom ## Multiple R-squared: 0.9463, Adjusted R-squared: 0.9452 ## F-statistic: 854.5 on 2 and 97 DF, p-value: &lt; 2.2e-16 Listas Las listas son objetos que pueden contener otros objetos, sin importar su tipo! mi_lista &lt;- list(mi_objeto, mi_vector, df_trump_scores, mi_modelo) De la siguiente forma podemos acceder a los elementos de una lista, similar a lo que hicimos antes con vectores: mi_lista[3] ## [[1]] ## # A tibble: 100 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 ## 7 Blackburn TN R 93.9 26.0 ## 8 Barrasso WY R 91.2 46.3 ## 9 Bennet CO D 15.4 -4.91 ## 10 Blumenthal CT D 11.8 -13.6 ## # ... with 90 more rows mi_lista[[3]] ## # A tibble: 100 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 ## 7 Blackburn TN R 93.9 26.0 ## 8 Barrasso WY R 91.2 46.3 ## 9 Bennet CO D 15.4 -4.91 ## 10 Blumenthal CT D 11.8 -13.6 ## # ... with 90 more rows ¿Cuál es la diferencia entre estos dos últimos comandos? El primero devuelve una nueva lista con solo un elemento, el tercero de la lista original. El segundo, en tanto, devuelve el contenido del tercer elemento de la lista. Sintaxis de R Markdown En el texto de nuestros documentos podemos escribir en cursiva o negrita. También podemos insertar links. Usualmente cuando queremos hablar de paquetes o funciones dentro de nuestro texto los escribimos entre tildes invertidos: tidyverse, mean(). Crear tablas también es relativamente simple. Con texto: Nombre Descripción Juan Un estudiante Marta Una estudiante O a partir de un data frame, con código: library(knitr) kable(head(df_trump_scores)) last_name state party trump_score trump_margin Alexander TN R 80.00000 26.0057009 Blunt MO R 84.84848 18.6371170 Brown OH D 14.70588 8.1295744 Burr NC R 90.32258 3.6552285 Baldwin WI D 14.70588 0.7643432 Boozman AR R 88.23529 26.9209780 Importante. Por favor noten que la primera tabla ocupa sintaxis de R Markdown en vez de código de R, por lo que no está dentro de un chunk! También podemos incluir ecuaciones, escritas entre signos de peso con la sintaxis de \\(\\LaTeX\\). Un ejemplo: \\(\\hat{\\beta}=(X&#39;X)^{-1}X&#39;Y\\). Título de prueba Subtítulo Una lista Artículo de lista uno Artículo de lista dos Artículo derivado (nota los cuatro espacios antes del símbolo +). Artículo de lista tres Otra lista (ahora ordenada) Artículo de lista uno Artículo de lista dos Artículo de lista tres Nota que los números de la lista aparecerán solos en el documento compilado. Una imagen Podemos insertar una imagen, referenciando su ubicación en nuestra carpeta del proyecto: Compilar nuestro documento Podemos compilar nuestro código a un documento utilizando el botón Knit en RStudio, o presionando Ctrl/Cmd + Shift + K. (Ejercicio D) Crea un vector numérico, que vaya desde 4 hasta 109. Luego, calcula su media y mediana. Recuerda crear tu(s) chunk(s) con Ctrl/Cmd + Alt + i. Siguiente script Pasemos brevemente a ver el script 01b. "],["manejo-02a.html", "02A - Manejo de datos Manejo de bases de datos La base de datos ideal: tidy Operaciones básicas en bases de datos (Wickham, 2014) Trabajo con R Manejo de datos: operaciones básicas Agregar/colapsar con summarize() / hacer operaciones por grupos con group_by() Hacer cadenas de operaciones con las pipes (%&gt;%)", " 02A - Manejo de datos Si quieres correr este script localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (2A, 2B, 2C, 2D): tidyverse, janitor, writexl, learnr. Manejo de bases de datos Manejo de datos = limpiar y ordenar datos para poder analizarlos. Se suele decir que el 80% del análisis de datos es solo manejo (Wickham, 2014). Fuente: Wickham &amp; Grolemund (2017) Partes de una base de datos tabular Encabezado (header) Fila (row) Columna (column) Celda (cell) Una pequeña mnemotecnia: La base de datos ideal: tidy En el paradigma tidy (Wickham, 2014): Cada variable es una columna Cada observación es una fila Cada valor es una celda Existe una base de datos para cada unidad observacional (Ejercicio A) Por favor revisar este link. Contiene un panel para las emisiones anuales de CO2 de los países americanos (unidad de medida: toneladas per capita). Hay tres bases con la misma información, una por cada hoja. ¿Cuál es la tidy? Operaciones básicas en bases de datos (Wickham, 2014) Transformar columnas (añadir o modificar existentes) Puede ser en una sola columna o en múltiples columnas En el tidyverse, mutate() Seleccionar columnas (y excluir otras) En el tidyverse, select() Filtrar observaciones en base a una condición En el tidyverse, filter() Ordenar la base de datos, en base a una(s) variable(s) En el tidyverse, arrange() Agregar/colapsar la base de datos Colapsar múltiples valores en algún resumen (por ejemplo, media o suma) Puede ser para toda la base o por subgrupos En el tidyverse, summarize() (Ejercicio B) Favor ir a este link ¿Qué operaciones básicas pueden ser interesantes para comenzar a analizar estos datos? Contesta con dos ejemplos: Trabajo con R Comenzaremos cargando el tidyverse: library(tidyverse) Base de datos: aprobación de presidentes/as en Latinoamérica Tenemos una base de datos ligeramente editada a partir de Reyes-Housholder (2019). Incluye también un par de variables de los World Development Indicators, recopiladas por Quality of Government. La base de datos se encuentra en datos/base_aprob_reyes-housholder.csv. Contiene información de la aprobación de presidentes/as en 17 países de América Latina por trimestre (2000-2014), además de variables de control. ¿Cuál es la unidad de análisis de la base? ¿Cuántas observaciones tendrá, asumiendo un panel balanceado? Carga de base en formato csv df_aprob &lt;- read_csv(&quot;datos/base_aprob_reyes-housholder.csv&quot;) ## Parsed with column specification: ## cols( ## country = col_character(), ## year = col_double(), ## quarter = col_double(), ## president = col_character(), ## net_approval = col_double(), ## pres_sex = col_character(), ## pres_sex_d = col_double(), ## exec_corr = col_double(), ## gdp_growth = col_double(), ## unemp = col_double(), ## wdi_gdp = col_double(), ## wdi_pop = col_double() ## ) Resúmenes simples para data frames El resumen más simple de un objeto en R suele poder obtenerse con su nombre comando. Nota cómo debajo de cada nombre, algunas variables tienen &lt;dbl&gt; y otras &lt;chr&gt;. ¿Qué significa esto? df_aprob ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Por cierto, podemos obtener un resumen similar clickeando nuestro objeto en el panel Environment (superior derecho) de RStudio. Esto es lo mismo que ocupar el comando View(): View(df_aprob) Otro resumen útil es la función glimpse() del tidyverse, que nos da otra perspectiva: glimpse(df_aprob) ## Rows: 1,020 ## Columns: 12 ## $ country &lt;chr&gt; &quot;Argentina&quot;, &quot;Argentina&quot;, &quot;Argen~ ## $ year &lt;dbl&gt; 2000, 2000, 2000, 2000, 2001, 20~ ## $ quarter &lt;dbl&gt; 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3,~ ## $ president &lt;chr&gt; &quot;Fernando de la Rúa&quot;, &quot;Fernando ~ ## $ net_approval &lt;dbl&gt; 40.126, 16.390, 23.968, -18.254,~ ## $ pres_sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, ~ ## $ pres_sex_d &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~ ## $ exec_corr &lt;dbl&gt; 14.01525, 14.01525, 14.01525, 14~ ## $ gdp_growth &lt;dbl&gt; -0.8, -0.8, -0.8, -0.8, -4.4, -4~ ## $ unemp &lt;dbl&gt; 15.0000, 15.0000, 15.0000, 15.00~ ## $ wdi_gdp &lt;dbl&gt; 552151219031, 552151219031, 5521~ ## $ wdi_pop &lt;dbl&gt; 37057452, 37057452, 37057452, 37~ ¿Qué significan las variables de esta base de datos? Completa la siguiente tabla: Variable Descripción country País. year Año. quarter Trimestre. president Presidente/a. net_approval Aprobación neta del presidente/a (% aprobación - % rechazo). pres_sex pres_sex_d exec_corr Corrupción en el Ejecutivo, según V-Dem. De 0 a 100 (mayor es más corrupción). gdp_growth unemp wdi_gdp Producto interno bruto del país, ajustado por paridad de cambio (PPP) y constante en dólares del 2011. wdi_pop Manejo de datos: operaciones básicas En todas las operaciones básicas que veremos hoy el primer argumento en la función será el data frame a editar. Seleccionar columnas con select() Seleccionemos solo la columna de países: select(df_aprob, country) ## # A tibble: 1,020 x 1 ## country ## &lt;chr&gt; ## 1 Argentina ## 2 Argentina ## 3 Argentina ## 4 Argentina ## 5 Argentina ## 6 Argentina ## 7 Argentina ## 8 Argentina ## 9 Argentina ## 10 Argentina ## # ... with 1,010 more rows Recuerda que esto no creó ningún objeto nuevo, es solo un comando que estamos ejecutando en la consola. Si quisiéramos crear un objeto nuevo, tendríamos que asignarlo: df_aprob_reducida &lt;- select(df_aprob, country) df_aprob_reducida ## # A tibble: 1,020 x 1 ## country ## &lt;chr&gt; ## 1 Argentina ## 2 Argentina ## 3 Argentina ## 4 Argentina ## 5 Argentina ## 6 Argentina ## 7 Argentina ## 8 Argentina ## 9 Argentina ## 10 Argentina ## # ... with 1,010 more rows Podemos seleccionar múltiples columnas a la vez, separadas por comas: select(df_aprob, country, year, unemp) ## # A tibble: 1,020 x 3 ## country year unemp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 2000 15 ## 2 Argentina 2000 15 ## 3 Argentina 2000 15 ## 4 Argentina 2000 15 ## 5 Argentina 2001 18.3 ## 6 Argentina 2001 18.3 ## 7 Argentina 2001 18.3 ## 8 Argentina 2001 18.3 ## 9 Argentina 2002 17.9 ## 10 Argentina 2002 17.9 ## # ... with 1,010 more rows Supongamos que queremos las primeras cinco variables de la base de datos. Las siguientes tres formas nos permitirán obtenerlas: select(df_aprob, country, year, quarter, president, net_approval) ## # A tibble: 1,020 x 5 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows select(df_aprob, country:net_approval) # esta es la forma recomendada para la mayoría de los casos ## # A tibble: 1,020 x 5 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows select(df_aprob, 1:5) ## # A tibble: 1,020 x 5 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows El comando select() también nos sirve para reordenar las columnas. Supongamos que queremos que la variable president sea la primera. Podemos hacer algo como esto: select(df_aprob, president, country:year, net_approval:unemp) ## # A tibble: 1,020 x 9 ## president country year net_approval pres_sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Fernando de la ~ Argent~ 2000 40.1 male ## 2 Fernando de la ~ Argent~ 2000 16.4 male ## 3 Fernando de la ~ Argent~ 2000 24.0 male ## 4 Fernando de la ~ Argent~ 2000 -18.3 male ## 5 Fernando de la ~ Argent~ 2001 -6.97 male ## 6 Fernando de la ~ Argent~ 2001 -20.1 male ## 7 Fernando de la ~ Argent~ 2001 -19.4 male ## 8 Fernando de la ~ Argent~ 2001 -23.2 male ## 9 Eduardo Alberto~ Argent~ 2002 -2.01 male ## 10 Eduardo Alberto~ Argent~ 2002 -20.1 male ## # ... with 1,010 more rows, and 4 more variables: ## # pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt; Esta forma es un poco tediosa. Hay una función de ayuda que nos será útil en este caso, se llama everything() select(df_aprob, president, everything()) # selecciona &quot;president&quot; y todo lo demás ## # A tibble: 1,020 x 12 ## president country year quarter net_approval ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Fernando de la ~ Argenti~ 2000 1 40.1 ## 2 Fernando de la ~ Argenti~ 2000 2 16.4 ## 3 Fernando de la ~ Argenti~ 2000 3 24.0 ## 4 Fernando de la ~ Argenti~ 2000 4 -18.3 ## 5 Fernando de la ~ Argenti~ 2001 1 -6.97 ## 6 Fernando de la ~ Argenti~ 2001 2 -20.1 ## 7 Fernando de la ~ Argenti~ 2001 3 -19.4 ## 8 Fernando de la ~ Argenti~ 2001 4 -23.2 ## 9 Eduardo Alberto~ Argenti~ 2002 1 -2.01 ## 10 Eduardo Alberto~ Argenti~ 2002 2 -20.1 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Finalmente, también podemos excluir variables con un signo -: select(df_aprob, -president) ## # A tibble: 1,020 x 11 ## country year quarter net_approval pres_sex ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argentina 2000 1 40.1 male ## 2 Argentina 2000 2 16.4 male ## 3 Argentina 2000 3 24.0 male ## 4 Argentina 2000 4 -18.3 male ## 5 Argentina 2001 1 -6.97 male ## 6 Argentina 2001 2 -20.1 male ## 7 Argentina 2001 3 -19.4 male ## 8 Argentina 2001 4 -23.2 male ## 9 Argentina 2002 1 -2.01 male ## 10 Argentina 2002 2 -20.1 male ## # ... with 1,010 more rows, and 6 more variables: ## # pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Renombrar columnas con rename() Podemos cambiar el nombre de una columna con el comando rename(). Por ejemplo: rename(df_aprob, trimeste = quarter) # noten que no estoy modificando la base, solo imprimiéndola! ## # A tibble: 1,020 x 12 ## country year trimeste president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Albert~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Albert~ -20.1 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Filtrar observaciones con filter() A menudo queremos quedarnos solo con algunas observaciones de nuestra base de datos, filtrando de acuerdo a características específicas. Podemos hacer esto gracias a la función filter() y algo llamado operadores lógicos. Para comenzar, quedémonos solo con las observaciones de Chile: filter(df_aprob, country == &quot;Chile&quot;) ## # A tibble: 60 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Chile 2000 1 Eduardo Frei Rui~ 6.22 ## 2 Chile 2000 2 Ricardo Lagos Es~ 19.8 ## 3 Chile 2000 3 Ricardo Lagos Es~ 19.5 ## 4 Chile 2000 4 Ricardo Lagos Es~ 14.8 ## 5 Chile 2001 1 Ricardo Lagos Es~ 7.99 ## 6 Chile 2001 2 Ricardo Lagos Es~ 1.81 ## 7 Chile 2001 3 Ricardo Lagos Es~ -1.40 ## 8 Chile 2001 4 Ricardo Lagos Es~ 6.90 ## 9 Chile 2002 1 Ricardo Lagos Es~ 6.60 ## 10 Chile 2002 2 Ricardo Lagos Es~ 3.65 ## # ... with 50 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Le estamos diciendo a filter(), por medio del segundo argumento, que solo se quede con observaciones en las que la variable country es igual a Chile. Este es igual a es un operador lógico, que se escribe como == en R. Aquí hay una lista de operadores lógicos comunes: operador descripción == es igual a != es distinto a &gt; es mayor a &lt; es menor a &gt;= es mayor o igual a &lt;= es menor o igual a &amp; intersección | unión %in% está contenido en Por ejemplo, podemos obtener todas las observaciones (país-año-trimestre) en las que la aprobación presidencial neta es positiva: filter(df_aprob, net_approval &gt; 0) ## # A tibble: 709 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2003 2 Eduardo Alberto~ 26.5 ## 5 Argenti~ 2003 3 Néstor Carlos K~ 53.7 ## 6 Argenti~ 2003 4 Néstor Carlos K~ 53.0 ## 7 Argenti~ 2004 1 Néstor Carlos K~ 57.1 ## 8 Argenti~ 2004 2 Néstor Carlos K~ 52.8 ## 9 Argenti~ 2004 3 Néstor Carlos K~ 39.1 ## 10 Argenti~ 2004 4 Néstor Carlos K~ 44.9 ## # ... with 699 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Podemos también realizar filtros más complejos. Obtengamos solo las observaciones del Cono Sur: filter(df_aprob, country == &quot;Argentina&quot; | country == &quot;Chile&quot; | country == &quot;Uruguay&quot;) ## # A tibble: 180 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 170 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; filter(df_aprob, country %in% c(&quot;Argentina&quot;, &quot;Chile&quot;, &quot;Uruguay&quot;)) # lo mismo, con otro op. lógico ## # A tibble: 180 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 170 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Podemos también incluir pequeñas operaciones en nuestros filtros. Obtengamos todas las observaciones en las que la corrupción ejecutiva es mayor a la del promedio de toda la base: filter(df_aprob, exec_corr &gt; mean(exec_corr)) ## # A tibble: 456 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2003 1 Eduardo Alberto~ -2.78 ## 2 Argenti~ 2003 2 Eduardo Alberto~ 26.5 ## 3 Argenti~ 2003 3 Néstor Carlos K~ 53.7 ## 4 Argenti~ 2003 4 Néstor Carlos K~ 53.0 ## 5 Argenti~ 2004 1 Néstor Carlos K~ 57.1 ## 6 Argenti~ 2004 2 Néstor Carlos K~ 52.8 ## 7 Argenti~ 2004 3 Néstor Carlos K~ 39.1 ## 8 Argenti~ 2004 4 Néstor Carlos K~ 44.9 ## 9 Argenti~ 2005 1 Néstor Carlos K~ 45.7 ## 10 Argenti~ 2005 2 Néstor Carlos K~ 45.4 ## # ... with 446 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; (Ejercicios C) (C1) Selecciona solo las dos columnas que registran el sexo del presidente/a en la base de datos. Recuerda que los chunks se insertan con Ctrl/Cmd + Alt + i. Tu código: (C2) Filtra la base de datos para que solo tenga las observaciones del año 2000. Tu código: (C3) Filtra la base de datos para que solo incluya observaciones de crisis económica: cuando el crecimiento del PIB sea negativo y/o el desempleo sea mayor al 20%. Tu código: Ordenar el data frame con arrange() Podemos cambiar el orden de las observaciones con el comando arrange(). Por ejemplo, ordenémoslas desde el país-año-trimestre menos corrupto al más corrupto: arrange(df_aprob, exec_corr) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Uruguay 2000 1 Julio Sanguietti 41.2 ## 2 Uruguay 2000 2 Jorge Battle 45.4 ## 3 Uruguay 2000 3 Jorge Battle 31.4 ## 4 Uruguay 2000 4 Jorge Battle 18.1 ## 5 Uruguay 2001 1 Jorge Battle 18.5 ## 6 Uruguay 2001 2 Jorge Battle 17.8 ## 7 Uruguay 2001 3 Jorge Battle 15.9 ## 8 Uruguay 2001 4 Jorge Battle 14.5 ## 9 Uruguay 2002 1 Jorge Battle 6.36 ## 10 Uruguay 2002 2 Jorge Battle -6.37 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Si quisiéramos ordenarlo inversamente, tendríamos que añadir un - (signo menos) antes de la variable: arrange(df_aprob, -exec_corr) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Venezuela 2013 1 Hugo Chávez -12.6 ## 2 Venezuela 2013 2 Nicolás Maduro -13.7 ## 3 Venezuela 2013 3 Nicolás Maduro -16.8 ## 4 Venezuela 2013 4 Nicolás Maduro -16.6 ## 5 Venezuela 2014 1 Nicolás Maduro -18.1 ## 6 Venezuela 2014 2 Nicolás Maduro -19.4 ## 7 Venezuela 2014 3 Nicolás Maduro -22.1 ## 8 Venezuela 2014 4 Nicolás Maduro -24.9 ## 9 Venezuela 2007 1 Hugo Chávez -10.2 ## 10 Venezuela 2007 2 Hugo Chávez -11.0 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Atención, lo anterior solo sirve en columnas numéricas. Para ordenar una categórica inversamente, debemos usar el comando desc(): arrange(df_aprob, desc(country)) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Venezuela 2000 1 Hugo Chávez -7.14 ## 2 Venezuela 2000 2 Hugo Chávez -10.6 ## 3 Venezuela 2000 3 Hugo Chávez -11.2 ## 4 Venezuela 2000 4 Hugo Chávez -11.1 ## 5 Venezuela 2001 1 Hugo Chávez -10.4 ## 6 Venezuela 2001 2 Hugo Chávez -11.7 ## 7 Venezuela 2001 3 Hugo Chávez -14.5 ## 8 Venezuela 2001 4 Hugo Chávez -19.5 ## 9 Venezuela 2002 1 Hugo Chávez -21.5 ## 10 Venezuela 2002 2 Hugo Chávez -20.8 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Podemos ordenar por más de una variable. Esto es, ordenar a partir de una primera variable y luego ordenar los empates a partir de otra segunda variable. Veamos el siguiente ejemplo: arrange(df_aprob, pres_sex, -net_approval) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Brazil 2013 1 Dilma Vana Rous~ 62.5 ## 2 Brazil 2012 4 Dilma Vana Rous~ 60.9 ## 3 Brazil 2012 2 Dilma Vana Rous~ 60.5 ## 4 Brazil 2012 3 Dilma Vana Rous~ 58.7 ## 5 Brazil 2012 1 Dilma Vana Rous~ 57.2 ## 6 Brazil 2011 4 Dilma Vana Rous~ 54.3 ## 7 Brazil 2011 1 Dilma Vana Rous~ 47.7 ## 8 Brazil 2011 3 Dilma Vana Rous~ 45.6 ## 9 Brazil 2013 2 Dilma Vana Rous~ 44.4 ## 10 Argenti~ 2011 4 Cristina Fernán~ 44.3 ## # ... with 1,010 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt; Transformar variables con mutate() Transformaciones con una variable Supongamos que queremos crear una variable con el PIB en versión logarítmica: mutate(df_aprob, wdi_gdp_log = log(wdi_gdp)) ## # A tibble: 1,020 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt;, wdi_gdp_log &lt;dbl&gt; Podemos realizar cualquier tipo de operación en las variables. Por ejemplo, transformemos la escala de wdi_pop a millones: mutate(df_aprob, wdi_pop_mill = wdi_pop / 1000000) ## # A tibble: 1,020 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt;, wdi_pop_mill &lt;dbl&gt; Transformaciones con múltiples variables Crucialmente, podemos generar operaciones entre las variables. Por ejemplo, calculemos el GDP per capita: mutate(df_aprob, wdi_gdp_pc = wdi_gdp / wdi_pop) ## # A tibble: 1,020 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt;, wdi_gdp_pc &lt;dbl&gt; Varias transformaciones a la vez: Algo como lo siguiente funcionará: mutate(df_aprob, wdi_pop_mill = wdi_pop / 1000000, wdi_gdp_pc = wdi_gdp / wdi_pop) ## # A tibble: 1,020 x 14 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 1,010 more rows, and 9 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt;, wdi_pop_mill &lt;dbl&gt;, ## # wdi_gdp_pc &lt;dbl&gt; (Ejercicio D) Crea un nuevo data frame, que esté ordenado desde el país-año-trimeste con menor aprobación presidencial al con mayor aprobación presidencial (recuerda crear el nuevo objeto y ponerle un buen nombre!). Tu código: En tu nuevo objeto, obtén solo con las observaciones que tengan presidentas. Tu código: Crea una nueva variable, que registre el desempleo como proporción en vez de porcentaje. Tu código: Agregar/colapsar con summarize() / hacer operaciones por grupos con group_by() Podemos hacer resúmenes para la base de datos con summarize: summarize(df_aprob, prom_desemp = mean(unemp)) ## # A tibble: 1 x 1 ## prom_desemp ## &lt;dbl&gt; ## 1 7.04 Como antes, podemos hacer varios a la vez: summarize(df_aprob, prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 1 x 3 ## prom_desemp prom_crec prom_aprob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7.04 3.77 15.3 Resúmenes agrupados Lo realmente interesante es hacer resúmenes por grupos. Primero debemos tener una versión agrupada de la base de datos. Esta es igual que nuestra base original, pero R sabe que las siguientes operaciones que realicemos en ella deberán ser agrupadas (veamos la ligera diferencia cuando hacemos un resumen con glimpse()) df_aprob_por_pais &lt;- group_by(df_aprob, country) glimpse(df_aprob_por_pais) ## Rows: 1,020 ## Columns: 12 ## Groups: country [17] ## $ country &lt;chr&gt; &quot;Argentina&quot;, &quot;Argentina&quot;, &quot;Argen~ ## $ year &lt;dbl&gt; 2000, 2000, 2000, 2000, 2001, 20~ ## $ quarter &lt;dbl&gt; 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3,~ ## $ president &lt;chr&gt; &quot;Fernando de la Rúa&quot;, &quot;Fernando ~ ## $ net_approval &lt;dbl&gt; 40.126, 16.390, 23.968, -18.254,~ ## $ pres_sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, ~ ## $ pres_sex_d &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,~ ## $ exec_corr &lt;dbl&gt; 14.01525, 14.01525, 14.01525, 14~ ## $ gdp_growth &lt;dbl&gt; -0.8, -0.8, -0.8, -0.8, -4.4, -4~ ## $ unemp &lt;dbl&gt; 15.0000, 15.0000, 15.0000, 15.00~ ## $ wdi_gdp &lt;dbl&gt; 552151219031, 552151219031, 5521~ ## $ wdi_pop &lt;dbl&gt; 37057452, 37057452, 37057452, 37~ Hagamos una operación de resumen en esta nueva base: summarize(df_aprob_por_pais, prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 17 x 4 ## country prom_desemp prom_crec prom_aprob ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 11.0 2.72 16.7 ## 2 Bolivia 3.70 4.24 11.3 ## 3 Brazil 8.35 3.4 34.2 ## 4 Chile 8.18 4.33 5.71 ## 5 Colombia 12.5 4.35 27.1 ## 6 Costa Rica 6.73 4.15 14.5 ## 7 Ecuador 6.76 4.31 37.1 ## 8 El Salvador 5.75 1.87 39.1 ## 9 Guatemala 2.80 3.47 5.44 ## 10 Honduras 4.22 4.08 12.7 ## 11 Mexico 3.99 2.10 28.9 ## 12 Nicaragua 6.78 3.73 16.2 ## 13 Panama 8.45 6.31 14.2 ## 14 Paraguay 5.69 3.66 10.9 ## 15 Peru 4.32 5.30 -26.2 ## 16 Uruguay 10.3 3.08 26.9 ## 17 Venezuela 10.3 3.04 -14.8 Hacer cadenas de operaciones con las pipes (%&gt;%) La mayor parte del tiempo queremos hacer más de una operación en una base de datos. Por ejemplo, podríamos querer (1) crear una nueva variable con PIB per capita, y luego (2) filtrar las observaciones con valores iguales o mayores a la media de PIB per capita en toda la base: df_aprob_con_pib_pc &lt;- mutate(df_aprob, pib_pc = wdi_gdp / wdi_pop) filter(df_aprob_con_pib_pc, pib_pc &gt; mean(pib_pc)) ## # A tibble: 492 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 482 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt;, pib_pc &lt;dbl&gt; Esta misma cadena de operaciones se puede escribir de la siguiente forma: df_aprob %&gt;% mutate(pib_pc = wdi_gdp / wdi_pop) %&gt;% filter(pib_pc &gt; mean(pib_pc)) ## # A tibble: 492 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando de la ~ 40.1 ## 2 Argenti~ 2000 2 Fernando de la ~ 16.4 ## 3 Argenti~ 2000 3 Fernando de la ~ 24.0 ## 4 Argenti~ 2000 4 Fernando de la ~ -18.3 ## 5 Argenti~ 2001 1 Fernando de la ~ -6.97 ## 6 Argenti~ 2001 2 Fernando de la ~ -20.1 ## 7 Argenti~ 2001 3 Fernando de la ~ -19.4 ## 8 Argenti~ 2001 4 Fernando de la ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo Alberto~ -2.01 ## 10 Argenti~ 2002 2 Eduardo Alberto~ -20.1 ## # ... with 482 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, ## # wdi_pop &lt;dbl&gt;, pib_pc &lt;dbl&gt; ¡Este código es sorprendemente legible! Las pipes (%&gt;%) se leen como luego (o pero luego) y se insertan con Ctrl/Cmd + Shift + M en RStudio. Pueden ver todos los atajos de teclado en Help &gt; Keyboard Shortcuts Help. Uno de los usos más comunes de las pipes es el combo group_by() + summarize(). Repitamos nuestras operaciones de antes para hacer un resumen agrupado: df_aprob %&gt;% group_by(country) %&gt;% summarize(prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 17 x 4 ## country prom_desemp prom_crec prom_aprob ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 11.0 2.72 16.7 ## 2 Bolivia 3.70 4.24 11.3 ## 3 Brazil 8.35 3.4 34.2 ## 4 Chile 8.18 4.33 5.71 ## 5 Colombia 12.5 4.35 27.1 ## 6 Costa Rica 6.73 4.15 14.5 ## 7 Ecuador 6.76 4.31 37.1 ## 8 El Salvador 5.75 1.87 39.1 ## 9 Guatemala 2.80 3.47 5.44 ## 10 Honduras 4.22 4.08 12.7 ## 11 Mexico 3.99 2.10 28.9 ## 12 Nicaragua 6.78 3.73 16.2 ## 13 Panama 8.45 6.31 14.2 ## 14 Paraguay 5.69 3.66 10.9 ## 15 Peru 4.32 5.30 -26.2 ## 16 Uruguay 10.3 3.08 26.9 ## 17 Venezuela 10.3 3.04 -14.8 (Ejercicios E-G) E. Calcula, ayudándote de las pipes, la mediana por país de corrupción ejecutiva y PIB. Recuerda que puedes insertar chunks con Ctrl/Cmd + Alt + i y pipes con Ctrl/Cmd + Shift + M. Tu código: F. De nuevo usando pipes, ordena los países en la base desde el que tuvo el mayor PIB per cápita promedio en el período 2010-2014 hasta el que tuvo el menor. Tu código: G. ¿Qué país-año-trimestre, entre los gobernados por mujeres, tuvo la corrupción ejecutiva más alta? ¿Y la aprobación neta más alta? "],["manejo-02b.html", "02B - Manejo de datos (ejercicio) Contexto", " 02B - Manejo de datos (ejercicio) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica en el script 02A. Recomiendo reiniciar R antes de comenzar: Session &gt; Restart R y click en la escoba del panel de Environment (superior derecho). Contexto La base de datos de este ejercicio guarda relación con la política monetaria ante la Gran Depresión. En especial, trata sobre la crisis en Mississippi, donde la administración central de los bancos estaba en manos de Bancos Centrales con distintas políticas: el Banco Central de Atlanta, encargado del Distrito 6, estuvo a favor de prestarle dinero a los bancos en problemas. En cambio, el Banco Central de St. Louis se encargó del Distrito 8 de acuerdo a la Doctrica de las Letras Reales, que sostiene que los Bancos Centrales deben restringir el crédito durante una recesión económica (Angrist &amp; Pischke, 2014, cap. 5) ¿Qué política monetaria fue más efectiva para combatir la crisis desde la perspectiva financiera? Podemos analizar cuántos bancos quebraron a cada lado de la política para entender mejor esto. A. Comienza cargando el tidyverse y la base de datos, que se encuentra en la carpeta datos (recuerda ponerle un buen nombre). El nombre del archivo es banks2.csv. Tu código: B. Analiza la base. ¿Qué información tiene? ¿Cuál es la unidad de análisis? Considera que bib significa banks in business. Tu respuesta: C. Obtén solo las observaciones del primero de julio de cada año. Esto nos permitirá analizar patrones anuales. Crea una nueva base de datos con esta nueva unidad de análisis. Tu código: D. Revisa el archivo de ayuda de la función diff(). Para cada zona de Banco Central, ¿cuál es la diferencia de bancos en operación al comparar 1929 con 1934? Tu código: E. Repite el ejercicio anterior, pero calculando la diferencia en términos proporcionales. Tu código: F. ¿En qué mes del año (enero, febrero, etc.) fueron más pronunciados los cierres de bancos, en promedio? "],["manejo-02c.html", "02C - Manejo de datos (extras) Cargar y guardar bases de datos Versiones iterativas de summarize() y mutate()", " 02C - Manejo de datos (extras) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica en el script 02A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de Environment (superior derecho). Ahora carguemos los paquetes que usaremos: library(tidyverse) library(readxl) # leer datos de Excel ## install.packages(c(&quot;janitor&quot;, &quot;writexl&quot;)) library(janitor) # limpiar bases ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test library(writexl) # guardar bases de Excel Cargar y guardar bases de datos Cargar desde múltiples formatos Hay múltiples formatos en los podemos encontrar bases de datos tabulares. Por suerte, la consistencia del tidyverse nos permite usar funciones muy similares para trabajar con ellas en R (Araya y Cruz, 2019). Extensión Descripción Función .csv Archivo delimitado por comas read_csv() .dta Stata (suele incluir etiquetas) haven::read_stata() .Rdata R (puede tener múltiples objetos) load() .rds R (un solo objeto) read_rds() .sav SPSS (suele incluir etiquetas) haven::read_spss() .xlsx Excel 2007- writexl::read_excel() Limpiar nombres de columnas En esta ocasión cargaremos unos datos en formato Excel. Es muy común encontrar datos que tienen este tipo de extensión, y en general no vienen demasiado limpios (el trabajo con planillas no necesariamente se hace pensando en el procesamiento con código). Inspeccionémoslos visualmente. Son datos de casos policiales en 2016 para 340 comunas de Chile, recolectados desde la Subsecretaría de Prevención del Delito (2017). Habiendo cargando el paquete readxl antes, la sintaxis para cargar los datos será familiar: df_casos_policiales &lt;- read_excel(&quot;datos/casos_delitos_por_comuna.xlsx&quot;) glimpse(df_casos_policiales) ## Rows: 340 ## Columns: 17 ## $ Comuna &lt;chr&gt; ~ ## $ `Comuna ID` &lt;dbl&gt; ~ ## $ `Región ID` &lt;dbl&gt; ~ ## $ `Población (INE 2017)` &lt;dbl&gt; ~ ## $ `Robos con violencia o intimidación` &lt;dbl&gt; ~ ## $ `Robos por sorpresa` &lt;dbl&gt; ~ ## $ `Robos de vehículo motorizado` &lt;dbl&gt; ~ ## $ `Robos de objeto de o desde vehículo` &lt;dbl&gt; ~ ## $ `Robos en lugar habitado` &lt;dbl&gt; ~ ## $ `Robos en lugar no habitado` &lt;dbl&gt; ~ ## $ `Otros robos con fuerza` &lt;dbl&gt; ~ ## $ Hurtos &lt;dbl&gt; ~ ## $ `Lesiones menos graves, graves o gravísimas` &lt;dbl&gt; ~ ## $ `Lesiones leves` &lt;dbl&gt; ~ ## $ Homicidios &lt;dbl&gt; ~ ## $ Violaciones &lt;dbl&gt; ~ ## $ VIF &lt;dbl&gt; ~ Los nombres de las columnas en la base tienen mayúsculas, espacios y tildes, lo que nos puede generar problemas en el análisis. La convención en el tidyverse es nombrar utilizando snake_case (nombre_de_mi_objeto), sin mayúsculas, espacios ni tildes. Esto nos ahorrará muchos problemas. Si ya tenemos una base de datos y queremos estandarizar sus variables, el paquete janitor provee la función clean_names() para esto: df_casos_policiales_l &lt;- df_casos_policiales %&gt;% clean_names() glimpse(df_casos_policiales_l) ## Rows: 340 ## Columns: 17 ## $ comuna &lt;chr&gt; &quot;Al~ ## $ comuna_id &lt;dbl&gt; 560~ ## $ region_id &lt;dbl&gt; 5, ~ ## $ poblacion_ine_2017 &lt;dbl&gt; 107~ ## $ robos_con_violencia_o_intimidacion &lt;dbl&gt; 23,~ ## $ robos_por_sorpresa &lt;dbl&gt; 11,~ ## $ robos_de_vehiculo_motorizado &lt;dbl&gt; 9, ~ ## $ robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt; 56,~ ## $ robos_en_lugar_habitado &lt;dbl&gt; 384~ ## $ robos_en_lugar_no_habitado &lt;dbl&gt; 80,~ ## $ otros_robos_con_fuerza &lt;dbl&gt; 5, ~ ## $ hurtos &lt;dbl&gt; 184~ ## $ lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt; 22,~ ## $ lesiones_leves &lt;dbl&gt; 52,~ ## $ homicidios &lt;dbl&gt; 0, ~ ## $ violaciones &lt;dbl&gt; 1, ~ ## $ vif &lt;dbl&gt; 129~ (Ejercicios A-B) A. ¿Cuál fue la comuna con más homicidios en Chile en el año 2016? Tu código: B. ¿Cuál fue la comuna con más casos de violencia intrafamiliar por cada 1000 habitantes? Tu código: Crear bases de datos a mano A veces queremos crear un data frame arbitrariamente a partir de vectores. Para esto, la funcióm tibble() es simple y útil: df_ejemplo &lt;- tibble( x = c(1:10), y = c(9, 10, 1:8) ) df_ejemplo ## # A tibble: 10 x 2 ## x y ## &lt;int&gt; &lt;dbl&gt; ## 1 1 9 ## 2 2 10 ## 3 3 1 ## 4 4 2 ## 5 5 3 ## 6 6 4 ## 7 7 5 ## 8 8 6 ## 9 9 7 ## 10 10 8 Guardar bases de datos Guardar una base de datos es necesario para compartirla con colegas o usarla en otros proyectos. La mayoría de las funciones que vimos, que comienzan con read_, tienen su versión write_ para este propósito. Por ejemplo, read_csv() -&gt; write_csv(). El único par de comandos en los que hay algo distinto es readxl::read_excel() -&gt; writexl::write_xlsx(). En general, los mejores formatos para guardar bases son .csv (muy universal) y .rds (nos aseguramos de que cualquier cosa extraña en nuestros datos pueda volver bien a R). Guardemos los datos en formatos .csv, .rds y .xlsx (Excel). Recuerda que ya cargamos antes el paquete writexl, que nos permite hacer esto último. write_csv(df_ejemplo, &quot;datos/df_ejemplo.csv&quot;) write_csv(df_ejemplo, &quot;datos/df_ejemplo.rds&quot;) write_xlsx(df_ejemplo, &quot;datos/df_ejemplo.xlsx&quot;) Podríamos volver a cargarlo con read_excel(): df_ejemplo_comprob &lt;- read_excel(&quot;datos/df_ejemplo.xlsx&quot;) df_ejemplo_comprob ## # A tibble: 10 x 2 ## x y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 9 ## 2 2 10 ## 3 3 1 ## 4 4 2 ## 5 5 3 ## 6 6 4 ## 7 7 5 ## 8 8 6 ## 9 9 7 ## 10 10 8 (Ejercicio) Guarda una versión de la base de datos de delitos, en formato csv. Utiliza la versión con los nombres de columnas limpios y excluye la variable de región. Tu código: Versiones iterativas de summarize() y mutate() Es común necesitar hacer una misma operación en múltiples columnas de una base. Por ejemplo, podríamos querer los totales de delitos específicos por región, como muestra el siguiente chunk. df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize(lesiones_leves_total = sum(lesiones_leves), hurtos_total = sum(hurtos)) ## # A tibble: 16 x 3 ## region_id lesiones_leves_total hurtos_total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1523 3935 ## 2 2 3014 8257 ## 3 3 1253 2953 ## 4 4 2830 6613 ## 5 5 6955 19537 ## 6 6 3347 8553 ## 7 7 2368 7371 ## 8 8 4549 13698 ## 9 9 3227 9808 ## 10 10 2824 9575 ## 11 11 486 1169 ## 12 12 525 1568 ## 13 13 22796 65621 ## 14 14 1269 3783 ## 15 15 733 1762 ## 16 16 1250 3644 Sin embargo, hacer este código para los 13 tipos de delito es una pérdida de tiempo: generaría código particularmente difícil de leer. Podemos aplicar la función summarize_at() para usar la función de suma en múltiples variables. Noten cómo en el código siguiente . reemplazará a la variable en la definición de la operación (gracias al operador ~). df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = ~sum(.)) ## # A tibble: 16 x 14 ## region_id robos_con_violencia_o_in~ robos_por_sorpr~ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 1499 ## 2 2 1930 1173 ## 3 3 832 379 ## 4 4 1667 1106 ## 5 5 5777 4537 ## 6 6 1629 1011 ## 7 7 1108 852 ## 8 8 4646 2664 ## 9 9 1547 1331 ## 10 10 1025 728 ## 11 11 71 26 ## 12 12 112 29 ## 13 13 41541 19168 ## 14 14 424 339 ## 15 15 618 451 ## 16 16 605 513 ## # ... with 11 more variables: ## # robos_de_vehiculo_motorizado &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt;, ## # robos_en_lugar_habitado &lt;dbl&gt;, ## # robos_en_lugar_no_habitado &lt;dbl&gt;, ## # otros_robos_con_fuerza &lt;dbl&gt;, hurtos &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt;, ## # lesiones_leves &lt;dbl&gt;, homicidios &lt;dbl&gt;, ## # violaciones &lt;dbl&gt;, vif &lt;dbl&gt; Incluso podemos editar un poco los nombres de los resúmenes, asignándolos como elementos en una lista. Noten cómo van a cambiar dichos nombres, terminando ahora en \"_total\": df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(total = ~sum(.))) ## # A tibble: 16 x 14 ## region_id robos_con_violencia_o_~ robos_por_sorpres~ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 1499 ## 2 2 1930 1173 ## 3 3 832 379 ## 4 4 1667 1106 ## 5 5 5777 4537 ## 6 6 1629 1011 ## 7 7 1108 852 ## 8 8 4646 2664 ## 9 9 1547 1331 ## 10 10 1025 728 ## 11 11 71 26 ## 12 12 112 29 ## 13 13 41541 19168 ## 14 14 424 339 ## 15 15 618 451 ## 16 16 605 513 ## # ... with 11 more variables: ## # robos_de_vehiculo_motorizado_total &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_total &lt;dbl&gt;, ## # robos_en_lugar_habitado_total &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_total &lt;dbl&gt;, ## # otros_robos_con_fuerza_total &lt;dbl&gt;, ## # hurtos_total &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_total &lt;dbl&gt;, ## # lesiones_leves_total &lt;dbl&gt;, ## # homicidios_total &lt;dbl&gt;, violaciones_total &lt;dbl&gt;, ## # vif_total &lt;dbl&gt; También podemos utilizar más de una función de resumen a la vez en nuestros datos: df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(total = ~sum(.), max = ~max(.))) ## # A tibble: 16 x 27 ## region_id robos_con_violencia_o_~ robos_por_sorpres~ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 1499 ## 2 2 1930 1173 ## 3 3 832 379 ## 4 4 1667 1106 ## 5 5 5777 4537 ## 6 6 1629 1011 ## 7 7 1108 852 ## 8 8 4646 2664 ## 9 9 1547 1331 ## 10 10 1025 728 ## 11 11 71 26 ## 12 12 112 29 ## 13 13 41541 19168 ## 14 14 424 339 ## 15 15 618 451 ## 16 16 605 513 ## # ... with 24 more variables: ## # robos_de_vehiculo_motorizado_total &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_total &lt;dbl&gt;, ## # robos_en_lugar_habitado_total &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_total &lt;dbl&gt;, ## # otros_robos_con_fuerza_total &lt;dbl&gt;, ## # hurtos_total &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_total &lt;dbl&gt;, ## # lesiones_leves_total &lt;dbl&gt;, ## # homicidios_total &lt;dbl&gt;, violaciones_total &lt;dbl&gt;, ## # vif_total &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion_max &lt;dbl&gt;, ## # robos_por_sorpresa_max &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_max &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_max &lt;dbl&gt;, ## # robos_en_lugar_habitado_max &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_max &lt;dbl&gt;, ## # otros_robos_con_fuerza_max &lt;dbl&gt;, ## # hurtos_max &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_max &lt;dbl&gt;, ## # lesiones_leves_max &lt;dbl&gt;, homicidios_max &lt;dbl&gt;, ## # violaciones_max &lt;dbl&gt;, vif_max &lt;dbl&gt; Aparte de hacer resúmenes, crear múltiples variables según una misma operación es bastante común. Supongamos que queremos las cifras relativas (tasas) para cada tipo de delito, como en el siguiente ejemplo: df_casos_policiales_l %&gt;% mutate(lesiones_leves_c1000 = lesiones_leves * 1000 / poblacion_ine_2017) %&gt;% select(comuna, poblacion_ine_2017, lesiones_leves, lesiones_leves_c1000) # solo para legibilidad ## # A tibble: 340 x 4 ## comuna poblacion_ine_2017 lesiones_leves ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algarrobo 10700 52 ## 2 Alhué 5916 26 ## 3 Alto-Biobío 5957 24 ## 4 Alto-del-Carmen 6519 8 ## 5 Alto-Hospicio 124872 523 ## 6 Ancud 44249 132 ## 7 Andacollo 11555 77 ## 8 Angol 55845 244 ## 9 Antártica 202 0 ## 10 Antofagasta 389812 1528 ## # ... with 330 more rows, and 1 more variable: ## # lesiones_leves_c1000 &lt;dbl&gt; Podemos utilizar mutate_at() para repetir esta operación en todas nuestras variables de interés. df_casos_policiales_l %&gt;% mutate_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(c1000 = ~ . * 1000 / poblacion_ine_2017)) ## # A tibble: 340 x 30 ## comuna comuna_id region_id poblacion_ine_20~ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algarrobo 5602 5 10700 ## 2 Alhué 13502 13 5916 ## 3 Alto-Biobío 8314 8 5957 ## 4 Alto-del-Carm~ 3302 3 6519 ## 5 Alto-Hospicio 1107 1 124872 ## 6 Ancud 10202 10 44249 ## 7 Andacollo 4103 4 11555 ## 8 Angol 9201 9 55845 ## 9 Antártica 12202 12 202 ## 10 Antofagasta 2101 2 389812 ## # ... with 330 more rows, and 26 more variables: ## # robos_con_violencia_o_intimidacion &lt;dbl&gt;, ## # robos_por_sorpresa &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt;, ## # robos_en_lugar_habitado &lt;dbl&gt;, ## # robos_en_lugar_no_habitado &lt;dbl&gt;, ## # otros_robos_con_fuerza &lt;dbl&gt;, hurtos &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt;, ## # lesiones_leves &lt;dbl&gt;, homicidios &lt;dbl&gt;, ## # violaciones &lt;dbl&gt;, vif &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion_c1000 &lt;dbl&gt;, ## # robos_por_sorpresa_c1000 &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_c1000 &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_c1000 &lt;dbl&gt;, ## # robos_en_lugar_habitado_c1000 &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_c1000 &lt;dbl&gt;, ## # otros_robos_con_fuerza_c1000 &lt;dbl&gt;, ## # hurtos_c1000 &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_c1000 &lt;dbl&gt;, ## # lesiones_leves_c1000 &lt;dbl&gt;, ## # homicidios_c1000 &lt;dbl&gt;, violaciones_c1000 &lt;dbl&gt;, ## # vif_c1000 &lt;dbl&gt; (Ejercicio C) Si queremos obtener un promedio por región en datos como estos, debemos calcular un promedio ponderado: si es que no hacemos esto, comunas con pocos habitantes estarán sobrerrepresentadas en los promedios. Un ejemplo a continuación: df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize(prom_hurtos = weighted.mean(hurtos, w = poblacion_ine_2017)) ## # A tibble: 16 x 2 ## region_id prom_hurtos ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1968. ## 2 2 3941. ## 3 3 1216. ## 4 4 1543. ## 5 5 2039. ## 6 6 1139. ## 7 7 1305. ## 8 8 1304. ## 9 9 1608. ## 10 10 1826. ## 11 11 513. ## 12 12 990. ## 13 13 2329. ## 14 14 1064. ## 15 15 1711. ## 16 16 938. Para cada tipo de delito, obtén el promedio ponderado por región. Tu código: "],["manejo-02d.html", "02D - Manejo de datos (ejercicio int.)", " 02D - Manejo de datos (ejercicio int.) Este ejercicio interactivo solo se puede ejecutar en RStudio Cloud. Si quieres correrlo localmente, debe haber descargado el proyecto, como se explica en el script 02A. "],["visualizacion.html", "03A - Visualización de datos (intro) Inicio: cargar paquetes, base de datos Gráficos univariados Gráficos bivariados Un poco de personalización: etiquetas", " 03A - Visualización de datos (intro) Diapositivas de visualización de datos Si quieres correr estos scripts localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (3A, 3B, 3C): tidyverse. Ilustración de Allison Horst. Inicio: cargar paquetes, base de datos library(tidyverse) Carga de base en formato rds Hoy tenemos una base de datos con información de los municipios, construida a partir de dos fuentes: la encuesta Casen 2017 y los resultados de las elecciones municipales del año 2016. df_municipios &lt;- read_rds(&quot;datos/datos_municipios.rds&quot;) ¿Te queda claro la información que registra cada variable? Si es que no, haz tus apuntes aquí: Gráficos univariados Gráfico univariado para variable categórica (barras) Veamos la distribución de las coaliciones de los alcaldes en las comunas: ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion)) + geom_bar() Si queremos invertir los ejes, podemos usar el mapeo estético y = en vez de x =: ggplot(data = df_municipios, mapping = aes(y = alcalde_coalicion)) + geom_bar() Gráfico univariado para variable continua (histograma) Veamos la distribución del % de población rural en las comunas: ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value ## with `binwidth`. Podemos controlar cómo se arma el histograma en los argumentos de geom_histogram(): bindwidth = 5 hace que nuestros bins tengan un ancho de 5. boundary = 0 asegura que los bins partan en 0, en vez de intentar centrarse en los números enteros (el defecto). closed = \"left\" ayuda a ggplot2 a decidir qué hacer con los valores que caen exactamente en los límites del bin. El valor left determina que los bins están cerrados a la izquierda, es decir, un valor intermedio caerá en la barra de la derecha. El valor right, el defecto, dirá que los bins están cerrados a la derecha, es decir, un valor intermedio caerá en la barra de la izquierda. ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram(binwidth = 5, boundary = 0, closed = &quot;left&quot;) (Ejercicio A) Genera un gráfico univariado para alguna de la variables de la base de datos. ¿Hay algún patrón interesante? Tu código (recuerda, los chunks se insertan con Ctrl/Cmd+Shift+i): Gráficos bivariados Gráfico bivariado para dos variables continuas (dispersión) Observemos la relación entre la variable de población mapuche en la comuna y su índice de pobreza multidimensional: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4)) + geom_point(size = 2) Podemos añadir color y forma a los puntos según las coaliciones de los alcaldes: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4, color = alcalde_coalicion, shape = alcalde_coalicion)) + geom_point(size = 2) Gráfico bivariado para x discreta + y continua: boxplot/violin Veamos la relación entre la coalición del edil y la pobreza de la comuna: ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion, y = porc_pobres_md4)) + geom_boxplot() ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion, y = porc_pobres_md4)) + geom_violin() Gráfico bivariado para x discreta + y continua: columnas (ránking) ggplot(data = df_municipios %&gt;% group_by(alcalde_coalicion) %&gt;% summarize(porc_alcaldes_reelectos = sum(alcalde_reelecto) / n()), mapping = aes(x = alcalde_coalicion, y = porc_alcaldes_reelectos)) + geom_col() A veces queremos hacer estos gráficos de forma horizontal (gráfico de ránking). Podemos hacer un cambio similar al anterior, con los mapeos estéticos invertidos. Luego aprenderemos a ordenar las barras, para hacer ránkings. ggplot(data = df_municipios %&gt;% group_by(alcalde_coalicion) %&gt;% summarize(porc_alcaldes_reelectos = sum(alcalde_reelecto) / n()), mapping = aes(x = porc_alcaldes_reelectos, y = alcalde_coalicion)) + geom_col() Un poco de personalización: etiquetas Volvamos a uno de los gráficos que hicimos antes: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4, color = alcalde_coalicion, shape = alcalde_coalicion)) + geom_point(size = 2) Con el comando labs() dentro de la cadena de ggplot2 podemos poner etiquetas que harán al gráfico más legible: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4, color = alcalde_coalicion, shape = alcalde_coalicion)) + geom_point(size = 2) + labs(title = &quot;Relación entre porcentaje de población mapuche y porcentaje de pobreza&quot;, subtitle = &quot;por comunas, año 2017&quot;, caption = &quot;Fuente: Casen (2017).&quot;, # ahora para los mapeos estéticos: x = &quot;% de población mapuche&quot;, y = &quot;% de población pobreza (multidimensional)&quot;, color = &quot;Coalición del(la) edil&quot;, shape = &quot;Coalición del(la) edil&quot;) (Ejercicios B-D) ¡En todos los ejercicios genera buenas etiquetas para tus gráficos, utilizando labs()! Genera un plot de violín para la relación entre una variable x discreta y una variable y continua en la base. Tu código: Genera un gráfico de dispersión entre dos variables continuas de la base. Cambia el color y/o forma de los puntos de acuerdo a una de las variables categóricas de la base (si es que vas a utilizar una variable dummy para esto, ingrésala como as.factor(variable) en el mapeo estético). Ayudándote del torpedo para hoy, genera dos gráficos que incluya geoms que no hayamos visto hasta ahora. d1. Tu código: d2. Tu código: "],["visualizacion-ext.html", "03B - Visualización de datos (extensiones) Cargar paquetes y datos Gráfico de ránking Facetas Gráficos de líneas Más personalización", " 03B - Visualización de datos (extensiones) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica al comienzo del script 03A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de Environment (superior derecho). Cargar paquetes y datos library(tidyverse) df_municipios &lt;- read_rds(&quot;datos/datos_municipios.rds&quot;) Gráfico de ránking Supongamos que queremos rankear a las comunas según su edad promedio. Podríamos hacer un gráfico de columnas: ggplot(data = df_municipios, mapping = aes(x = edad_prom, y = comuna)) + geom_col() (Al menos) dos cosas están mal con el gráfico anterior. Primero, son demasiadas observaciones. Segundo, las barras no están ordenadas. Podemos suplir ambas cosas y crear un gráfico de ránking que se entienda: ggplot(data = df_municipios %&gt;% arrange(-edad_prom) %&gt;% # ordenamos slice(1:10), # seleccionamos las diez primeras mapping = aes(x = edad_prom, y = fct_reorder(comuna, edad_prom))) + # ordenamos geom_col() Ejercicio A Genera un gráfico de ránking para las diez comunas con mayor población de la muestra. Facetas ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value ## with `binwidth`. ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() + facet_wrap(~alcalde_coalicion) ## `stat_bin()` using `bins = 30`. Pick better value ## with `binwidth`. ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() + facet_wrap(~alcalde_coalicion, nrow = 3) ## `stat_bin()` using `bins = 30`. Pick better value ## with `binwidth`. Noten que los gráficos anteriores, por defecto, las facetas comparten escalas para las variables x e y. Podemos cambiar este default con el argumento scales = \"free\", que también puede tomar los valores free_x o free_y. Qué queremos usar aquí dependerá de la naturaleza de nuestros datos, caso a caso ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() + facet_wrap(~alcalde_coalicion, scales = &quot;free&quot;) ## `stat_bin()` using `bins = 30`. Pick better value ## with `binwidth`. Ejercicio B Genera un gráfico de dispersión (con geom_point()) para dos variables de la base. Luego divídelo por facetas según la coalición del(la) edil. Gráficos de líneas Vamos a cargar datos desde Gapminder (2010), compilados por Edgar Ruiz, Riva Quiroga y Mauricio Pacha Vargas: gapminder_muestra &lt;- read_csv(&quot;datos/gapminder_muestra_es.csv&quot;) ## Parsed with column specification: ## cols( ## pais = col_character(), ## anio = col_double(), ## esperanza_de_vida = col_double() ## ) Podríamos querer graficar las tendencias en el tiempo para los tres países. Con las herramientas que hemos visto ahora ahora, podríamos hacer algo como lo siguiente: ggplot(data = gapminder_muestra, mapping = aes(x = anio, y = esperanza_de_vida, color = pais)) + geom_point() Esto es difícil de leer, nos vendría bien tener líneas para seguir los patrones en el tiempo. Podemos hacer esto añadiendo geom_line() y el mapeo estético group = (a veces podemos omitir esto, ggplot2 tratará de inferirlo, pero yo recomiendo utilizarlo explícitamente siempre). ggplot(data = gapminder_muestra, mapping = aes(x = anio, y = esperanza_de_vida, color = pais, group = pais)) + geom_point() + geom_line() Más personalización Vamos a ver cómo añadir texto dentro de los gráficos, editar las escalas (ejes y colores), etcétera, el próximo script. "],["visualizacion-personalizacion.html", "03C - Visualización de datos (personalización) Inicio: cargar paquetes, base de datos Gráfico de ejemplo Gráficos como objetos / guardar gráficos en el disco Personalización de gráficos", " 03C - Visualización de datos (personalización) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica al comienzo del script 3A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de Environment (superior derecho). Inicio: cargar paquetes, base de datos library(tidyverse) Cargar de datos: municipios Carguemos nuestra base de datos en formato .rds. Tiene información comunal construida a partir de dos fuentes: la encuesta Casen 2017 y los resultados de las elecciones municipales del año 2016. df_municipios &lt;- read_rds(&quot;datos/datos_municipios.rds&quot;) Gráfico de ejemplo ggplot(data = df_municipios, mapping = aes(x = as.factor(region), y = porc_pobres_md4)) + geom_boxplot() + labs(x = &quot;Región&quot;, y = &quot;% Pobreza multidimensional&quot;, title = &quot;% de pobreza en las comunas de Chile, separadas por región&quot;, caption = &quot;Fuente: Casen (2017)&quot;) Gráficos como objetos / guardar gráficos en el disco Podemos crear los gráficos como objetos en R. Hagamos esto para nuestro gráfico anterior: p_pobreza_sep_region &lt;- ggplot(data = df_municipios, mapping = aes(x = as.factor(region), y = porc_pobres_md4)) + geom_boxplot() + labs(x = &quot;Región&quot;, y = &quot;% Pobreza multidimensional&quot;, title = &quot;% de pobreza en las comunas de Chile, separadas por región&quot;, caption = &quot;Fuente: Casen (2017)&quot;) Para generarlos, los llamamos en la consola: p_pobreza_sep_region Podemos continuar con cadenas de ggplot2 a partir de objetos: p_pobreza_sep_region + geom_violin(alpha = 0.5) También podemos guardar nuestros gráficos en el disco fácilmente, si es que son objetos: ggsave(filename = &quot;p_pobreza_sep_region.png&quot;, plot = p_pobreza_sep_region) ## Saving 7 x 5 in image ¿Cómo conseguir que el gráfico tenga las proporciones que queremos? La mejor forma es modificando un poco algunos argumento de ggsave: scale edita la proporción de tamaños entre el plano y los elementos del gráfico. Valores menores a 1 harán los elementos más grandes. width edita el ancho, en pulgadas. height edita el alto, en pulgadas. Con units = \"cm\" podríamos dar ancho y alto en centímetros. [Aquí hay una guía completa sobre guardar gráficos en disco, escrita por Jenny Bryan (2018)] Casi siempre me funciona bien ocupar scale = 0.8, height = 6 y width = entre 8 y 10 (dependiendo si es un gráfico ancho o no). Hay mucho de ensayo y error aquí! ggsave(filename = &quot;p_pobreza_sep_region.png&quot;, plot = p_pobreza_sep_region, scale = 0.8, height = 6, width = 10) Personalización de gráficos Etiquetas (labs) Esto es algo que ya hemos visto, y se consigue con el comando labs(): ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion)) + geom_bar() + labs(x = &quot;Coalición del alcalde&quot;, y = &quot;Frecuencia&quot;, title = &quot;Alcaldías por coalición, luego de las elecciones 2016&quot;, caption = &quot;Fuente: Emol (2016)&quot;) Algunos argumentos de labs() funcionan en cualquier gráfico (title, subtitle, caption, etc.), mientras otros dependen de los mapeos estéticos particulares de cada gráfico (x, y, color, shape, etc.). Personalizar escalas numéricas Volvamos a nuestro histograma de antes: ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram(binwidth = 5, boundary = 0, closed = &quot;left&quot;) + labs(x = &quot;% de población rural&quot;, y = &quot;Frecuencia&quot;, title = &quot;Comunas chilenas según su porcentaje de población rural&quot;, caption = &quot;Fuente: Casen (2017)&quot;) Podemos editar arbitrariamente qué se muestra en los ejes continuos con los comandos scale_*_continuous() y el argumento breaks =: ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram(binwidth = 5, boundary = 0, closed = &quot;left&quot;) + labs(x = &quot;% de población rural&quot;, y = &quot;Frecuencia&quot;, title = &quot;Comunas chilenas según su porcentaje de población rural&quot;, caption = &quot;Fuente: Casen (2017)&quot;) + scale_x_continuous(breaks = seq(from = 0, to = 100, by = 10)) + scale_y_continuous(breaks = seq(from = 0, to = 60, by = 10)) (Nueva base de datos) Ahora trabajaremos con una base de datos con información de carreras universitarias en Estados Unidos. Su fuente es FiveThirtyEight (2018), aunque estos datos específicos fueron editados para Tidy Tuesday. carreras_eeuu &lt;- read_csv(&quot;datos/carreras_eeuu.csv&quot;) ## Parsed with column specification: ## cols( ## carrera_codigo = col_double(), ## carrera = col_character(), ## carrera_tipo1 = col_character(), ## carrera_tipo2 = col_character(), ## estudiantes_total = col_double(), ## estudiantes_muj = col_double(), ## estudiantes_hom = col_double(), ## salario_mediana = col_double(), ## salario_q1 = col_double(), ## salario_q3 = col_double(), ## en_part_time = col_double(), ## en_trabajos_calificados = col_double(), ## en_trabajos_no_calificados = col_double(), ## en_trabajos_sueldo_min = col_double(), ## desempleados = col_double() ## ) glimpse(carreras_eeuu) ## Rows: 171 ## Columns: 15 ## $ carrera_codigo &lt;dbl&gt; 1100, 1101, 1102, ~ ## $ carrera &lt;chr&gt; &quot;Agricultura (Gene~ ## $ carrera_tipo1 &lt;chr&gt; &quot;STEM&quot;, &quot;STEM&quot;, &quot;S~ ## $ carrera_tipo2 &lt;chr&gt; &quot;Agricultura y Rec~ ## $ estudiantes_total &lt;dbl&gt; 10399, 14240, 2439~ ## $ estudiantes_muj &lt;dbl&gt; 6053, 9658, 1749, ~ ## $ estudiantes_hom &lt;dbl&gt; 4346, 4582, 690, 1~ ## $ salario_mediana &lt;dbl&gt; 40000, 40000, 4000~ ## $ salario_q1 &lt;dbl&gt; 30000, 25000, 2700~ ## $ salario_q3 &lt;dbl&gt; 50000, 50000, 5400~ ## $ en_part_time &lt;dbl&gt; 2031, 2196, 620, 5~ ## $ en_trabajos_calificados &lt;dbl&gt; 2418, 1925, 535, 5~ ## $ en_trabajos_no_calificados &lt;dbl&gt; 4717, 6221, 893, 9~ ## $ en_trabajos_sueldo_min &lt;dbl&gt; 839, 1362, 94, 212~ ## $ desempleados &lt;dbl&gt; 178, 649, 182, 917~ (Ejercicio A) Antes de comenzar a trabajar con los datos, crea una nueva base de datos llamada carreras_eeuu2 que tenga tres nuevas variables: porc_mujeres, porc_desempleo, porc_en_trabajos_calificados (todas calculadas con respecto al total de cada carrera). Tu código: En el resto de la clase utilizaremos esta base modificada. Elegir buenas escalas de colores Escalas de colores categóricas Comencemos dibujando solo el plano de coordenadas, sin geoms. ¿Qué esperan ver en el siguiente gráfico, una vez que añadamos geom_point()? ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = carrera_tipo1)) Veamos el gráfico: ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = carrera_tipo1)) + geom_point() La paleta de colores categóricos por defecto de ggplot2, lamentablemente, es difícil de ver para los/as daltónicos/as. Podemos cambiarla por una de ColorBrewer con el comando scale_color_brewer(): ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = carrera_tipo1)) + geom_point() + scale_color_brewer(palette = &quot;PuOr&quot;) Escalas de colores numéricas Grafiquemos la misma relación de antes, pero esta vez añadamos color a los puntos con una variable continua (porc_mujeres): ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres)) + geom_point() De nuevo, la paleta de colores por defecto es subóptima. La mejor paleta para visualizar escalas continuas en color es viridis. Podemos utilizarla con el comando scale_color_viridis_c(): ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres)) + geom_point() + scale_color_viridis_c() # de la escala (Ejercicio B) Genera un gráfico de dispersión para dos variables numéricas en la base de datos. Añade color a las observaciones de acuerdo al tipo de carrera (amplio). Utiliza una escala de ColorBrewer distinta a la de antes. Recuerda utilizar buenos labs (etiquetas). Tu código: Texto dentro del gráfico Para el último gráfico que hicimos, nos puede interesar ver la posición de carreras específicas. Podemos generar esto añadiendo texto dentro del gráfico: ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres, label = carrera)) + geom_point() + geom_label() + # esto genera los textos, ojo que necesita el mapeo de &quot;label&quot; antes! scale_color_viridis_c() Esto último es inútil, pues no se entiende nada. Podemos destacar solo una carrera si construimos geom_label() usando datos parciales. Coloquemos solo el texto para ciencia política: ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres, label = carrera)) + geom_point() + geom_label(data = carreras_eeuu2 %&gt;% filter(carrera == &quot;Ciencia Política&quot;), alpha = 0.7) + scale_color_viridis_c() Texto dentro de gráficos de columna Calculemos la mediana de porcentaje de desempleo por tipo (amplio) de carrera: ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(median_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = median_porc_desempleo)) + geom_col() Para añadir cajas de texto con los valores numéricos al gráfico, de nuevo podemos utilizar geom_label(), luego de haber indicado el mapeo estético para label: ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(median_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = median_porc_desempleo, label = median_porc_desempleo)) + geom_col() + geom_label() Un tip: podemos redondear los números utilizando round() en el mapeo de label: ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(median_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = median_porc_desempleo, label = round(median_porc_desempleo, 2))) + geom_col() + geom_label() Por cierto, aparte de geom_label() está geom_text(), que no dibuja una caja alrededor del texto. ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(mediana_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = mediana_porc_desempleo, label = round(mediana_porc_desempleo, 2))) + geom_col() + geom_text(vjust = -0.4) # solo esto cambió. vjust cambia ligeramente la posición del texto (Ejercicio D) Genera un gráfico de tipo ránking con la diez carreras con mayor salario mediano. Registra con texto los valores de salarios medianos. ¡Utiliza buenos labs (etiquetas)! "],["busqueda-ayuda.html", "04 - Guía búsqueda de ayuda Leer archivos de ayuda de R Encontrar funciones en línea Solucionar problemas Pedir ayuda con ejemplos reproducibles (reprex)", " 04 - Guía búsqueda de ayuda En esta guía vamos a revisar algunos tips y recursos para buscar ayuda efectivamente, en el contexto de proyectos de análisis de datos. Leer archivos de ayuda de R Todas las funciones en R tienen un archivo de ayuda asociado. Podemos acceder a estos simplemente antecediendo el nombre de la función con un signo de interrogación: ?mean ?`%&gt;%` # con estos tildes invertidos podemos ingresar funciones que tengan caracteres especiales ?`%in%` Podemos leer un archivo de ayuda de R de la siguiente forma: Figure 1: Traducido de Healy (2018). Encontrar funciones en línea CRAN packages CRAN es el sitio de los repositorios oficiales de R. La página web es un poco confusa, pero usualmente encontramos los paquetes que queremos buscando en Google cran &lt;paquete&gt;. Por ejemplo, este es el sitio para el paquete dplyr. Contiene información útil sobre el paquete. Tres campos muy importantes a mirar son (a) URL, que nos lleva al sitio oficial del paquete, usualmente en la página del autor/a, (B) Vignettes, que son pequeñas guías oficiales de cómo usarlo y (C) Reference manual, un manual con todos los archivos de ayuda de sus funciones. rdrr.io En este sitio podemos buscar funciones y mirar sus archivos de ayuda en línea. Su buscador integrado no es particularmente bueno, así que recomiendo usar Google. Así llegaremos a esta página, por ejemplo: mutate rdrr. CRAN Task Views CRAN Task Views son guías muy completas sobre qué paquetes nos pueden ayudar a lidiar con tópicos específicos. Por ejemplo, veamos el CTV de Estadística para las Ciencias Sociales. Solucionar problemas Problemas con paréntesis y comas Vamos a usar una base de ejemplo de ggplot2, llamada midwest. Contiene información demográfica sobre distintos condados en Estados Unidos, parte de la zona geográfica llamada Midwest. midwest ## # A tibble: 437 x 28 ## PID county state area poptotal popdensity ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 561 ADAMS IL 0.052 66090 1271. ## 2 562 ALEXANDER IL 0.014 10626 759 ## 3 563 BOND IL 0.022 14991 681. ## 4 564 BOONE IL 0.017 30806 1812. ## 5 565 BROWN IL 0.018 5836 324. ## 6 566 BUREAU IL 0.05 35688 714. ## 7 567 CALHOUN IL 0.017 5322 313. ## 8 568 CARROLL IL 0.027 16805 622. ## 9 569 CASS IL 0.024 13437 560. ## 10 570 CHAMPAIGN IL 0.058 173025 2983. ## # ... with 427 more rows, and 22 more variables: ## # popwhite &lt;int&gt;, popblack &lt;int&gt;, ## # popamerindian &lt;int&gt;, popasian &lt;int&gt;, ## # popother &lt;int&gt;, percwhite &lt;dbl&gt;, percblack &lt;dbl&gt;, ## # percamerindan &lt;dbl&gt;, percasian &lt;dbl&gt;, ## # percother &lt;dbl&gt;, popadults &lt;int&gt;, perchsd &lt;dbl&gt;, ## # percollege &lt;dbl&gt;, percprof &lt;dbl&gt;, ## # poppovertyknown &lt;int&gt;, percpovertyknown &lt;dbl&gt;, ## # percbelowpoverty &lt;dbl&gt;, ## # percchildbelowpovert &lt;dbl&gt;, ## # percadultpoverty &lt;dbl&gt;, percelderlypoverty &lt;dbl&gt;, ## # inmetro &lt;int&gt;, category &lt;chr&gt; Generemos un gráfico con ella: ggplot(data = midwest, mapping = aes(x = as.factor(inmetro), y = percbelowpoverty)) + geom_boxplot() + labs(title = &quot;Relación entre carácter metropolitano y pobreza en los condados del Midwest&quot;, caption = &quot;Fuente: Wickham (2018)&quot;, x = &quot;Carácter metropolitano&quot;, y = &quot;Porcentaje de pobreza&quot;) La gran mayoría de los errores que se cometen en R tienen que ver con sintaxis. Como hemos visto, R (como cualquier lenguaje de programación) espera instrucciones muy precisas de nuestra parte. Aquí algunos tips para detectar problemas de este tipo: Revisar dónde abren/cierran paréntesis sospechosos. Si ponemos el teclado al lado de uno de ellos, RStudio resaltará el paréntesis par a este: Con respecto a las comas, debemos recordar que se utilizan para separar argumentos de funciones, por lo que siempre deben estar adentro de ellas. Fíjate en los argumentos de la función labs() en el código de arriba. Otro error de sintaxis es dejar cadenas de código (%&gt;% o +) abiertas. Esto es, dejar un pipe o + extra al final. R seguirá esperando la continuación de la cadena! Un truco para ver dónde está fallando nuestro código es ponerle sangría línea a línea. Si tenemos un código desordenado, podemos ir ordenándolo línea a línea con Ctrl + I. Probablemente esto nos dé una mejor perspectiva para encontrar errores de comas, pipes, etc: Leer los mensajes de error de R Veamos el siguiente error, cuando intentamos multiplicar una variable categórica: midwest %&gt;% filter(county == &quot;IL&quot;) %&gt;% mutate(county5 = county * 5) ## Error: Problem with `mutate()` input `county5`. ## x non-numeric argument to binary operator ## i Input `county5` is `county * 5`. El mensaje nos menciona que el error sucedió en mutate(), lo que ya es útil. Luego, el concepto de non-numeric nos da una idea de lo que puede estar pasando. Buscar en internet A veces entendemos el mensaje de error y sabemos cómo solucionarlo. Pero a menudo una buena idea es buscar el error en Google (la mayoría de los errores ya han sido preguntados en línea), acompañado de la función y/o paquete. Para hacer estas búsquedas eficientemente, deberíamos eliminar cualquier información del error que sea específica de nuestra base de datos (generalizándolo). Por ejemplo, una buena búsqueda para el error anterior podría ser la siguiente. r dplyr mutate non-numeric argument to binary operator En Google podemos poner una palabra o frase entre comillas para que los resultados deban necesariamente contenerla tal como está escrita. Podríamos buscar algo como esto: r dplyr mutate non-numeric argument to binary operator Por lejos, los mejores resultados vienen de StackOverflow, un sitio web de preguntas y respuestas de programación. En Google a menudo querrán clickear en Más resultados de stackoverflow.com, si es que no encuentran la solución en los primeros resultados. Podemos hacer nuestra búsqueda anterior directamente en StackOverflow a través de Google, de la siguiente forma: site:stackoverflow.com r dplyr mutate non-numeric argument to binary operator Pedir ayuda con ejemplos reproducibles (reprex) Cuando tenemos un problema y queremos compartirlo con alguien (colegas, StackOverflow, etc.), lo ideal es que generemos un ejemplo mínimo que reproduzca nuestro problema (reprex). La idea es que la otra persona no tenga que lidiar con todo nuestro código, sino que solo con la parte que nos está dando problemas. Adicionalmente, no queremos que esa otra persona tenga que entender nuestra base de datos en particular, por lo que los reprex usualmente están hechos con bases de datos pequeñas creadas o con bases de datos que vienen por defecto con R o el tidyverse (mtcars, midwest, mpg, diamonds, etc.). Por último, queremos que esa otra persona pueda correr rápidamente nuestro código, sin tener que preocuparse de nada más aparte de nuestro problema. Nuestro problema de antes: midwest %&gt;% filter(county == &quot;IL&quot;) %&gt;% mutate(county5 = county * 5) ## Error: Problem with `mutate()` input `county5`. ## x non-numeric argument to binary operator ## i Input `county5` is `county * 5`. Utilizar la base midwest está bien, pero vamos a generar nuestro reprex con otra de ejemplo en el paquete ggplot2, llamada mpg. Esta base se ve de la siguiente forma. No importa mucho su contenido, pero sí que tenemos una variable categórica para usar. En este caso, model nos servirá. ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l~ f ## 2 audi a4 1.8 1999 4 manual~ f ## 3 audi a4 2 2008 4 manual~ f ## 4 audi a4 2 2008 4 auto(a~ f ## 5 audi a4 2.8 1999 6 auto(l~ f ## 6 audi a4 2.8 1999 6 manual~ f ## 7 audi a4 3.1 2008 6 auto(a~ f ## 8 audi a4 qua~ 1.8 1999 4 manual~ 4 ## 9 audi a4 qua~ 1.8 1999 4 auto(l~ 4 ## 10 audi a4 qua~ 2 2008 4 manual~ 4 ## # ... with 224 more rows, and 4 more variables: ## # cty &lt;int&gt;, hwy &lt;int&gt;, fl &lt;chr&gt;, class &lt;chr&gt; Debemos pensar hacer la misma operación con la nueva base, y que nos dé el mismo error. Además, el reprex debe incluir la carga de todos los paquetes necesarios: library(tidyverse) # carga filter(), mutate() y mpg mpg %&gt;% filter(model == &quot;a4&quot;) %&gt;% mutate(model = model * 5) # Error: Problem with `mutate()` input `model`. # x non-numeric argument to binary operator # i Input `model` is `model * 5`. Una ventaja de los reprex es que a menudo en el proceso de hacerlos, encontramos la raíz de los problemas. Por ejemplo, es posible que en la reducción anterior nos demos cuenta que filter() no tiene nada que ver con nuestro problema, por lo que el reprex podría quedar así: library(tidyverse) # carga filter(), mutate() y mpg mpg %&gt;% mutate(model = model * 5) # Error: Problem with `mutate()` input `model`. # x non-numeric argument to binary operator # i Input `model` is `model * 5`. "],["manejo-av.html", "05A - Manejo avanzado de datos (intro) Inicio: cargar paquetes, base de datos Pivotear bases de datos (wide &lt;-&gt; long) Recodificar variables Valores perdidos/missing/NA Unir bases de datos", " 05A - Manejo avanzado de datos (intro) Si quieres correr estos scripts localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (05A, 05B): tidyverse. Inicio: cargar paquetes, base de datos library(tidyverse) df_tasa_robos &lt;- read_csv(&quot;datos/tasa_robos_wide.csv&quot;) ## Parsed with column specification: ## cols( ## comuna = col_character(), ## comuna_id = col_double(), ## `2012` = col_double(), ## `2013` = col_double(), ## `2014` = col_double(), ## `2015` = col_double(), ## `2016` = col_double() ## ) Tenemos una base de datos con los casos policiales de robos cada 1.000 habitantes. Contiene información para 340 comunas de Chile, 2012-2016. Su fuente es la Subsecretaría de Prevención del Delito (2017). Pivotear bases de datos (wide &lt;-&gt; long) ¿Qué pasa si queremos graficar estos datos, por ejemplo viendo la evolución temporal de la variable en una comuna? El formato de los datos no es el ideal. Aquí los valores de una variable (año) se expandieron hacia las columnas, generando una base en formato wide. Podemos alargar esta base usando la función pivot_longer(), de la siguiente manera: df_tasa_robos_long &lt;- df_tasa_robos %&gt;% pivot_longer(cols = -c(comuna, comuna_id), # descartamos vars. que no queremos transformar names_to = &quot;anio&quot;, values_to = &quot;tasa_robos&quot;) df_tasa_robos_long ## # A tibble: 1,700 x 4 ## comuna comuna_id anio tasa_robos ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Algarrobo 5602 2012 4031. ## 2 Algarrobo 5602 2013 3612. ## 3 Algarrobo 5602 2014 3734. ## 4 Algarrobo 5602 2015 4231. ## 5 Algarrobo 5602 2016 3665. ## 6 Alhué 13502 2012 796. ## 7 Alhué 13502 2013 950. ## 8 Alhué 13502 2014 1167. ## 9 Alhué 13502 2015 606. ## 10 Alhué 13502 2016 956. ## # ... with 1,690 more rows Esta estructura de datos es mucho más amigable para ggplot2: ggplot(data = df_tasa_robos_long %&gt;% filter(comuna %in% c(&quot;San-Joaquín&quot;, &quot;Macul&quot;)), mapping = aes(x = as.factor(anio), y = tasa_robos, color = comuna, group = comuna)) + geom_line() # podríamos seguir añadiendo escalas, labs, etc... Noten que pivot_longer() tiene una función recíproca, pivot_wider(): df_tasa_robos_long %&gt;% pivot_wider(names_from = &quot;anio&quot;, values_from = &quot;tasa_robos&quot;) ## # A tibble: 340 x 7 ## comuna comuna_id `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algarr~ 5602 4031. 3612. 3734. 4231. 3665. ## 2 Alhué 13502 796. 950. 1167. 606. 956. ## 3 Alto-B~ 8314 225. 305. 245. 139. 103. ## 4 Alto-d~ 3302 208. 209. 397. 293. 315. ## 5 Alto-H~ 1107 2589. 2218. 1930. 1962. 1847. ## 6 Ancud 10202 579. 763. 697. 755. 732. ## 7 Andaco~ 4103 759. 640. 892. 911. 1075. ## 8 Angol 9201 1400. 1515. 1822. 1939. 1468. ## 9 Antárt~ 12202 0 0 0 0 0 ## 10 Antofa~ 2101 2178. 1892. 1938. 1671. 1391. ## # ... with 330 more rows Recodificar variables Supongamos que, usando nuestra nueva base long, queremos crear una variable binaria/dummy que indique si la observación es para el gobierno de Piñera I o Bachelet II. Podemos usar if_else() dentro de mutate(): df_tasa_robos_long %&gt;% mutate(d_gob_bachelet = if_else(condition = anio &gt;= 2014, true = 1, false = 0)) ## # A tibble: 1,700 x 5 ## comuna comuna_id anio tasa_robos d_gob_bachelet ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algarrobo 5602 2012 4031. 0 ## 2 Algarrobo 5602 2013 3612. 0 ## 3 Algarrobo 5602 2014 3734. 1 ## 4 Algarrobo 5602 2015 4231. 1 ## 5 Algarrobo 5602 2016 3665. 1 ## 6 Alhué 13502 2012 796. 0 ## 7 Alhué 13502 2013 950. 0 ## 8 Alhué 13502 2014 1167. 1 ## 9 Alhué 13502 2015 606. 1 ## 10 Alhué 13502 2016 956. 1 ## # ... with 1,690 more rows if_else() nos sirve si es que queremos crear variables binarias (numéricas o no). Pero a menudo queremos asignar más categorías. En esos casos podemos usar case_when(): df_tasa_robos_long %&gt;% mutate(gobierno = case_when(anio &lt; 2014 ~ &quot;Piñera I&quot;, # condición ~ valor anio == 2014 ~ &quot;Cambio de mando&quot;, anio &gt; 2014 ~ &quot;Bachelet II&quot;)) ## # A tibble: 1,700 x 5 ## comuna comuna_id anio tasa_robos gobierno ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Algarrobo 5602 2012 4031. Piñera I ## 2 Algarrobo 5602 2013 3612. Piñera I ## 3 Algarrobo 5602 2014 3734. Cambio de mando ## 4 Algarrobo 5602 2015 4231. Bachelet II ## 5 Algarrobo 5602 2016 3665. Bachelet II ## 6 Alhué 13502 2012 796. Piñera I ## 7 Alhué 13502 2013 950. Piñera I ## 8 Alhué 13502 2014 1167. Cambio de mando ## 9 Alhué 13502 2015 606. Bachelet II ## 10 Alhué 13502 2016 956. Bachelet II ## # ... with 1,690 more rows Una opción válida al usar case_when() es asignar un valor para cualquier otro caso: df_tasa_robos_long %&gt;% mutate(gobierno = case_when(anio &lt; 2014 ~ &quot;Piñera I&quot;, anio == 2014 ~ &quot;Cambio de mando&quot;, TRUE ~ &quot;Bachelet II&quot;)) # en cualquier otro caso ## # A tibble: 1,700 x 5 ## comuna comuna_id anio tasa_robos gobierno ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Algarrobo 5602 2012 4031. Piñera I ## 2 Algarrobo 5602 2013 3612. Piñera I ## 3 Algarrobo 5602 2014 3734. Cambio de mando ## 4 Algarrobo 5602 2015 4231. Bachelet II ## 5 Algarrobo 5602 2016 3665. Bachelet II ## 6 Alhué 13502 2012 796. Piñera I ## 7 Alhué 13502 2013 950. Piñera I ## 8 Alhué 13502 2014 1167. Cambio de mando ## 9 Alhué 13502 2015 606. Bachelet II ## 10 Alhué 13502 2016 956. Bachelet II ## # ... with 1,690 more rows Mini-ejercicio Crea la variable d_gob_bachelet de antes, pero esta vez usando case_when(). Tu código: Valores perdidos/missing/NA Para el resto de la clase trabajaremos también con datos de robos, esta vez para los países del Cono Sur (2006-2016). La fuente es la Oficina de las Naciones Unidas contra la Droga y el Delito (UNODC). df_robos_cono_sur &lt;- read_csv(&quot;datos/robos_cono_sur.csv&quot;) ## Parsed with column specification: ## cols( ## pais = col_character(), ## pais_codigo = col_character(), ## anio = col_double(), ## robos_c100k = col_double() ## ) df_robos_cono_sur ## # A tibble: 33 x 4 ## pais pais_codigo anio robos_c100k ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 738. ## 2 Argentina ARG 2007 662. ## 3 Argentina ARG 2008 704. ## 4 Argentina ARG 2009 NA ## 5 Argentina ARG 2010 NA ## 6 Argentina ARG 2011 NA ## 7 Argentina ARG 2012 NA ## 8 Argentina ARG 2013 NA ## 9 Argentina ARG 2014 668. ## 10 Argentina ARG 2015 626. ## # ... with 23 more rows Veamos los datos. ¿Qué pasó con las datos de Argentina, 2009-2013? R registra los valores perdidos como NA. Esto no es un caracter con las letras N y A, sino que un valor especial dentro del vector, sin importar su tipo. Realizar operaciones básicas en vectores con NA Intentemos calcular la media por país para la variable robos_c100k: df_robos_cono_sur %&gt;% group_by(pais) %&gt;% summarize(media_robos_c100k = mean(robos_c100k)) ## # A tibble: 3 x 2 ## pais media_robos_c100k ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina NA ## 2 Chile 1070. ## 3 Uruguay 2984. La mayoría de las operaciones básicas en R (median(), sd(), sum(), etc.) fallarán cuando alguno de los valores en el cálculo sea un NA. Si es que de todas formas queremos utilizar la función, tomando en cuenta solo los valores existentes, prácticamente todas estas operaciones incluyen un argumento na.rm = (NA remove): df_robos_cono_sur %&gt;% group_by(pais) %&gt;% summarize(media_robos_c100k = mean(robos_c100k, na.rm = T)) ## # A tibble: 3 x 2 ## pais media_robos_c100k ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 669. ## 2 Chile 1070. ## 3 Uruguay 2984. Por defecto, los modelos de regresión hacen algo como esto, omiten las observaciones que tengan NA en alguna de las variables del modelo. Siempre que estemos en la duda sobre cómo se comporta alguna función ante NAs, deberíamos revisar su archivo de ayuda y buscar algún argumento que incluya na: ?lm Filtrar NAs de una base Lo siguiente no funcionará: df_robos_cono_sur %&gt;% filter(robos_c100k == NA) Lo que debemos utilizar en operaciones lógicas para testear la presencia de NAs es la función is.na(): df_robos_cono_sur %&gt;% filter(is.na(robos_c100k)) ## # A tibble: 5 x 4 ## pais pais_codigo anio robos_c100k ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina ARG 2009 NA ## 2 Argentina ARG 2010 NA ## 3 Argentina ARG 2011 NA ## 4 Argentina ARG 2012 NA ## 5 Argentina ARG 2013 NA Podemos realizar una negación en una operación lógica antecediéndola de un signo de exclamación. En este caso, obtendremos solo las observaciones que no tienen NA en robos_c100k: df_robos_cono_sur %&gt;% filter(!is.na(robos_c100k)) ## # A tibble: 28 x 4 ## pais pais_codigo anio robos_c100k ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 738. ## 2 Argentina ARG 2007 662. ## 3 Argentina ARG 2008 704. ## 4 Argentina ARG 2014 668. ## 5 Argentina ARG 2015 626. ## 6 Argentina ARG 2016 616. ## 7 Chile CHL 2006 942. ## 8 Chile CHL 2007 1018. ## 9 Chile CHL 2008 1054. ## 10 Chile CHL 2009 1136. ## # ... with 18 more rows Crear valores perdidos df_robos_cono_sur ## # A tibble: 33 x 4 ## pais pais_codigo anio robos_c100k ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 738. ## 2 Argentina ARG 2007 662. ## 3 Argentina ARG 2008 704. ## 4 Argentina ARG 2009 NA ## 5 Argentina ARG 2010 NA ## 6 Argentina ARG 2011 NA ## 7 Argentina ARG 2012 NA ## 8 Argentina ARG 2013 NA ## 9 Argentina ARG 2014 668. ## 10 Argentina ARG 2015 626. ## # ... with 23 more rows Supongamos que no confiamos en los datos más antiguos para Argentina (2006-2008) y también queremos asignarlos como valores perdidos. Una opción podría ser eliminar dichas observaciones con filter(), pero tal vez tenemos información útil en otras variables. Podríamos asignarle el valor de NA a dichas observaciones con if_else() o case_when(): df_robos_cono_sur %&gt;% mutate(robos_c100k = case_when( pais == &quot;Argentina&quot; &amp; anio &lt;= 2008 ~ NA, TRUE ~ robos_c100k )) Lo anterior falla, pese a que la sintaxis de case_when() es correcta! El problema es que cuando creamos valores perdidos debemos decirle explícitamente a R qué tipo de NAs utilizaremos, según el tipo de vector. Los tipos más comunes son NA_character_ (para vectores de caracteres, chr) o NA_real_ (para vectores de números reales, dbl). Veamos cómo ahora funcionará: df_robos_cono_sur %&gt;% mutate(robos_c100k = case_when( pais == &quot;Argentina&quot; &amp; anio &lt;= 2008 ~ NA_real_, TRUE ~ robos_c100k )) ## # A tibble: 33 x 4 ## pais pais_codigo anio robos_c100k ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 NA ## 2 Argentina ARG 2007 NA ## 3 Argentina ARG 2008 NA ## 4 Argentina ARG 2009 NA ## 5 Argentina ARG 2010 NA ## 6 Argentina ARG 2011 NA ## 7 Argentina ARG 2012 NA ## 8 Argentina ARG 2013 NA ## 9 Argentina ARG 2014 668. ## 10 Argentina ARG 2015 626. ## # ... with 23 more rows Unir bases de datos Aquí tenemos una base con muchos datos de los World Development Indicators del Banco Mundial. Están para los tres países del Cono Sur, pero desde 2007 a 2016 (falta 2006, en comparación a los datos anteriores). df_wdi &lt;- read_csv(&quot;datos/wdi_cono_sur.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_double(), ## pais_codigo = col_character(), ## external_debt_stocks_total_dod_current_us = col_logical(), ## total_debt_service_percent_of_exports_of_goods_services_and_primary_income = col_logical() ## ) ## See spec(...) for full column specifications. df_wdi ## # A tibble: 30 x 57 ## pais_codigo anio population_total population_growt~ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ARG 2007 39684295 0.999 ## 2 CHL 2007 16530195 1.07 ## 3 URY 2007 3331749 0.191 ## 4 ARG 2008 40080160 0.993 ## 5 CHL 2008 16708258 1.07 ## 6 URY 2008 3340221 0.254 ## 7 ARG 2009 40482788 1.00 ## 8 CHL 2009 16886186 1.06 ## 9 URY 2009 3349676 0.283 ## 10 ARG 2010 40788453 0.752 ## # ... with 20 more rows, and 53 more variables: ## # surface_area_sq_km &lt;dbl&gt;, ## # population_density_people_per_sq_km_of_land_area &lt;dbl&gt;, ## # poverty_headcount_ratio_at_national_poverty_lines_percent_of_population &lt;dbl&gt;, ## # poverty_headcount_ratio_at_1_90_a_day_2011_ppp_percent_of_population &lt;dbl&gt;, ## # gni_atlas_method_current_us &lt;dbl&gt;, ## # gni_per_capita_atlas_method_current_us &lt;dbl&gt;, ## # gni_ppp_current_international &lt;dbl&gt;, ## # gni_per_capita_ppp_current_international &lt;dbl&gt;, ## # income_share_held_by_lowest_20_percent &lt;dbl&gt;, ## # life_expectancy_at_birth_total_years &lt;dbl&gt;, ## # fertility_rate_total_births_per_woman &lt;dbl&gt;, ## # adolescent_fertility_rate_births_per_1_000_women_ages_15_19 &lt;dbl&gt;, ## # contraceptive_prevalence_any_methods_percent_of_women_ages_15_49 &lt;dbl&gt;, ## # births_attended_by_skilled_health_staff_percent_of_total &lt;dbl&gt;, ## # mortality_rate_under_5_per_1_000_live_births &lt;dbl&gt;, ## # prevalence_of_underweight_weight_for_age_percent_of_children_under_5 &lt;dbl&gt;, ## # immunization_measles_percent_of_children_ages_12_23_months &lt;dbl&gt;, ## # primary_completion_rate_total_percent_of_relevant_age_group &lt;dbl&gt;, ## # school_enrollment_primary_percent_gross &lt;dbl&gt;, ## # school_enrollment_secondary_percent_gross &lt;dbl&gt;, ## # school_enrollment_primary_and_secondary_gross_gender_parity_index_gpi &lt;dbl&gt;, ## # prevalence_of_hiv_total_percent_of_population_ages_15_49 &lt;dbl&gt;, ## # forest_area_sq_km &lt;dbl&gt;, ## # terrestrial_and_marine_protected_areas_percent_of_total_territorial_area &lt;dbl&gt;, ## # annual_freshwater_withdrawals_total_percent_of_internal_resources &lt;dbl&gt;, ## # urban_population_growth_annual_percent &lt;dbl&gt;, ## # energy_use_kg_of_oil_equivalent_per_capita &lt;dbl&gt;, ## # co2_emissions_metric_tons_per_capita &lt;dbl&gt;, ## # electric_power_consumption_k_wh_per_capita &lt;dbl&gt;, ## # gdp_current_us &lt;dbl&gt;, ## # gdp_growth_annual_percent &lt;dbl&gt;, ## # inflation_gdp_deflator_annual_percent &lt;dbl&gt;, ## # agriculture_forestry_and_fishing_value_added_percent_of_gdp &lt;dbl&gt;, ## # industry_including_construction_value_added_percent_of_gdp &lt;dbl&gt;, ## # exports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # imports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # gross_capital_formation_percent_of_gdp &lt;dbl&gt;, ## # revenue_excluding_grants_percent_of_gdp &lt;dbl&gt;, ## # time_required_to_start_a_business_days &lt;dbl&gt;, ## # domestic_credit_provided_by_financial_sector_percent_of_gdp &lt;dbl&gt;, ## # tax_revenue_percent_of_gdp &lt;dbl&gt;, ## # military_expenditure_percent_of_gdp &lt;dbl&gt;, ## # mobile_cellular_subscriptions_per_100_people &lt;dbl&gt;, ## # high_technology_exports_percent_of_manufactured_exports &lt;dbl&gt;, ## # statistical_capacity_score_overall_average &lt;dbl&gt;, ## # merchandise_trade_percent_of_gdp &lt;dbl&gt;, ## # net_barter_terms_of_trade_index_2000_100 &lt;dbl&gt;, ## # external_debt_stocks_total_dod_current_us &lt;lgl&gt;, ## # total_debt_service_percent_of_exports_of_goods_services_and_primary_income &lt;lgl&gt;, ## # net_migration &lt;dbl&gt;, ## # personal_remittances_received_current_us &lt;dbl&gt;, ## # foreign_direct_investment_net_inflows_bo_p_current_us &lt;dbl&gt;, ## # net_official_development_assistance_and_official_aid_received_current_us &lt;dbl&gt; ¿Cómo podemos añadir toda esta nueva información a nuestra base original? No podemos simplemente pegar las columnas unas al lado de otras con bind_cols() (los números de filas son distintos, lo mismo con el orden de las observaciones). Como ejemplos: bind_cols(tibble(x = 1), tibble(y = 2)) ## # A tibble: 1 x 2 ## x y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 bind_rows(tibble(x = 1), tibble(x = 2)) ## # A tibble: 2 x 1 ## x ## &lt;dbl&gt; ## 1 1 ## 2 2 Lo mejor es realizar una unión de bases (merge/join). Lejos la más común de estas operaciones es la unión izquierda, en la que queremos añadir información a una base (la izquierda) a partir de otra (la derecha). left_join() nos permitirá hacer esto, mirando las observaciones de ambas bases donde las columnas de identificación toman los mismos valores: df_robos_cono_sur_con_wdi &lt;- left_join( x = df_robos_cono_sur, y = df_wdi, by = c(&quot;pais_codigo&quot;, &quot;anio&quot;) # by dice cuáles son las variables de id. ) df_robos_cono_sur_con_wdi ## # A tibble: 33 x 59 ## pais pais_codigo anio robos_c100k population_total ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Arge~ ARG 2006 738. NA ## 2 Arge~ ARG 2007 662. 39684295 ## 3 Arge~ ARG 2008 704. 40080160 ## 4 Arge~ ARG 2009 NA 40482788 ## 5 Arge~ ARG 2010 NA 40788453 ## 6 Arge~ ARG 2011 NA 41261490 ## 7 Arge~ ARG 2012 NA 41733271 ## 8 Arge~ ARG 2013 NA 42202935 ## 9 Arge~ ARG 2014 668. 42669500 ## 10 Arge~ ARG 2015 626. 43131966 ## # ... with 23 more rows, and 54 more variables: ## # population_growth_annual_percent &lt;dbl&gt;, ## # surface_area_sq_km &lt;dbl&gt;, ## # population_density_people_per_sq_km_of_land_area &lt;dbl&gt;, ## # poverty_headcount_ratio_at_national_poverty_lines_percent_of_population &lt;dbl&gt;, ## # poverty_headcount_ratio_at_1_90_a_day_2011_ppp_percent_of_population &lt;dbl&gt;, ## # gni_atlas_method_current_us &lt;dbl&gt;, ## # gni_per_capita_atlas_method_current_us &lt;dbl&gt;, ## # gni_ppp_current_international &lt;dbl&gt;, ## # gni_per_capita_ppp_current_international &lt;dbl&gt;, ## # income_share_held_by_lowest_20_percent &lt;dbl&gt;, ## # life_expectancy_at_birth_total_years &lt;dbl&gt;, ## # fertility_rate_total_births_per_woman &lt;dbl&gt;, ## # adolescent_fertility_rate_births_per_1_000_women_ages_15_19 &lt;dbl&gt;, ## # contraceptive_prevalence_any_methods_percent_of_women_ages_15_49 &lt;dbl&gt;, ## # births_attended_by_skilled_health_staff_percent_of_total &lt;dbl&gt;, ## # mortality_rate_under_5_per_1_000_live_births &lt;dbl&gt;, ## # prevalence_of_underweight_weight_for_age_percent_of_children_under_5 &lt;dbl&gt;, ## # immunization_measles_percent_of_children_ages_12_23_months &lt;dbl&gt;, ## # primary_completion_rate_total_percent_of_relevant_age_group &lt;dbl&gt;, ## # school_enrollment_primary_percent_gross &lt;dbl&gt;, ## # school_enrollment_secondary_percent_gross &lt;dbl&gt;, ## # school_enrollment_primary_and_secondary_gross_gender_parity_index_gpi &lt;dbl&gt;, ## # prevalence_of_hiv_total_percent_of_population_ages_15_49 &lt;dbl&gt;, ## # forest_area_sq_km &lt;dbl&gt;, ## # terrestrial_and_marine_protected_areas_percent_of_total_territorial_area &lt;dbl&gt;, ## # annual_freshwater_withdrawals_total_percent_of_internal_resources &lt;dbl&gt;, ## # urban_population_growth_annual_percent &lt;dbl&gt;, ## # energy_use_kg_of_oil_equivalent_per_capita &lt;dbl&gt;, ## # co2_emissions_metric_tons_per_capita &lt;dbl&gt;, ## # electric_power_consumption_k_wh_per_capita &lt;dbl&gt;, ## # gdp_current_us &lt;dbl&gt;, ## # gdp_growth_annual_percent &lt;dbl&gt;, ## # inflation_gdp_deflator_annual_percent &lt;dbl&gt;, ## # agriculture_forestry_and_fishing_value_added_percent_of_gdp &lt;dbl&gt;, ## # industry_including_construction_value_added_percent_of_gdp &lt;dbl&gt;, ## # exports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # imports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # gross_capital_formation_percent_of_gdp &lt;dbl&gt;, ## # revenue_excluding_grants_percent_of_gdp &lt;dbl&gt;, ## # time_required_to_start_a_business_days &lt;dbl&gt;, ## # domestic_credit_provided_by_financial_sector_percent_of_gdp &lt;dbl&gt;, ## # tax_revenue_percent_of_gdp &lt;dbl&gt;, ## # military_expenditure_percent_of_gdp &lt;dbl&gt;, ## # mobile_cellular_subscriptions_per_100_people &lt;dbl&gt;, ## # high_technology_exports_percent_of_manufactured_exports &lt;dbl&gt;, ## # statistical_capacity_score_overall_average &lt;dbl&gt;, ## # merchandise_trade_percent_of_gdp &lt;dbl&gt;, ## # net_barter_terms_of_trade_index_2000_100 &lt;dbl&gt;, ## # external_debt_stocks_total_dod_current_us &lt;lgl&gt;, ## # total_debt_service_percent_of_exports_of_goods_services_and_primary_income &lt;lgl&gt;, ## # net_migration &lt;dbl&gt;, ## # personal_remittances_received_current_us &lt;dbl&gt;, ## # foreign_direct_investment_net_inflows_bo_p_current_us &lt;dbl&gt;, ## # net_official_development_assistance_and_official_aid_received_current_us &lt;dbl&gt; "],["manejo-av-ej.html", "05B - Visualización de datos (extensiones)", " 05B - Visualización de datos (extensiones) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica al comienzo del script 05A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de Environment (superior derecho). library(tidyverse) En el ejercicio trabajaremos con un panel de datos de países latinoamericanos en este milenio. Tenemos información sobre gasto en burocracia y pobreza; buscaremos responder a las preguntas (c) y (d). Los siguientes son los datos de gasto en burocracia, 2000-2017, que tienen por fuente el Banco Mundial (2017), compilados por Our World in Data: ## (este no es el formato original de OWID, aunque se parece bastante) df_gasto_burocracia &lt;- read_csv(&quot;datos/gasto_burocracia.csv&quot;) ## Parsed with column specification: ## cols( ## PAÍS = col_character(), ## AÑO = col_double(), ## `% DE BUROCRACIA EN GASTO FISCAL` = col_double() ## ) df_gasto_burocracia ## # A tibble: 216 x 3 ## PAÍS AÑO `% DE BUROCRACIA EN GASTO FISCAL` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 2000 14.7 ## 2 Argentina 2001 14.2 ## 3 Argentina 2002 11.3 ## 4 Argentina 2003 11.7 ## 5 Argentina 2004 11.5 ## 6 Argentina 2005 NA ## 7 Argentina 2006 NA ## 8 Argentina 2007 NA ## 9 Argentina 2008 NA ## 10 Argentina 2009 NA ## # ... with 206 more rows Estos son los datos de (extrema) pobreza, 2001-2017, medida como el porcentaje de la población que vive con menos de USD 1.90 al día (Banco Mundial, 2019): ## (este no es el formato original del Banco Mundial, aunque se parece bastante) df_pobreza &lt;- read_csv(&quot;datos/pobreza.csv&quot;) ## Parsed with column specification: ## cols( ## country = col_character(), ## `2001` = col_double(), ## `2002` = col_double(), ## `2003` = col_double(), ## `2004` = col_double(), ## `2005` = col_double(), ## `2006` = col_double(), ## `2007` = col_double(), ## `2008` = col_double(), ## `2009` = col_double(), ## `2010` = col_double(), ## `2011` = col_double(), ## `2012` = col_double(), ## `2013` = col_double(), ## `2014` = col_double(), ## `2015` = col_double(), ## `2016` = col_double(), ## `2017` = col_double() ## ) df_pobreza ## # A tibble: 12 x 18 ## country `2001` `2002` `2003` `2004` `2005` `2006` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 9.4 14 7 5.4 3.9 3.3 ## 2 Bolivia 22.8 24.7 NA 13.7 19.3 16.4 ## 3 Brazil 11.6 10.3 11.1 9.7 8.6 7.2 ## 4 Chile NA NA 4.2 NA NA 2.4 ## 5 Colombia 19.7 14.3 12 10.9 9.7 NA ## 6 Ecuador NA NA 14.5 15 12.1 8.1 ## 7 Guyana NA NA NA NA NA NA ## 8 Peru 17.2 15 11.7 13.5 15.3 13.3 ## 9 Paraguay 8.9 13.2 8.3 5.7 6.1 7.9 ## 10 Suriname NA NA NA NA NA NA ## 11 Uruguay NA NA NA NA NA 0.5 ## 12 Venezuela 11 18.2 22.7 19.8 18.9 10.2 ## # ... with 11 more variables: 2007 &lt;dbl&gt;, 2008 &lt;dbl&gt;, ## # 2009 &lt;dbl&gt;, 2010 &lt;dbl&gt;, 2011 &lt;dbl&gt;, 2012 &lt;dbl&gt;, ## # 2013 &lt;dbl&gt;, 2014 &lt;dbl&gt;, 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt;, ## # 2017 &lt;dbl&gt; ¿Qué necesitamos hacer con nuestros datos para poder contestar las preguntas C) y D)? A continuación, enumera las distintas modificaciones que debemos hacer para limpiar los datos, tomando en cuenta los contenidos de esta unidad. Modificación A Modificación B Etc. Ejecuta el plan de modificación/limpieza de A). Para Latinoamérica en su conjunto, ¿cómo ha evolucionado en el tiempo la media del % de gasto fiscal invertido en burocracia? C1) Genera un gráfico con dicha evolución. C2) Encuentra los valores promedios antes y después de la crisis del 2008 (te ayudará crear una variable dummy/binaria a partir de los años). A nivel latinoamericano, ¿existe una relación entre pobreza y % de gasto fiscal invertido en burocracia? Genera un gráfico para responder esta pregunta. Para cada país, utiliza el año más reciente en el que hay datos para ambas variables. "]]
