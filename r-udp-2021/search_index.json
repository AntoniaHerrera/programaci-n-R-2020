[["index.html", "Programación en Ciencias Sociales Inicio Links importantes Cronograma y materiales del curso", " Programación en Ciencias Sociales Andrés Cruz 2021-05-30 Inicio Este es el sitio web del curso “Programación en Ciencias Sociales” (CPO3523), dictado en el Escuela de Ciencia Política UDP durante el primer semestre de 2021. El objetivo del sitio es servir como material de consulta. Todos los proyectos que ejecutemos en RStudio Cloud estarán también compilados aquí, para facilitar su revisión. Links importantes Programa del curso Clases grabadas (acceso con cuenta UDP) RStudio Cloud (acceso con cuenta UDP) Cronograma y materiales del curso I. Introducción L 2021-03-08 Presentación del programa Ciencia de datos y programación Introducción a R, RStudio y R Markdown Material mínimo Material complementario RStudio. 2018a. Introducción al Lenguaje R: Guía Rápida. RStudio. 2018b. RStudio IDE: Guía Rápida. RStudio. 2014. RMarkdown: Hoja de Referencia. II. Manejo de bases de datos L 2021-03-15, L 2021-03-22 Introducción al tidyverse Carga de bases de datos Manejo de bases de datos Limpieza de bases Material mínimo Material complementario Cruz, A. 2020. Manejo de Datos. RStudio. 2017. Importar Datos: Guía Rápida RStudio. 2018. Transformación de Datos con dplyr: Hoja de referencia. III. Visualización de datos L 2021-03-29, L 2021-04-05 Principios de visualización de datos Introducción a la gramática de gráficos Generación de gráficos en ggplot2 Material mínimo Material complementario Healy, K. 2018. Data Visualization: A Practical Introduction. Cap. 1. Araya, S. 2020. Visualización de Datos. RStudio. 2016. Visualización de Datos usando ggplot2: Guía Rápida. Semana de receso 1: L 2021-04-12 IV. Búsqueda efectiva de ayuda L 2021-04-19 Archivos de ayuda en R. Recursos de apoyo: Google, StackOverflow, GitHub. Construcción de ejemplos mínimos reproducibles (reprex). Material mínimo Material complementario Healy, K. 2018. Data Visualization: A Practical Introduction. Anexo 1.1 Wickham, H. y Grolemund, G. 2017. R for Data Science. Sección 1.6. Mostipak, J. 2018. So You’ve Been Asked to Make a Reprex. Entrega Solemne 1: L 2021-04-26 V. Manejo avanzado de bases de datos L 2021-05-03 Reformulación (pivot) de bases de datos. Recodificación de variables. Combinación (merge) de bases. Material mínimo Material complementario Urdinez, F. y Cruz, A. 2020. Manejo Avanzado de Datos Políticos. RStudio. 2017b. Importar Datos: Guía Rápida. Pág. 2. Bryan, J. 2018. Cheatsheet for dplyr join functions. VI. Análisis de texto L 2021-05-10, L 2021-05-17 Manipulación de cadenas de texto. Expresiones regulares. Introducción al análisis cuantitativo de textos (QTA). Material mínimo Material complementario Wickham, H., y Grolemund, G. 2017. R for Data Science. Cap. 14. Silge, J. y Robinson, D. 2018. Text Mining with R. Caps. 1-3. RStudio. 2017c. Trabajar con Cadenas con stringr: Guía Rápida VII. Minería de datos web y R avanzado L 2021-05-24 Tipos de objeto en R Funciones personalizadas. Iteraciones Material mínimo Material complementario Wickham, H., y Grolemund, G. 2017. R for Data Science. Caps. 19 y 21. Barría, G. 2021. Minería de Datos Web. Densmore, J. 2017. Ethics in web scraping. RStudio. 2017a. Aplicar Funciones con purrr: Guía Rápida. Entrega Ensayo Breve: L 2021-05-24 [Instrucciones y pauta] Semana de receso 2: L 2021-05-31 VIII. Replicación y generación de reportes L 2021-06-07 Replicación en ciencias sociales. R Markdown para reportes y presentaciones. Material mínimo Material complementario King, G. 1995. Replication, Replication. RStudio. 2014. RMarkdown: Hoja de Referencia. Entrega Solemne 2: L 2021-06-14 Presentaciones y retroalimentación para el trabajo final: L 2021-06-21 Feriado: L 2021-06-28 Prueba recuperativa: A fijar entre M 2021-06-29 y V 2021-07-02 IX. Datos espaciales y mapas / X. Cierre L 2021-07-05 Introducción a los datos espaciales con sf. Mapas en ggplot2. Ciencia social computacional. La comunidad de R. RStudio de escritorio. Material mínimo Material complementario Escobar, A. y Ortiz, G. 2021. Mapas y Datos Espaciales. Grimmer, J. 2015. We Are All Social Scientists Now. Frick, H., y Daish, A. 2017. R-Ladies Global Community. Garnett, R. 2018. Spatial Manipulation with sf: Cheatsheet. Entrega del trabajo escrito final: M 2021-07-06 Examen: L 2021-07-12 "],["rbasico.html", "01A - R básico Introducción: comandos y código Paquetes Comandos básicos y tipos de objeto en R Sintaxis de R Markdown Título de prueba Siguiente script", " 01A - R básico Diapositivas de introducción Si quieres correr este script localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar: tidyverse. Este es un script de R Markdown, una forma de registrar nuestro código de R. Sabemos esto por por la extensión .Rmd y todas las opciones que están fijadas más arriba (por ahora no nos concentraremos demasiado en ellas). Antes de comenzar, juguemos un poco con las opciones de RStudio. Vamos a Tools &gt; Global Options &gt; Appearance. Introducción: comandos y código En los scripts de R Markdown el texto plano (como este) nos permite añadir comentarios, explicaciones, etc. Cuando ocupemos código debemos insertarlo en “chunks” o bloques de código, como veremos a continuación. Haremos un bloque de código para ocupar R como una calculadora simple. Podemos correr el código línea por línea con Ctrl/Cmd + Enter, si nuestro teclado está en dicha parte del script. Para correr el chunk completo puedes presionar en el pequeño botón de “Play” en la parte superior derecha o presionar Ctrl/Cmd + Shift + Enter. 1 + 5 ## [1] 6 78878.12 * 8e05 / (12 - 7 + 87.2) # este es un comentario &quot;en línea&quot;, se antecede con un # ## [1] 684408850 Para crear un chunk, debes presionar Ctrl/Cmd + Alt + i. Prueba a crear un chunk y calcula alguna operación aritmética. Tu código: En R podemos crear objetos, que guardarán información para ser utilizada en operaciones siguientes: mi_objeto &lt;- 5 mi_objeto # poner su nombre lo imprime, sin más ## [1] 5 Por ejemplo, podemos hacer aritmética con este nuevo objeto: mi_objeto - 17 ## [1] -12 ¿Cuál es la diferencia entre este último comando y el siguiente? mi_objeto_b &lt;- mi_objeto - 17 Eliminemos este segundo objeto, utilizando la funcion rm() (remove): rm(mi_objeto_b) Si quisiéramos reiniciar la sesión (comenzando todo desde cero), podríamos presionar Session &gt; Restart R) y clickear en la escoba del panel “Environment” de RStudio (superior derecho). Paquetes Los paquetes añaden nuevas funciones a R. Hay que cargarlos en cada nueva sesión, con el comando library(). library(tidyverse) El tidyverse es un paquete que ocuparemos en todas nuestras clases, que añade una gran cantidad de funciones al lenguaje. Ojo! library() solo nos permite cargar paquetes que hayamos instalado. Aquí en RStudio Cloud yo instalé el tidyverse para todas/os, pero por defecto habría que instalarlo. Probemos a utilizar otro paquete, fun: library(fun) Debemos instalarlo. Basta con instalar los paquetes una vez, luego podremos cargarlos en cada sesión que queramos. La mayoría de los paquetes se instalan con el comando install.packages(\"paquete\"): install.packages(&quot;fun&quot;) Por cierto, podemos saber que R está trabajando gracias a RStudio. Mientras el paquete se instala, fíjate que hay una pequeña línea (¿color?) en la parte izquierda del código. Terminada la instalación, carguemos el nuevo paquete: library(fun) # ahora el paquete está instalado, por lo que carga sin problemas (Ejercicio A) Prueba a instalar un paquete llamado “fun”. Luego, cárgalo y corre el siguiente comando: random_password(). ¿Qué hace? Recuerda registrar todo el proceso en el script! Tu código: Comandos básicos y tipos de objeto en R En esta sección veremos vectores, data frames (marcos de datos) y listas. Vectores Lo siguiente es un vector numérico: c(7, 9, 19, 2, 9) ## [1] 7 9 19 2 9 El siguiente comando creará un objeto (mi_vector). ¿Qué contendrá este nuevo objeto? mi_vector &lt;- c(2, -3, mi_objeto, 6:9) Veamos algunos comandos básicos a aplicar en números y vectores numéricos. mi_vector[2] # acceder al segundo elemento del vector ## [1] -3 sqrt(x = mi_objeto) # la raíz cuadrada es una función! ## [1] 2.236068 log(x = mi_objeto) # logaritmo natural ## [1] 1.609438 mean(x = mi_vector) # media del vector ## [1] 4.857143 media_mi_vector &lt;- mean(x = mi_vector) # si quisiéramos guardarla como objeto! median(x = mi_vector) # mediana del vector ## [1] 6 quantile(x = mi_vector, probs = c(0.25, 0.5, 0.75)) # q1, q2, q3 ## 25% 50% 75% ## 3.5 6.0 7.5 sd(x = mi_vector) # desviación estándar del vector ## [1] 4.140393 length(x = mi_vector) # número de elementos del vector ## [1] 7 sum(x = mi_vector) # suma del vector ## [1] 34 min(x = mi_vector) # ¿qué hace esta función? ## [1] -3 max(x = mi_vector) # ¿y esta? ## [1] 9 Todas las funciones que hemos visto simplemente tomaban un objeto, sin más. La mayoría de las funciones son más complejas: requieren más de un objeto o nos permiten integrar más opciones. Les damos instrucciones específicas a las funciones por medio de argumentos (hasta ahora, solo vimos funciones con el inicio de argumento “x =”). sort(x = mi_vector) # ordena el vector de menor a mayor ## [1] -3 2 5 6 7 8 9 sort(x = mi_vector, decreasing = TRUE) # ¿qué cambia con este argumento? ## [1] 9 8 7 6 5 2 -3 Nota que podemos añadir saltos de línea entre argumentos: sort(x = mi_vector, decreasing = TRUE) ## [1] 9 8 7 6 5 2 -3 Importante. Si ponemos los valores de los argumentos en orden, podemos evitar escribir los argumentos mismos: sort(mi_vector, TRUE) # igual resultado que nuestros comandos anteriores ## [1] 9 8 7 6 5 2 -3 Por cierto, podemos consultar el archivo de ayuda de una función fácilmente. Ahí encontraremos los distintos argumentos explicados: ?sort Los vectores también pueden ser de otros tipos: c(&quot;Manzana&quot;, &quot;Pera&quot;, &quot;Naranja&quot;, &quot;Damasco&quot;) # vector de caracteres. Nota las comillas! ## [1] &quot;Manzana&quot; &quot;Pera&quot; &quot;Naranja&quot; ## [4] &quot;Damasco&quot; nchar(&quot;Manzana&quot;) # cuenta los caracteres de un elemento ## [1] 7 c(TRUE, FALSE, TRUE, TRUE) # vector lógico ## [1] TRUE FALSE TRUE TRUE c(T, F, T, T) ## [1] TRUE FALSE TRUE TRUE (Ejercicio B) De nuevo ocupa la función random_password() del paquete fun, pero esta vez con el argumento length = 10. Prueba con diferentes valores del argumento! Tu código: Data frames (marcos de datos) Los data frames son objetos centrales en R, sin duda los que más utilizaremos. Vamos a cargar uno simple: df_trump_scores &lt;- read_csv(&quot;datos/trump_scores_202003_cong116.csv&quot;) # esta función es del tidyverse! ## ## ── Column specification ───────────── ## cols( ## last_name = col_character(), ## state = col_character(), ## party = col_character(), ## trump_score = col_double(), ## trump_margin = col_double() ## ) El “Trump Score” es el porcentaje de votaciones en las que un senador/a ha estado alineado/a con Donald Trump. El “Trump Margin” es el margen que Trump obtuvo en el estado del senador/a en cuestión. Fuente: FiveThirtyEight (2020). Descargado el 11 de marzo de 2020. df_trump_scores # imprime un vistazo rápido ## # A tibble: 100 x 5 ## last_name state party trump_score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 ## 2 Blunt MO R 84.8 ## 3 Brown OH D 14.7 ## 4 Burr NC R 90.3 ## 5 Baldwin WI D 14.7 ## 6 Boozman AR R 88.2 ## 7 Blackburn TN R 93.9 ## 8 Barrasso WY R 91.2 ## 9 Bennet CO D 15.4 ## 10 Blumenthal CT D 11.8 ## # … with 90 more rows, and 1 more ## # variable: trump_margin &lt;dbl&gt; head(df_trump_scores) # imprime solo las seis primeras filas ## # A tibble: 6 x 5 ## last_name state party trump_score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 ## 2 Blunt MO R 84.8 ## 3 Brown OH D 14.7 ## 4 Burr NC R 90.3 ## 5 Baldwin WI D 14.7 ## 6 Boozman AR R 88.2 ## # … with 1 more variable: ## # trump_margin &lt;dbl&gt; También podemos inspeccionar un data frame clickeando su nombre en el panel superior derecho, pestaña Environment. Las columnas de un data frame son vectores! df_trump_scores$last_name ## [1] &quot;Alexander&quot; &quot;Blunt&quot; ## [3] &quot;Brown&quot; &quot;Burr&quot; ## [5] &quot;Baldwin&quot; &quot;Boozman&quot; ## [7] &quot;Blackburn&quot; &quot;Barrasso&quot; ## [9] &quot;Bennet&quot; &quot;Blumenthal&quot; ## [11] &quot;Booker&quot; &quot;Braun&quot; ## [13] &quot;Cantwell&quot; &quot;Cardin&quot; ## [15] &quot;Carper&quot; &quot;Crapo&quot; ## [17] &quot;Collins&quot; &quot;Capito&quot; ## [19] &quot;Cornyn&quot; &quot;Casey&quot; ## [21] &quot;Cassidy&quot; &quot;Coons&quot; ## [23] &quot;Cotton&quot; &quot;Cramer&quot; ## [25] &quot;Cruz&quot; &quot;Cortez Masto&quot; ## [27] &quot;Durbin&quot; &quot;Daines&quot; ## [29] &quot;Duckworth&quot; &quot;Enzi&quot; ## [31] &quot;Ernst&quot; &quot;Feinstein&quot; ## [33] &quot;Fischer&quot; &quot;Graham&quot; ## [35] &quot;Grassley&quot; &quot;Gillibrand&quot; ## [37] &quot;Gardner&quot; &quot;Hirono&quot; ## [39] &quot;Heinrich&quot; &quot;Hoeven&quot; ## [41] &quot;Harris&quot; &quot;Hassan&quot; ## [43] &quot;Hyde-Smith&quot; &quot;Hawley&quot; ## [45] &quot;Inhofe&quot; &quot;Johnson&quot; ## [47] &quot;Jones&quot; &quot;Klobuchar&quot; ## [49] &quot;King&quot; &quot;Kaine&quot; ## [51] &quot;Kennedy&quot; &quot;Leahy&quot; ## [53] &quot;Lankford&quot; &quot;Lee&quot; ## [55] &quot;Loeffler&quot; &quot;Markey&quot; ## [57] &quot;McConnell&quot; &quot;Menendez&quot; ## [59] &quot;Moran&quot; &quot;Murray&quot; ## [61] &quot;Murkowski&quot; &quot;Murphy&quot; ## [63] &quot;Merkley&quot; &quot;Manchin&quot; ## [65] &quot;McSally&quot; &quot;Portman&quot; ## [67] &quot;Peters&quot; &quot;Paul&quot; ## [69] &quot;Perdue&quot; &quot;Reed&quot; ## [71] &quot;Roberts&quot; &quot;Risch&quot; ## [73] &quot;Rubio&quot; &quot;Rounds&quot; ## [75] &quot;Rosen&quot; &quot;Romney&quot; ## [77] &quot;Sanders&quot; &quot;Schumer&quot; ## [79] &quot;Shelby&quot; &quot;Stabenow&quot; ## [81] &quot;Shaheen&quot; &quot;Scott&quot; ## [83] &quot;Sinema&quot; &quot;Schatz&quot; ## [85] &quot;Sasse&quot; &quot;Sullivan&quot; ## [87] &quot;Smith&quot; &quot;Scott&quot; ## [89] &quot;Thune&quot; &quot;Toomey&quot; ## [91] &quot;Tester&quot; &quot;Tillis&quot; ## [93] &quot;Udall&quot; &quot;Van Hollen&quot; ## [95] &quot;Wicker&quot; &quot;Wyden&quot; ## [97] &quot;Whitehouse&quot; &quot;Warner&quot; ## [99] &quot;Warren&quot; &quot;Young&quot; df_trump_scores$trump_score ## [1] 80.000000 84.848485 ## [3] 14.705882 90.322581 ## [5] 14.705882 88.235294 ## [7] 93.939394 91.176471 ## [9] 15.384615 11.764706 ## [11] 4.166667 94.117647 ## [13] 15.151515 15.151515 ## [15] 11.764706 93.548387 ## [17] 41.176471 93.939394 ## [19] 91.176471 20.588235 ## [21] 84.848485 14.705882 ## [23] 82.352941 90.909091 ## [25] 93.750000 11.764706 ## [27] 18.181818 79.411765 ## [29] 16.129032 90.909091 ## [31] 91.176471 14.705882 ## [33] 88.235294 76.666667 ## [35] 91.176471 7.692308 ## [37] 83.870968 14.705882 ## [39] 20.588235 91.176471 ## [41] 4.545455 14.705882 ## [43] 91.176471 85.294118 ## [45] 90.909091 91.176471 ## [47] 21.212121 7.692308 ## [49] 17.647059 14.705882 ## [51] 88.235294 14.705882 ## [53] 88.235294 63.636364 ## [55] 100.000000 8.823529 ## [57] 91.176471 11.764706 ## [59] 57.575758 14.705882 ## [61] 56.250000 17.647059 ## [63] 11.764706 32.352941 ## [65] 91.176471 84.848485 ## [67] 14.705882 60.714286 ## [69] 92.857143 8.823529 ## [71] 91.176471 90.625000 ## [73] 81.250000 92.857143 ## [75] 12.500000 79.411765 ## [77] 5.263158 11.764706 ## [79] 91.176471 14.705882 ## [81] 14.705882 87.500000 ## [83] 24.242424 11.764706 ## [85] 87.500000 90.322581 ## [87] 17.647059 91.176471 ## [89] 91.176471 84.375000 ## [91] 11.764706 88.235294 ## [93] 17.647059 14.705882 ## [95] 85.294118 8.823529 ## [97] 9.375000 14.705882 ## [99] 9.090909 64.705882 Producto de esto, podemos operar en ellas usando las funciones que aprendimos antes. (Ejercicio C) Calcula la mediana de los Trumps Scores y la mediana de los Trump Margins. Tu código: Ejemplos de análisis con data frames En general, la forma de data frame nos es útil para correr análisis. Aquí un gráfico exploratorio (no miraremos demasiado la sintaxis): ggplot(data = df_trump_scores, mapping = aes(x = trump_margin, trump_score, color = party)) + geom_point() + scale_color_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) Aquí una regresión lineal, que busca estimar el Trump Score de un senador/a de acuerdo a dos predictores: el margen de Trump en su estado y su partido político: mi_modelo &lt;- lm(trump_score ~ trump_margin + party, data = df_trump_scores) summary(mi_modelo) ## ## Call: ## lm(formula = trump_score ~ trump_margin + party, data = df_trump_scores) ## ## Residuals: ## Min 1Q Median 3Q ## -40.151 -1.952 1.599 4.487 ## Max ## 17.239 ## ## Coefficients: ## Estimate Std. Error ## (Intercept) 15.71390 1.40190 ## trump_margin 0.17650 0.06248 ## partyR 66.13619 2.50530 ## t value Pr(&gt;|t|) ## (Intercept) 11.209 &lt; 2e-16 *** ## trump_margin 2.825 0.00574 ** ## partyR 26.399 &lt; 2e-16 *** ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 ## &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.623 on 97 degrees of freedom ## Multiple R-squared: 0.9463, Adjusted R-squared: 0.9452 ## F-statistic: 854.5 on 2 and 97 DF, p-value: &lt; 2.2e-16 Listas Las listas son objetos que pueden contener otros objetos, sin importar su tipo! mi_lista &lt;- list(mi_objeto, mi_vector, df_trump_scores, mi_modelo) De la siguiente forma podemos acceder a los elementos de una lista, similar a lo que hicimos antes con vectores: mi_lista[3] ## [[1]] ## # A tibble: 100 x 5 ## last_name state party trump_score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 ## 2 Blunt MO R 84.8 ## 3 Brown OH D 14.7 ## 4 Burr NC R 90.3 ## 5 Baldwin WI D 14.7 ## 6 Boozman AR R 88.2 ## 7 Blackburn TN R 93.9 ## 8 Barrasso WY R 91.2 ## 9 Bennet CO D 15.4 ## 10 Blumenthal CT D 11.8 ## # … with 90 more rows, and 1 more ## # variable: trump_margin &lt;dbl&gt; mi_lista[[3]] ## # A tibble: 100 x 5 ## last_name state party trump_score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 ## 2 Blunt MO R 84.8 ## 3 Brown OH D 14.7 ## 4 Burr NC R 90.3 ## 5 Baldwin WI D 14.7 ## 6 Boozman AR R 88.2 ## 7 Blackburn TN R 93.9 ## 8 Barrasso WY R 91.2 ## 9 Bennet CO D 15.4 ## 10 Blumenthal CT D 11.8 ## # … with 90 more rows, and 1 more ## # variable: trump_margin &lt;dbl&gt; ¿Cuál es la diferencia entre estos dos últimos comandos? El primero devuelve una nueva lista con solo un elemento, el tercero de la lista original. El segundo, en tanto, devuelve el contenido del tercer elemento de la lista. Sintaxis de R Markdown En el texto de nuestros documentos podemos escribir en cursiva o negrita. También podemos insertar links. Usualmente cuando queremos hablar de paquetes o funciones dentro de nuestro texto los escribimos entre tildes invertidos: tidyverse, mean(). Crear tablas también es relativamente simple. Con texto: Nombre Descripción Juan Un estudiante Marta Una estudiante O a partir de un data frame, con código: library(knitr) kable(head(df_trump_scores)) last_name state party trump_score trump_margin Alexander TN R 80.00000 26.0057009 Blunt MO R 84.84848 18.6371170 Brown OH D 14.70588 8.1295744 Burr NC R 90.32258 3.6552285 Baldwin WI D 14.70588 0.7643432 Boozman AR R 88.23529 26.9209780 Importante. Por favor noten que la primera tabla ocupa sintaxis de R Markdown en vez de código de R, por lo que no está dentro de un chunk! También podemos incluir ecuaciones, escritas entre signos de peso con la sintaxis de \\(\\LaTeX\\). Un ejemplo: \\(\\hat{\\beta}=(X&#39;X)^{-1}X&#39;Y\\). Título de prueba Subtítulo Una lista Artículo de lista uno Artículo de lista dos Artículo derivado (nota los cuatro espacios antes del símbolo “+”). Artículo de lista tres Otra lista (ahora ordenada) Artículo de lista uno Artículo de lista dos Artículo de lista tres Nota que los números de la lista aparecerán solos en el documento compilado. Una imagen Podemos insertar una imagen, referenciando su ubicación en nuestra carpeta del proyecto: Compilar nuestro documento Podemos compilar nuestro código a un documento utilizando el botón “Knit” en RStudio, o presionando Ctrl/Cmd + Shift + K. (Ejercicio D) Crea un vector numérico, que vaya desde 4 hasta 109. Luego, calcula su media y mediana. Recuerda crear tu(s) chunk(s) con Ctrl/Cmd + Alt + i. Siguiente script Pasemos brevemente a ver el script 01b. "],["manejo-02a.html", "02A - Manejo de datos Manejo de bases de datos La base de datos ideal: tidy Operaciones básicas en bases de datos (Wickham, 2014) Trabajo con R Manejo de datos: operaciones básicas Agregar/colapsar con summarize() / hacer operaciones por grupos con group_by() Hacer cadenas de operaciones con las pipes (%&gt;%)", " 02A - Manejo de datos Si quieres correr este script localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (2A, 2B, 2C, 2D): tidyverse, janitor, writexl, learnr. Manejo de bases de datos Manejo de datos = limpiar y ordenar datos para poder analizarlos. Se suele decir que el 80% del análisis de datos es solo manejo (Wickham, 2014). Fuente: Wickham &amp; Grolemund (2017) Partes de una base de datos tabular Encabezado (header) Fila (row) Columna (column) Celda (cell) Una pequeña mnemotecnia: La base de datos ideal: tidy En el paradigma “tidy” (Wickham, 2014): Cada variable es una columna Cada observación es una fila Cada valor es una celda Existe una base de datos para cada unidad observacional (Ejercicio A) Por favor revisar este link. Contiene un panel para las emisiones anuales de CO2 de los países americanos (unidad de medida: toneladas per capita). Hay tres bases con la misma información, una por cada hoja. ¿Cuál es la “tidy”? Operaciones básicas en bases de datos (Wickham, 2014) Transformar columnas (añadir o modificar existentes) Puede ser en una sola columna o en múltiples columnas En el tidyverse, mutate() Seleccionar columnas (y excluir otras) En el tidyverse, select() Filtrar observaciones en base a una condición En el tidyverse, filter() Ordenar la base de datos, en base a una(s) variable(s) En el tidyverse, arrange() Agregar/colapsar la base de datos Colapsar múltiples valores en algún resumen (por ejemplo, media o suma) Puede ser para toda la base o por subgrupos En el tidyverse, summarize() (Ejercicio B) Favor ir a este link ¿Qué operaciones básicas pueden ser interesantes para comenzar a analizar estos datos? Contesta con dos ejemplos: Trabajo con R Comenzaremos cargando el tidyverse: library(tidyverse) Base de datos: aprobación de presidentes/as en Latinoamérica Tenemos una base de datos ligeramente editada a partir de Reyes-Housholder (2019). Incluye también un par de variables de los World Development Indicators, recopiladas por Quality of Government. La base de datos se encuentra en datos/base_aprob_reyes-housholder.csv. Contiene información de la aprobación de presidentes/as en 17 países de América Latina por trimestre (2000-2014), además de variables de control. ¿Cuál es la unidad de análisis de la base? ¿Cuántas observaciones tendrá, asumiendo un panel balanceado? Carga de base en formato csv df_aprob &lt;- read_csv(&quot;datos/base_aprob_reyes-housholder.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## country = col_character(), ## year = col_double(), ## quarter = col_double(), ## president = col_character(), ## net_approval = col_double(), ## pres_sex = col_character(), ## pres_sex_d = col_double(), ## exec_corr = col_double(), ## gdp_growth = col_double(), ## unemp = col_double(), ## wdi_gdp = col_double(), ## wdi_pop = col_double() ## ) Resúmenes simples para data frames El resumen más simple de un objeto en R suele poder obtenerse con su nombre comando. Nota cómo debajo de cada nombre, algunas variables tienen &lt;dbl&gt; y otras &lt;chr&gt;. ¿Qué significa esto? df_aprob ## # A tibble: 1,020 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Por cierto, podemos obtener un resumen similar clickeando nuestro objeto en el panel “Environment” (superior derecho) de RStudio. Esto es lo mismo que ocupar el comando View(): View(df_aprob) Otro resumen útil es la función glimpse() del tidyverse, que nos da otra perspectiva: glimpse(df_aprob) ## Rows: 1,020 ## Columns: 12 ## $ country &lt;chr&gt; &quot;Argentina&quot;, &quot;… ## $ year &lt;dbl&gt; 2000, 2000, 20… ## $ quarter &lt;dbl&gt; 1, 2, 3, 4, 1,… ## $ president &lt;chr&gt; &quot;Fernando de l… ## $ net_approval &lt;dbl&gt; 40.126, 16.390… ## $ pres_sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;… ## $ pres_sex_d &lt;dbl&gt; 0, 0, 0, 0, 0,… ## $ exec_corr &lt;dbl&gt; 14.01525, 14.0… ## $ gdp_growth &lt;dbl&gt; -0.8, -0.8, -0… ## $ unemp &lt;dbl&gt; 15.0, 15.0, 15… ## $ wdi_gdp &lt;dbl&gt; 552151219031, … ## $ wdi_pop &lt;dbl&gt; 37057452, 3705… ¿Qué significan las variables de esta base de datos? Completa la siguiente tabla: Variable Descripción country País. year Año. quarter Trimestre. president Presidente/a. net_approval Aprobación neta del presidente/a (% aprobación - % rechazo). pres_sex pres_sex_d exec_corr Corrupción en el Ejecutivo, según V-Dem. De 0 a 100 (mayor es más corrupción). gdp_growth unemp wdi_gdp Producto interno bruto del país, ajustado por paridad de cambio (PPP) y constante en dólares del 2011. wdi_pop Manejo de datos: operaciones básicas En todas las operaciones básicas que veremos hoy el primer argumento en la función será el data frame a editar. Seleccionar columnas con select() Seleccionemos solo la columna de países: select(df_aprob, country) ## # A tibble: 1,020 x 1 ## country ## &lt;chr&gt; ## 1 Argentina ## 2 Argentina ## 3 Argentina ## 4 Argentina ## 5 Argentina ## 6 Argentina ## 7 Argentina ## 8 Argentina ## 9 Argentina ## 10 Argentina ## # … with 1,010 more rows Recuerda que esto no creó ningún objeto nuevo, es solo un comando que estamos ejecutando en la consola. Si quisiéramos crear un objeto nuevo, tendríamos que asignarlo: df_aprob_reducida &lt;- select(df_aprob, country) df_aprob_reducida ## # A tibble: 1,020 x 1 ## country ## &lt;chr&gt; ## 1 Argentina ## 2 Argentina ## 3 Argentina ## 4 Argentina ## 5 Argentina ## 6 Argentina ## 7 Argentina ## 8 Argentina ## 9 Argentina ## 10 Argentina ## # … with 1,010 more rows Podemos seleccionar múltiples columnas a la vez, separadas por comas: select(df_aprob, country, year, unemp) ## # A tibble: 1,020 x 3 ## country year unemp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 2000 15 ## 2 Argentina 2000 15 ## 3 Argentina 2000 15 ## 4 Argentina 2000 15 ## 5 Argentina 2001 18.3 ## 6 Argentina 2001 18.3 ## 7 Argentina 2001 18.3 ## 8 Argentina 2001 18.3 ## 9 Argentina 2002 17.9 ## 10 Argentina 2002 17.9 ## # … with 1,010 more rows Supongamos que queremos las primeras cinco variables de la base de datos. Las siguientes tres formas nos permitirán obtenerlas: select(df_aprob, country, year, quarter, president, net_approval) ## # A tibble: 1,020 x 5 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 1 more ## # variable: net_approval &lt;dbl&gt; select(df_aprob, country:net_approval) # esta es la forma recomendada para la mayoría de los casos ## # A tibble: 1,020 x 5 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 1 more ## # variable: net_approval &lt;dbl&gt; select(df_aprob, 1:5) ## # A tibble: 1,020 x 5 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 1 more ## # variable: net_approval &lt;dbl&gt; El comando select() también nos sirve para reordenar las columnas. Supongamos que queremos que la variable president sea la primera. Podemos hacer algo como esto: select(df_aprob, president, country:year, net_approval:unemp) ## # A tibble: 1,020 x 9 ## president country year ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Fernando de la Rúa Argenti… 2000 ## 2 Fernando de la Rúa Argenti… 2000 ## 3 Fernando de la Rúa Argenti… 2000 ## 4 Fernando de la Rúa Argenti… 2000 ## 5 Fernando de la Rúa Argenti… 2001 ## 6 Fernando de la Rúa Argenti… 2001 ## 7 Fernando de la Rúa Argenti… 2001 ## 8 Fernando de la Rúa Argenti… 2001 ## 9 Eduardo Alberto Du… Argenti… 2002 ## 10 Eduardo Alberto Du… Argenti… 2002 ## # … with 1,010 more rows, and 6 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt; Esta forma es un poco tediosa. Hay una función de ayuda que nos será útil en este caso, se llama everything() select(df_aprob, president, everything()) # selecciona &quot;president&quot; y todo lo demás ## # A tibble: 1,020 x 12 ## president country year quarter ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Fernando de… Argent… 2000 1 ## 2 Fernando de… Argent… 2000 2 ## 3 Fernando de… Argent… 2000 3 ## 4 Fernando de… Argent… 2000 4 ## 5 Fernando de… Argent… 2001 1 ## 6 Fernando de… Argent… 2001 2 ## 7 Fernando de… Argent… 2001 3 ## 8 Fernando de… Argent… 2001 4 ## 9 Eduardo Alb… Argent… 2002 1 ## 10 Eduardo Alb… Argent… 2002 2 ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Finalmente, también podemos excluir variables con un signo -: select(df_aprob, -president) ## # A tibble: 1,020 x 11 ## country year quarter net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argent… 2000 1 40.1 ## 2 Argent… 2000 2 16.4 ## 3 Argent… 2000 3 24.0 ## 4 Argent… 2000 4 -18.3 ## 5 Argent… 2001 1 -6.97 ## 6 Argent… 2001 2 -20.1 ## 7 Argent… 2001 3 -19.4 ## 8 Argent… 2001 4 -23.2 ## 9 Argent… 2002 1 -2.01 ## 10 Argent… 2002 2 -20.1 ## # … with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Renombrar columnas con rename() Podemos cambiar el nombre de una columna con el comando rename(). Por ejemplo: rename(df_aprob, trimeste = quarter) # noten que no estoy modificando la base, solo imprimiéndola! ## # A tibble: 1,020 x 12 ## country year trimeste president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando … ## 2 Argenti… 2000 2 Fernando … ## 3 Argenti… 2000 3 Fernando … ## 4 Argenti… 2000 4 Fernando … ## 5 Argenti… 2001 1 Fernando … ## 6 Argenti… 2001 2 Fernando … ## 7 Argenti… 2001 3 Fernando … ## 8 Argenti… 2001 4 Fernando … ## 9 Argenti… 2002 1 Eduardo A… ## 10 Argenti… 2002 2 Eduardo A… ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Filtrar observaciones con filter() A menudo queremos quedarnos solo con algunas observaciones de nuestra base de datos, filtrando de acuerdo a características específicas. Podemos hacer esto gracias a la función filter() y algo llamado “operadores lógicos”. Para comenzar, quedémonos solo con las observaciones de Chile: filter(df_aprob, country == &quot;Chile&quot;) ## # A tibble: 60 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Chile 2000 1 Eduardo Fre… ## 2 Chile 2000 2 Ricardo Lag… ## 3 Chile 2000 3 Ricardo Lag… ## 4 Chile 2000 4 Ricardo Lag… ## 5 Chile 2001 1 Ricardo Lag… ## 6 Chile 2001 2 Ricardo Lag… ## 7 Chile 2001 3 Ricardo Lag… ## 8 Chile 2001 4 Ricardo Lag… ## 9 Chile 2002 1 Ricardo Lag… ## 10 Chile 2002 2 Ricardo Lag… ## # … with 50 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Le estamos diciendo a filter(), por medio del segundo argumento, que solo se quede con observaciones en las que la variable country es igual a Chile. Este “es igual a” es un operador lógico, que se escribe como “==” en R. Aquí hay una lista de operadores lógicos comunes: operador descripción == es igual a != es distinto a &gt; es mayor a &lt; es menor a &gt;= es mayor o igual a &lt;= es menor o igual a &amp; intersección | unión %in% está contenido en Por ejemplo, podemos obtener todas las observaciones (país-año-trimestre) en las que la aprobación presidencial neta es positiva: filter(df_aprob, net_approval &gt; 0) ## # A tibble: 709 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2003 2 Eduardo Al… ## 5 Argenti… 2003 3 Néstor Car… ## 6 Argenti… 2003 4 Néstor Car… ## 7 Argenti… 2004 1 Néstor Car… ## 8 Argenti… 2004 2 Néstor Car… ## 9 Argenti… 2004 3 Néstor Car… ## 10 Argenti… 2004 4 Néstor Car… ## # … with 699 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Podemos también realizar filtros más complejos. Obtengamos solo las observaciones del Cono Sur: filter(df_aprob, country == &quot;Argentina&quot; | country == &quot;Chile&quot; | country == &quot;Uruguay&quot;) ## # A tibble: 180 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 170 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; filter(df_aprob, country %in% c(&quot;Argentina&quot;, &quot;Chile&quot;, &quot;Uruguay&quot;)) # lo mismo, con otro op. lógico ## # A tibble: 180 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 170 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Podemos también incluir pequeñas operaciones en nuestros filtros. Obtengamos todas las observaciones en las que la corrupción ejecutiva es mayor a la del promedio de toda la base: filter(df_aprob, exec_corr &gt; mean(exec_corr)) ## # A tibble: 456 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2003 1 Eduardo Al… ## 2 Argenti… 2003 2 Eduardo Al… ## 3 Argenti… 2003 3 Néstor Car… ## 4 Argenti… 2003 4 Néstor Car… ## 5 Argenti… 2004 1 Néstor Car… ## 6 Argenti… 2004 2 Néstor Car… ## 7 Argenti… 2004 3 Néstor Car… ## 8 Argenti… 2004 4 Néstor Car… ## 9 Argenti… 2005 1 Néstor Car… ## 10 Argenti… 2005 2 Néstor Car… ## # … with 446 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; (Ejercicios C) (C1) Selecciona solo las dos columnas que registran el sexo del presidente/a en la base de datos. Recuerda que los chunks se insertan con Ctrl/Cmd + Alt + i. Tu código: (C2) Filtra la base de datos para que solo tenga las observaciones del año 2000. Tu código: (C3) Filtra la base de datos para que solo incluya observaciones de crisis económica: cuando el crecimiento del PIB sea negativo y/o el desempleo sea mayor al 20%. Tu código: Ordenar el data frame con arrange() Podemos cambiar el orden de las observaciones con el comando arrange(). Por ejemplo, ordenémoslas desde el país-año-trimestre menos corrupto al más corrupto: arrange(df_aprob, exec_corr) ## # A tibble: 1,020 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Uruguay 2000 1 Julio Sangu… ## 2 Uruguay 2000 2 Jorge Battle ## 3 Uruguay 2000 3 Jorge Battle ## 4 Uruguay 2000 4 Jorge Battle ## 5 Uruguay 2001 1 Jorge Battle ## 6 Uruguay 2001 2 Jorge Battle ## 7 Uruguay 2001 3 Jorge Battle ## 8 Uruguay 2001 4 Jorge Battle ## 9 Uruguay 2002 1 Jorge Battle ## 10 Uruguay 2002 2 Jorge Battle ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Si quisiéramos ordenarlo inversamente, tendríamos que añadir un - (signo menos) antes de la variable: arrange(df_aprob, -exec_corr) ## # A tibble: 1,020 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Venezue… 2013 1 Hugo Chávez ## 2 Venezue… 2013 2 Nicolás Ma… ## 3 Venezue… 2013 3 Nicolás Ma… ## 4 Venezue… 2013 4 Nicolás Ma… ## 5 Venezue… 2014 1 Nicolás Ma… ## 6 Venezue… 2014 2 Nicolás Ma… ## 7 Venezue… 2014 3 Nicolás Ma… ## 8 Venezue… 2014 4 Nicolás Ma… ## 9 Venezue… 2007 1 Hugo Chávez ## 10 Venezue… 2007 2 Hugo Chávez ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Atención, lo anterior solo sirve en columnas numéricas. Para ordenar una categórica inversamente, debemos usar el comando desc(): arrange(df_aprob, desc(country)) ## # A tibble: 1,020 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Venezuela 2000 1 Hugo Cháv… ## 2 Venezuela 2000 2 Hugo Cháv… ## 3 Venezuela 2000 3 Hugo Cháv… ## 4 Venezuela 2000 4 Hugo Cháv… ## 5 Venezuela 2001 1 Hugo Cháv… ## 6 Venezuela 2001 2 Hugo Cháv… ## 7 Venezuela 2001 3 Hugo Cháv… ## 8 Venezuela 2001 4 Hugo Cháv… ## 9 Venezuela 2002 1 Hugo Cháv… ## 10 Venezuela 2002 2 Hugo Cháv… ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Podemos ordenar por más de una variable. Esto es, ordenar a partir de una primera variable y luego ordenar los empates a partir de otra segunda variable. Veamos el siguiente ejemplo: arrange(df_aprob, pres_sex, -net_approval) ## # A tibble: 1,020 x 12 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Brazil 2013 1 Dilma Vana… ## 2 Brazil 2012 4 Dilma Vana… ## 3 Brazil 2012 2 Dilma Vana… ## 4 Brazil 2012 3 Dilma Vana… ## 5 Brazil 2012 1 Dilma Vana… ## 6 Brazil 2011 4 Dilma Vana… ## 7 Brazil 2011 1 Dilma Vana… ## 8 Brazil 2011 3 Dilma Vana… ## 9 Brazil 2013 2 Dilma Vana… ## 10 Argenti… 2011 4 Cristina F… ## # … with 1,010 more rows, and 8 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Transformar variables con mutate() Transformaciones con una variable Supongamos que queremos crear una variable con el PIB en versión logarítmica: mutate(df_aprob, wdi_gdp_log = log(wdi_gdp)) ## # A tibble: 1,020 x 13 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 9 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_gdp_log &lt;dbl&gt; Podemos realizar cualquier tipo de operación en las variables. Por ejemplo, transformemos la escala de wdi_pop a millones: mutate(df_aprob, wdi_pop_mill = wdi_pop / 1000000) ## # A tibble: 1,020 x 13 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 9 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_pop_mill &lt;dbl&gt; Transformaciones con múltiples variables Crucialmente, podemos generar operaciones entre las variables. Por ejemplo, calculemos el GDP per capita: mutate(df_aprob, wdi_gdp_pc = wdi_gdp / wdi_pop) ## # A tibble: 1,020 x 13 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 9 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_gdp_pc &lt;dbl&gt; Varias transformaciones a la vez: Algo como lo siguiente funcionará: mutate(df_aprob, wdi_pop_mill = wdi_pop / 1000000, wdi_gdp_pc = wdi_gdp / wdi_pop) ## # A tibble: 1,020 x 14 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 1,010 more rows, and 10 ## # more variables: ## # net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_pop_mill &lt;dbl&gt;, ## # wdi_gdp_pc &lt;dbl&gt; (Ejercicio D) Crea un nuevo data frame, que esté ordenado desde el país-año-trimeste con menor aprobación presidencial al con mayor aprobación presidencial (recuerda crear el nuevo objeto y ponerle un buen nombre!). Tu código: En tu nuevo objeto, obtén solo con las observaciones que tengan presidentas. Tu código: Crea una nueva variable, que registre el desempleo como proporción en vez de porcentaje. Tu código: Agregar/colapsar con summarize() / hacer operaciones por grupos con group_by() Podemos hacer resúmenes para la base de datos con summarize: summarize(df_aprob, prom_desemp = mean(unemp)) ## # A tibble: 1 x 1 ## prom_desemp ## &lt;dbl&gt; ## 1 7.04 Como antes, podemos hacer varios a la vez: summarize(df_aprob, prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 1 x 3 ## prom_desemp prom_crec prom_aprob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7.04 3.77 15.3 Resúmenes agrupados Lo realmente interesante es hacer resúmenes por grupos. Primero debemos tener una versión “agrupada” de la base de datos. Esta es igual que nuestra base original, pero R sabe que las siguientes operaciones que realicemos en ella deberán ser agrupadas (veamos la ligera diferencia cuando hacemos un resumen con glimpse()) df_aprob_por_pais &lt;- group_by(df_aprob, country) glimpse(df_aprob_por_pais) ## Rows: 1,020 ## Columns: 12 ## Groups: country [17] ## $ country &lt;chr&gt; &quot;Argentina&quot;, &quot;… ## $ year &lt;dbl&gt; 2000, 2000, 20… ## $ quarter &lt;dbl&gt; 1, 2, 3, 4, 1,… ## $ president &lt;chr&gt; &quot;Fernando de l… ## $ net_approval &lt;dbl&gt; 40.126, 16.390… ## $ pres_sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;… ## $ pres_sex_d &lt;dbl&gt; 0, 0, 0, 0, 0,… ## $ exec_corr &lt;dbl&gt; 14.01525, 14.0… ## $ gdp_growth &lt;dbl&gt; -0.8, -0.8, -0… ## $ unemp &lt;dbl&gt; 15.0, 15.0, 15… ## $ wdi_gdp &lt;dbl&gt; 552151219031, … ## $ wdi_pop &lt;dbl&gt; 37057452, 3705… Hagamos una operación de resumen en esta nueva base: summarize(df_aprob_por_pais, prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 17 x 4 ## country prom_desemp prom_crec ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 11.0 2.72 ## 2 Bolivia 3.70 4.24 ## 3 Brazil 8.35 3.4 ## 4 Chile 8.18 4.33 ## 5 Colombia 12.5 4.35 ## 6 Costa Rica 6.73 4.15 ## 7 Ecuador 6.76 4.31 ## 8 El Salvador 5.75 1.87 ## 9 Guatemala 2.80 3.47 ## 10 Honduras 4.22 4.08 ## 11 Mexico 3.99 2.10 ## 12 Nicaragua 6.78 3.73 ## 13 Panama 8.45 6.31 ## 14 Paraguay 5.69 3.66 ## 15 Peru 4.32 5.30 ## 16 Uruguay 10.3 3.08 ## 17 Venezuela 10.3 3.04 ## # … with 1 more variable: ## # prom_aprob &lt;dbl&gt; Hacer cadenas de operaciones con las pipes (%&gt;%) La mayor parte del tiempo queremos hacer más de una operación en una base de datos. Por ejemplo, podríamos querer (1) crear una nueva variable con PIB per capita, y luego (2) filtrar las observaciones con valores iguales o mayores a la media de PIB per capita en toda la base: df_aprob_con_pib_pc &lt;- mutate(df_aprob, pib_pc = wdi_gdp / wdi_pop) filter(df_aprob_con_pib_pc, pib_pc &gt; mean(pib_pc)) ## # A tibble: 492 x 13 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 482 more rows, and 9 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # pib_pc &lt;dbl&gt; Esta misma cadena de operaciones se puede escribir de la siguiente forma: df_aprob %&gt;% mutate(pib_pc = wdi_gdp / wdi_pop) %&gt;% filter(pib_pc &gt; mean(pib_pc)) ## # A tibble: 492 x 13 ## country year quarter president ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argenti… 2000 1 Fernando d… ## 2 Argenti… 2000 2 Fernando d… ## 3 Argenti… 2000 3 Fernando d… ## 4 Argenti… 2000 4 Fernando d… ## 5 Argenti… 2001 1 Fernando d… ## 6 Argenti… 2001 2 Fernando d… ## 7 Argenti… 2001 3 Fernando d… ## 8 Argenti… 2001 4 Fernando d… ## 9 Argenti… 2002 1 Eduardo Al… ## 10 Argenti… 2002 2 Eduardo Al… ## # … with 482 more rows, and 9 more ## # variables: net_approval &lt;dbl&gt;, ## # pres_sex &lt;chr&gt;, ## # pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, ## # gdp_growth &lt;dbl&gt;, unemp &lt;dbl&gt;, ## # wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # pib_pc &lt;dbl&gt; ¡Este código es sorprendemente legible! Las pipes (%&gt;%) se leen como “luego” (o “pero luego”) y se insertan con Ctrl/Cmd + Shift + M en RStudio. Pueden ver todos los atajos de teclado en Help &gt; Keyboard Shortcuts Help. Uno de los usos más comunes de las pipes es el combo group_by() + summarize(). Repitamos nuestras operaciones de antes para hacer un resumen agrupado: df_aprob %&gt;% group_by(country) %&gt;% summarize(prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 17 x 4 ## country prom_desemp prom_crec ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 11.0 2.72 ## 2 Bolivia 3.70 4.24 ## 3 Brazil 8.35 3.4 ## 4 Chile 8.18 4.33 ## 5 Colombia 12.5 4.35 ## 6 Costa Rica 6.73 4.15 ## 7 Ecuador 6.76 4.31 ## 8 El Salvador 5.75 1.87 ## 9 Guatemala 2.80 3.47 ## 10 Honduras 4.22 4.08 ## 11 Mexico 3.99 2.10 ## 12 Nicaragua 6.78 3.73 ## 13 Panama 8.45 6.31 ## 14 Paraguay 5.69 3.66 ## 15 Peru 4.32 5.30 ## 16 Uruguay 10.3 3.08 ## 17 Venezuela 10.3 3.04 ## # … with 1 more variable: ## # prom_aprob &lt;dbl&gt; (Ejercicios E-G) E. Calcula, ayudándote de las pipes, la mediana por país de corrupción ejecutiva y PIB. Recuerda que puedes insertar chunks con Ctrl/Cmd + Alt + i y pipes con Ctrl/Cmd + Shift + M. Tu código: F. De nuevo usando pipes, ordena los países en la base desde el que tuvo el mayor PIB per cápita promedio en el período 2010-2014 hasta el que tuvo el menor. Tu código: G. ¿Qué país-año-trimestre, entre los gobernados por mujeres, tuvo la corrupción ejecutiva más alta? ¿Y la aprobación neta más alta? "],["manejo-02b.html", "02B - Manejo de datos (ejercicio) Contexto", " 02B - Manejo de datos (ejercicio) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica en el script 02A. Recomiendo reiniciar R antes de comenzar: Session &gt; Restart R y click en la escoba del panel de “Environment” (superior derecho). Contexto La base de datos de este ejercicio guarda relación con la política monetaria ante la Gran Depresión. En especial, trata sobre la crisis en Mississippi, donde la administración central de los bancos estaba en manos de Bancos Centrales con distintas políticas: “el Banco Central de Atlanta, encargado del Distrito 6, estuvo a favor de prestarle dinero a los bancos en problemas. En cambio, el Banco Central de St. Louis se encargó del Distrito 8 de acuerdo a la Doctrica de las Letras Reales’, que sostiene que los Bancos Centrales deben restringir el crédito durante una recesión económica” (Angrist &amp; Pischke, 2014, cap. 5) ¿Qué política monetaria fue más efectiva para combatir la crisis desde la perspectiva financiera? Podemos analizar cuántos bancos quebraron a cada lado de la política para entender mejor esto. A. Comienza cargando el tidyverse y la base de datos, que se encuentra en la carpeta “datos” (recuerda ponerle un buen nombre). El nombre del archivo es “banks2.csv”. Tu código: B. Analiza la base. ¿Qué información tiene? ¿Cuál es la unidad de análisis? Considera que “bib” significa “banks in business”. Tu respuesta: C. Obtén solo las observaciones del primero de julio de cada año. Esto nos permitirá analizar patrones anuales. Crea una nueva base de datos con esta nueva unidad de análisis. Tu código: D. Revisa el archivo de ayuda de la función diff(). Para cada zona de Banco Central, ¿cuál es la diferencia de bancos en operación al comparar 1929 con 1934? Tu código: E. Repite el ejercicio anterior, pero calculando la diferencia en términos proporcionales. Tu código: F. ¿En qué mes del año (enero, febrero, etc.) fueron más pronunciados los cierres de bancos, en promedio? "],["manejo-02c.html", "02C - Manejo de datos (extras) Cargar y guardar bases de datos Versiones iterativas de summarize() y mutate()", " 02C - Manejo de datos (extras) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica en el script 02A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). Ahora carguemos los paquetes que usaremos: library(tidyverse) library(readxl) # leer datos de Excel ## install.packages(c(&quot;janitor&quot;, &quot;writexl&quot;)) library(janitor) # limpiar bases library(writexl) # guardar bases de Excel Cargar y guardar bases de datos Cargar desde múltiples formatos Hay múltiples formatos en los podemos encontrar bases de datos tabulares. Por suerte, la consistencia del tidyverse nos permite usar funciones muy similares para trabajar con ellas en R (Araya y Cruz, 2019). Extensión Descripción Función .csv Archivo delimitado por comas read_csv() .dta Stata (suele incluir etiquetas) haven::read_stata() .Rdata R (puede tener múltiples objetos) load() .rds R (un solo objeto) read_rds() .sav SPSS (suele incluir etiquetas) haven::read_spss() .xlsx Excel 2007- writexl::read_excel() Limpiar nombres de columnas En esta ocasión cargaremos unos datos en formato Excel. Es muy común encontrar datos que tienen este tipo de extensión, y en general no vienen demasiado limpios (el trabajo con planillas no necesariamente se hace pensando en el procesamiento con código). Inspeccionémoslos visualmente. Son datos de casos policiales en 2016 para 340 comunas de Chile, recolectados desde la Subsecretaría de Prevención del Delito (2017). Habiendo cargando el paquete readxl antes, la sintaxis para cargar los datos será familiar: df_casos_policiales &lt;- read_excel(&quot;datos/casos_delitos_por_comuna.xlsx&quot;) glimpse(df_casos_policiales) ## Rows: 340 ## Columns: 17 ## $ Comuna &lt;chr&gt; … ## $ `Comuna ID` &lt;dbl&gt; … ## $ `Región ID` &lt;dbl&gt; … ## $ `Población (INE 2017)` &lt;dbl&gt; … ## $ `Robos con violencia o intimidación` &lt;dbl&gt; … ## $ `Robos por sorpresa` &lt;dbl&gt; … ## $ `Robos de vehículo motorizado` &lt;dbl&gt; … ## $ `Robos de objeto de o desde vehículo` &lt;dbl&gt; … ## $ `Robos en lugar habitado` &lt;dbl&gt; … ## $ `Robos en lugar no habitado` &lt;dbl&gt; … ## $ `Otros robos con fuerza` &lt;dbl&gt; … ## $ Hurtos &lt;dbl&gt; … ## $ `Lesiones menos graves, graves o gravísimas` &lt;dbl&gt; … ## $ `Lesiones leves` &lt;dbl&gt; … ## $ Homicidios &lt;dbl&gt; … ## $ Violaciones &lt;dbl&gt; … ## $ VIF &lt;dbl&gt; … Los nombres de las columnas en la base tienen mayúsculas, espacios y tildes, lo que nos puede generar problemas en el análisis. La convención en el tidyverse es nombrar utilizando snake_case (nombre_de_mi_objeto), sin mayúsculas, espacios ni tildes. Esto nos ahorrará muchos problemas. Si ya tenemos una base de datos y queremos estandarizar sus variables, el paquete janitor provee la función clean_names() para esto: df_casos_policiales_l &lt;- df_casos_policiales %&gt;% clean_names() glimpse(df_casos_policiales_l) ## Rows: 340 ## Columns: 17 ## $ comuna &lt;chr&gt; … ## $ comuna_id &lt;dbl&gt; … ## $ region_id &lt;dbl&gt; … ## $ poblacion_ine_2017 &lt;dbl&gt; … ## $ robos_con_violencia_o_intimidacion &lt;dbl&gt; … ## $ robos_por_sorpresa &lt;dbl&gt; … ## $ robos_de_vehiculo_motorizado &lt;dbl&gt; … ## $ robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt; … ## $ robos_en_lugar_habitado &lt;dbl&gt; … ## $ robos_en_lugar_no_habitado &lt;dbl&gt; … ## $ otros_robos_con_fuerza &lt;dbl&gt; … ## $ hurtos &lt;dbl&gt; … ## $ lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt; … ## $ lesiones_leves &lt;dbl&gt; … ## $ homicidios &lt;dbl&gt; … ## $ violaciones &lt;dbl&gt; … ## $ vif &lt;dbl&gt; … (Ejercicios A-B) A. ¿Cuál fue la comuna con más homicidios en Chile en el año 2016? Tu código: B. ¿Cuál fue la comuna con más casos de violencia intrafamiliar por cada 1000 habitantes? Tu código: Crear bases de datos “a mano” A veces queremos crear un data frame arbitrariamente a partir de vectores. Para esto, la funcióm tibble() es simple y útil: df_ejemplo &lt;- tibble( x = c(1:10), y = c(9, 10, 1:8) ) df_ejemplo ## # A tibble: 10 x 2 ## x y ## &lt;int&gt; &lt;dbl&gt; ## 1 1 9 ## 2 2 10 ## 3 3 1 ## 4 4 2 ## 5 5 3 ## 6 6 4 ## 7 7 5 ## 8 8 6 ## 9 9 7 ## 10 10 8 Guardar bases de datos Guardar una base de datos es necesario para compartirla con colegas o usarla en otros proyectos. La mayoría de las funciones que vimos, que comienzan con read_, tienen su versión write_ para este propósito. Por ejemplo, read_csv() -&gt; write_csv(). El único par de comandos en los que hay algo distinto es readxl::read_excel() -&gt; writexl::write_xlsx(). En general, los mejores formatos para guardar bases son .csv (muy universal) y .rds (nos aseguramos de que cualquier cosa extraña en nuestros datos pueda volver bien a R). Guardemos los datos en formatos .csv, .rds y .xlsx (Excel). Recuerda que ya cargamos antes el paquete writexl, que nos permite hacer esto último. write_csv(df_ejemplo, &quot;datos/df_ejemplo.csv&quot;) write_csv(df_ejemplo, &quot;datos/df_ejemplo.rds&quot;) write_xlsx(df_ejemplo, &quot;datos/df_ejemplo.xlsx&quot;) Podríamos volver a cargarlo con read_excel(): df_ejemplo_comprob &lt;- read_excel(&quot;datos/df_ejemplo.xlsx&quot;) df_ejemplo_comprob ## # A tibble: 10 x 2 ## x y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 9 ## 2 2 10 ## 3 3 1 ## 4 4 2 ## 5 5 3 ## 6 6 4 ## 7 7 5 ## 8 8 6 ## 9 9 7 ## 10 10 8 (Ejercicio) Guarda una versión de la base de datos de delitos, en formato csv. Utiliza la versión con los nombres de columnas limpios y excluye la variable de región. Tu código: Versiones iterativas de summarize() y mutate() Es común necesitar hacer una misma operación en múltiples columnas de una base. Por ejemplo, podríamos querer los totales de delitos específicos por región, como muestra el siguiente chunk. df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize(lesiones_leves_total = sum(lesiones_leves), hurtos_total = sum(hurtos)) ## # A tibble: 16 x 3 ## region_id lesiones_leves_total ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1523 ## 2 2 3014 ## 3 3 1253 ## 4 4 2830 ## 5 5 6955 ## 6 6 3347 ## 7 7 2368 ## 8 8 4549 ## 9 9 3227 ## 10 10 2824 ## 11 11 486 ## 12 12 525 ## 13 13 22796 ## 14 14 1269 ## 15 15 733 ## 16 16 1250 ## # … with 1 more variable: ## # hurtos_total &lt;dbl&gt; Sin embargo, hacer este código para los 13 tipos de delito es una pérdida de tiempo: generaría código particularmente difícil de leer. Podemos aplicar la función summarize_at() para usar la función de suma en múltiples variables. Noten cómo en el código siguiente “.” reemplazará a la variable en la definición de la operación (gracias al operador “~”). df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = ~sum(.)) ## # A tibble: 16 x 14 ## region_id robos_con_violencia_o_i… ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 ## 2 2 1930 ## 3 3 832 ## 4 4 1667 ## 5 5 5777 ## 6 6 1629 ## 7 7 1108 ## 8 8 4646 ## 9 9 1547 ## 10 10 1025 ## 11 11 71 ## 12 12 112 ## 13 13 41541 ## 14 14 424 ## 15 15 618 ## 16 16 605 ## # … with 12 more variables: ## # robos_por_sorpresa &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt;, ## # robos_en_lugar_habitado &lt;dbl&gt;, ## # robos_en_lugar_no_habitado &lt;dbl&gt;, ## # otros_robos_con_fuerza &lt;dbl&gt;, ## # hurtos &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt;, ## # lesiones_leves &lt;dbl&gt;, ## # homicidios &lt;dbl&gt;, ## # violaciones &lt;dbl&gt;, vif &lt;dbl&gt; Incluso podemos editar un poco los nombres de los resúmenes, asignándolos como elementos en una lista. Noten cómo van a cambiar dichos nombres, terminando ahora en \"_total\": df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(total = ~sum(.))) ## # A tibble: 16 x 14 ## region_id robos_con_violencia_o_i… ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 ## 2 2 1930 ## 3 3 832 ## 4 4 1667 ## 5 5 5777 ## 6 6 1629 ## 7 7 1108 ## 8 8 4646 ## 9 9 1547 ## 10 10 1025 ## 11 11 71 ## 12 12 112 ## 13 13 41541 ## 14 14 424 ## 15 15 618 ## 16 16 605 ## # … with 12 more variables: ## # robos_por_sorpresa_total &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_total &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_total &lt;dbl&gt;, ## # robos_en_lugar_habitado_total &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_total &lt;dbl&gt;, ## # otros_robos_con_fuerza_total &lt;dbl&gt;, ## # hurtos_total &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_total &lt;dbl&gt;, ## # lesiones_leves_total &lt;dbl&gt;, ## # homicidios_total &lt;dbl&gt;, ## # violaciones_total &lt;dbl&gt;, ## # vif_total &lt;dbl&gt; También podemos utilizar más de una función de resumen a la vez en nuestros datos: df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(total = ~sum(.), max = ~max(.))) ## # A tibble: 16 x 27 ## region_id robos_con_violencia_o_i… ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 ## 2 2 1930 ## 3 3 832 ## 4 4 1667 ## 5 5 5777 ## 6 6 1629 ## 7 7 1108 ## 8 8 4646 ## 9 9 1547 ## 10 10 1025 ## 11 11 71 ## 12 12 112 ## 13 13 41541 ## 14 14 424 ## 15 15 618 ## 16 16 605 ## # … with 25 more variables: ## # robos_por_sorpresa_total &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_total &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_total &lt;dbl&gt;, ## # robos_en_lugar_habitado_total &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_total &lt;dbl&gt;, ## # otros_robos_con_fuerza_total &lt;dbl&gt;, ## # hurtos_total &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_total &lt;dbl&gt;, ## # lesiones_leves_total &lt;dbl&gt;, ## # homicidios_total &lt;dbl&gt;, ## # violaciones_total &lt;dbl&gt;, ## # vif_total &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion_max &lt;dbl&gt;, ## # robos_por_sorpresa_max &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_max &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_max &lt;dbl&gt;, ## # robos_en_lugar_habitado_max &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_max &lt;dbl&gt;, ## # otros_robos_con_fuerza_max &lt;dbl&gt;, ## # hurtos_max &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_max &lt;dbl&gt;, ## # lesiones_leves_max &lt;dbl&gt;, ## # homicidios_max &lt;dbl&gt;, ## # violaciones_max &lt;dbl&gt;, ## # vif_max &lt;dbl&gt; Aparte de hacer resúmenes, crear múltiples variables según una misma operación es bastante común. Supongamos que queremos las cifras relativas (tasas) para cada tipo de delito, como en el siguiente ejemplo: df_casos_policiales_l %&gt;% mutate(lesiones_leves_c1000 = lesiones_leves * 1000 / poblacion_ine_2017) %&gt;% select(comuna, poblacion_ine_2017, lesiones_leves, lesiones_leves_c1000) # solo para legibilidad ## # A tibble: 340 x 4 ## comuna poblacion_ine_2017 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Algarrobo 10700 ## 2 Alhué 5916 ## 3 Alto-Biobío 5957 ## 4 Alto-del-Carmen 6519 ## 5 Alto-Hospicio 124872 ## 6 Ancud 44249 ## 7 Andacollo 11555 ## 8 Angol 55845 ## 9 Antártica 202 ## 10 Antofagasta 389812 ## # … with 330 more rows, and 2 more ## # variables: lesiones_leves &lt;dbl&gt;, ## # lesiones_leves_c1000 &lt;dbl&gt; Podemos utilizar mutate_at() para repetir esta operación en todas nuestras variables de interés. df_casos_policiales_l %&gt;% mutate_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(c1000 = ~ . * 1000 / poblacion_ine_2017)) ## # A tibble: 340 x 30 ## comuna comuna_id region_id ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algarrobo 5602 5 ## 2 Alhué 13502 13 ## 3 Alto-Biobío 8314 8 ## 4 Alto-del-Carm… 3302 3 ## 5 Alto-Hospicio 1107 1 ## 6 Ancud 10202 10 ## 7 Andacollo 4103 4 ## 8 Angol 9201 9 ## 9 Antártica 12202 12 ## 10 Antofagasta 2101 2 ## # … with 330 more rows, and 27 more ## # variables: ## # poblacion_ine_2017 &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion &lt;dbl&gt;, ## # robos_por_sorpresa &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt;, ## # robos_en_lugar_habitado &lt;dbl&gt;, ## # robos_en_lugar_no_habitado &lt;dbl&gt;, ## # otros_robos_con_fuerza &lt;dbl&gt;, ## # hurtos &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt;, ## # lesiones_leves &lt;dbl&gt;, ## # homicidios &lt;dbl&gt;, ## # violaciones &lt;dbl&gt;, vif &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion_c1000 &lt;dbl&gt;, ## # robos_por_sorpresa_c1000 &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_c1000 &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_c1000 &lt;dbl&gt;, ## # robos_en_lugar_habitado_c1000 &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_c1000 &lt;dbl&gt;, ## # otros_robos_con_fuerza_c1000 &lt;dbl&gt;, ## # hurtos_c1000 &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_c1000 &lt;dbl&gt;, ## # lesiones_leves_c1000 &lt;dbl&gt;, ## # homicidios_c1000 &lt;dbl&gt;, ## # violaciones_c1000 &lt;dbl&gt;, ## # vif_c1000 &lt;dbl&gt; (Ejercicio C) Si queremos obtener un promedio por región en datos como estos, debemos calcular un promedio ponderado: si es que no hacemos esto, comunas con pocos habitantes estarán sobrerrepresentadas en los promedios. Un ejemplo a continuación: df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize(prom_hurtos = weighted.mean(hurtos, w = poblacion_ine_2017)) ## # A tibble: 16 x 2 ## region_id prom_hurtos ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1968. ## 2 2 3941. ## 3 3 1216. ## 4 4 1543. ## 5 5 2039. ## 6 6 1139. ## 7 7 1305. ## 8 8 1304. ## 9 9 1608. ## 10 10 1826. ## 11 11 513. ## 12 12 990. ## 13 13 2329. ## 14 14 1064. ## 15 15 1711. ## 16 16 938. Para cada tipo de delito, obtén el promedio ponderado por región. Tu código: "],["manejo-02d.html", "02D - Manejo de datos (ejercicio int.)", " 02D - Manejo de datos (ejercicio int.) Este ejercicio interactivo solo se puede ejecutar en RStudio Cloud. Si quieres correrlo localmente, debe haber descargado el proyecto, como se explica en el script 02A. "],["visualizacion.html", "03A - Visualización de datos (intro) Inicio: cargar paquetes, base de datos Gráficos univariados Gráficos bivariados Un poco de personalización: etiquetas", " 03A - Visualización de datos (intro) Diapositivas de visualización de datos Si quieres correr estos scripts localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (3A, 3B, 3C): tidyverse. Ilustración de Allison Horst. Inicio: cargar paquetes, base de datos library(tidyverse) Carga de base en formato rds Hoy tenemos una base de datos con información de los municipios, construida a partir de dos fuentes: la encuesta Casen 2017 y los resultados de las elecciones municipales del año 2016. df_municipios &lt;- read_rds(&quot;datos/datos_municipios.rds&quot;) ¿Te queda claro la información que registra cada variable? Si es que no, haz tus apuntes aquí: Gráficos univariados Gráfico univariado para variable categórica (barras) Veamos la distribución de las coaliciones de los alcaldes en las comunas: ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion)) + geom_bar() Si queremos invertir los ejes, podemos usar el mapeo estético y = en vez de x =: ggplot(data = df_municipios, mapping = aes(y = alcalde_coalicion)) + geom_bar() Gráfico univariado para variable continua (histograma) Veamos la distribución del % de población rural en las comunas: ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram() ## `stat_bin()` using `bins = 30`. ## Pick better value with `binwidth`. Podemos controlar cómo se arma el histograma en los argumentos de geom_histogram(): bindwidth = 5 hace que nuestros bins tengan un ancho de 5. boundary = 0 asegura que los bins partan en 0, en vez de intentar centrarse en los números enteros (el defecto). closed = \"left\" ayuda a ggplot2 a decidir qué hacer con los valores que caen exactamente en los límites del bin. El valor “left” determina que los bins están cerrados a la izquierda, es decir, un valor intermedio caerá en la barra de la derecha. El valor “right”, el defecto, dirá que los bins están cerrados a la derecha, es decir, un valor intermedio caerá en la barra de la izquierda. ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram(binwidth = 5, boundary = 0, closed = &quot;left&quot;) (Ejercicio A) Genera un gráfico univariado para alguna de la variables de la base de datos. ¿Hay algún patrón interesante? Tu código (recuerda, los chunks se insertan con Ctrl/Cmd+Shift+i): Gráficos bivariados Gráfico bivariado para dos variables continuas (dispersión) Observemos la relación entre la variable de población mapuche en la comuna y su índice de pobreza multidimensional: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4)) + geom_point(size = 2) Podemos añadir color y forma a los puntos según las coaliciones de los alcaldes: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4, color = alcalde_coalicion, shape = alcalde_coalicion)) + geom_point(size = 2) Gráfico bivariado para x discreta + y continua: boxplot/violin Veamos la relación entre la coalición del edil y la pobreza de la comuna: ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion, y = porc_pobres_md4)) + geom_boxplot() ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion, y = porc_pobres_md4)) + geom_violin() Gráfico bivariado para x discreta + y continua: columnas (ránking) ggplot(data = df_municipios %&gt;% group_by(alcalde_coalicion) %&gt;% summarize(porc_alcaldes_reelectos = sum(alcalde_reelecto) / n()), mapping = aes(x = alcalde_coalicion, y = porc_alcaldes_reelectos)) + geom_col() A veces queremos hacer estos gráficos de forma horizontal (“gráfico de ránking”). Podemos hacer un cambio similar al anterior, con los mapeos estéticos invertidos. Luego aprenderemos a ordenar las barras, para hacer ránkings. ggplot(data = df_municipios %&gt;% group_by(alcalde_coalicion) %&gt;% summarize(porc_alcaldes_reelectos = sum(alcalde_reelecto) / n()), mapping = aes(x = porc_alcaldes_reelectos, y = alcalde_coalicion)) + geom_col() Un poco de personalización: etiquetas Volvamos a uno de los gráficos que hicimos antes: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4, color = alcalde_coalicion, shape = alcalde_coalicion)) + geom_point(size = 2) Con el comando labs() dentro de la cadena de ggplot2 podemos poner etiquetas que harán al gráfico más legible: ggplot(data = df_municipios, mapping = aes(x = porc_mapuche, y = porc_pobres_md4, color = alcalde_coalicion, shape = alcalde_coalicion)) + geom_point(size = 2) + labs(title = &quot;Relación entre porcentaje de población mapuche y porcentaje de pobreza&quot;, subtitle = &quot;por comunas, año 2017&quot;, caption = &quot;Fuente: Casen (2017).&quot;, # ahora para los mapeos estéticos: x = &quot;% de población mapuche&quot;, y = &quot;% de población pobreza (multidimensional)&quot;, color = &quot;Coalición del(la) edil&quot;, shape = &quot;Coalición del(la) edil&quot;) (Ejercicios B-D) ¡En todos los ejercicios genera buenas etiquetas para tus gráficos, utilizando labs()! Genera un plot de violín para la relación entre una variable x discreta y una variable y continua en la base. Tu código: Genera un gráfico de dispersión entre dos variables continuas de la base. Cambia el color y/o forma de los puntos de acuerdo a una de las variables categóricas de la base (si es que vas a utilizar una variable dummy para esto, ingrésala como as.factor(variable) en el mapeo estético). Ayudándote del torpedo para hoy, genera dos gráficos que incluya geoms que no hayamos visto hasta ahora. d1. Tu código: d2. Tu código: "],["visualizacion-ext.html", "03B - Visualización de datos (extensiones) Cargar paquetes y datos Gráfico de ránking Facetas Gráficos de líneas Más personalización", " 03B - Visualización de datos (extensiones) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica al comienzo del script 03A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). Cargar paquetes y datos library(tidyverse) df_municipios &lt;- read_rds(&quot;datos/datos_municipios.rds&quot;) Gráfico de ránking Supongamos que queremos rankear a las comunas según su edad promedio. Podríamos hacer un gráfico de columnas: ggplot(data = df_municipios, mapping = aes(x = edad_prom, y = comuna)) + geom_col() (Al menos) dos cosas están mal con el gráfico anterior. Primero, son demasiadas observaciones. Segundo, las barras no están ordenadas. Podemos suplir ambas cosas y crear un gráfico de “ránking” que se entienda: ggplot(data = df_municipios %&gt;% arrange(-edad_prom) %&gt;% # ordenamos slice(1:10), # seleccionamos las diez primeras mapping = aes(x = edad_prom, y = fct_reorder(comuna, edad_prom))) + # ordenamos geom_col() Ejercicio A Genera un gráfico de ránking para las diez comunas con mayor población de la muestra. Facetas ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() ## `stat_bin()` using `bins = 30`. ## Pick better value with `binwidth`. ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() + facet_wrap(~alcalde_coalicion) ## `stat_bin()` using `bins = 30`. ## Pick better value with `binwidth`. ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() + facet_wrap(~alcalde_coalicion, nrow = 3) ## `stat_bin()` using `bins = 30`. ## Pick better value with `binwidth`. Noten que los gráficos anteriores, por defecto, las facetas comparten escalas para las variables x e y. Podemos cambiar este default con el argumento scales = \"free\", que también puede tomar los valores “free_x” o “free_y”. Qué queremos usar aquí dependerá de la naturaleza de nuestros datos, caso a caso… ggplot(data = df_municipios, mapping = aes(x = porc_pobres_md4)) + geom_histogram() + facet_wrap(~alcalde_coalicion, scales = &quot;free&quot;) ## `stat_bin()` using `bins = 30`. ## Pick better value with `binwidth`. Ejercicio B Genera un gráfico de dispersión (con geom_point()) para dos variables de la base. Luego divídelo por facetas según la coalición del(la) edil. Gráficos de líneas Vamos a cargar datos desde Gapminder (2010), compilados por Edgar Ruiz, Riva Quiroga y Mauricio ‘Pacha’ Vargas: gapminder_muestra &lt;- read_csv(&quot;datos/gapminder_muestra_es.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## pais = col_character(), ## anio = col_double(), ## esperanza_de_vida = col_double() ## ) Podríamos querer graficar las tendencias en el tiempo para los tres países. Con las herramientas que hemos visto ahora ahora, podríamos hacer algo como lo siguiente: ggplot(data = gapminder_muestra, mapping = aes(x = anio, y = esperanza_de_vida, color = pais)) + geom_point() Esto es difícil de leer, nos vendría bien tener líneas para seguir los patrones en el tiempo. Podemos hacer esto añadiendo geom_line() y el mapeo estético group = (a veces podemos omitir esto, ggplot2 tratará de inferirlo, pero yo recomiendo utilizarlo explícitamente siempre). ggplot(data = gapminder_muestra, mapping = aes(x = anio, y = esperanza_de_vida, color = pais, group = pais)) + geom_point() + geom_line() Más personalización Vamos a ver cómo añadir texto dentro de los gráficos, editar las escalas (ejes y colores), etcétera, el próximo script. "],["visualizacion-personalizacion.html", "03C - Visualización de datos (personalización) Inicio: cargar paquetes, base de datos Gráfico de ejemplo Gráficos como objetos / guardar gráficos en el disco Personalización de gráficos", " 03C - Visualización de datos (personalización) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica al comienzo del script 3A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). Inicio: cargar paquetes, base de datos library(tidyverse) Cargar de datos: municipios Carguemos nuestra base de datos en formato .rds. Tiene información comunal construida a partir de dos fuentes: la encuesta Casen 2017 y los resultados de las elecciones municipales del año 2016. df_municipios &lt;- read_rds(&quot;datos/datos_municipios.rds&quot;) Gráfico de ejemplo ggplot(data = df_municipios, mapping = aes(x = as.factor(region), y = porc_pobres_md4)) + geom_boxplot() + labs(x = &quot;Región&quot;, y = &quot;% Pobreza multidimensional&quot;, title = &quot;% de pobreza en las comunas de Chile, separadas por región&quot;, caption = &quot;Fuente: Casen (2017)&quot;) Gráficos como objetos / guardar gráficos en el disco Podemos crear los gráficos como objetos en R. Hagamos esto para nuestro gráfico anterior: p_pobreza_sep_region &lt;- ggplot(data = df_municipios, mapping = aes(x = as.factor(region), y = porc_pobres_md4)) + geom_boxplot() + labs(x = &quot;Región&quot;, y = &quot;% Pobreza multidimensional&quot;, title = &quot;% de pobreza en las comunas de Chile, separadas por región&quot;, caption = &quot;Fuente: Casen (2017)&quot;) Para generarlos, los llamamos en la consola: p_pobreza_sep_region Podemos continuar con cadenas de ggplot2 a partir de objetos: p_pobreza_sep_region + geom_violin(alpha = 0.5) También podemos guardar nuestros gráficos en el disco fácilmente, si es que son objetos: ggsave(filename = &quot;p_pobreza_sep_region.png&quot;, plot = p_pobreza_sep_region) ## Saving 7 x 5 in image ¿Cómo conseguir que el gráfico tenga las proporciones que queremos? La mejor forma es modificando un poco algunos argumento de ggsave: scale edita la proporción de tamaños entre el plano y los elementos del gráfico. Valores menores a 1 harán los elementos más grandes. width edita el ancho, en pulgadas. height edita el alto, en pulgadas. Con units = \"cm\" podríamos dar ancho y alto en centímetros. [Aquí hay una guía completa sobre guardar gráficos en disco, escrita por Jenny Bryan (2018)] Casi siempre me funciona bien ocupar scale = 0.8, height = 6 y width = entre 8 y 10 (dependiendo si es un gráfico ancho o no). Hay mucho de ensayo y error aquí! ggsave(filename = &quot;p_pobreza_sep_region.png&quot;, plot = p_pobreza_sep_region, scale = 0.8, height = 6, width = 10) Personalización de gráficos Etiquetas (labs) Esto es algo que ya hemos visto, y se consigue con el comando labs(): ggplot(data = df_municipios, mapping = aes(x = alcalde_coalicion)) + geom_bar() + labs(x = &quot;Coalición del alcalde&quot;, y = &quot;Frecuencia&quot;, title = &quot;Alcaldías por coalición, luego de las elecciones 2016&quot;, caption = &quot;Fuente: Emol (2016)&quot;) Algunos argumentos de labs() funcionan en cualquier gráfico (title, subtitle, caption, etc.), mientras otros dependen de los mapeos estéticos particulares de cada gráfico (x, y, color, shape, etc.). Personalizar escalas numéricas Volvamos a nuestro histograma de antes: ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram(binwidth = 5, boundary = 0, closed = &quot;left&quot;) + labs(x = &quot;% de población rural&quot;, y = &quot;Frecuencia&quot;, title = &quot;Comunas chilenas según su porcentaje de población rural&quot;, caption = &quot;Fuente: Casen (2017)&quot;) Podemos editar arbitrariamente qué se muestra en los ejes continuos con los comandos scale_*_continuous() y el argumento breaks =: ggplot(data = df_municipios, mapping = aes(x = porc_rural)) + geom_histogram(binwidth = 5, boundary = 0, closed = &quot;left&quot;) + labs(x = &quot;% de población rural&quot;, y = &quot;Frecuencia&quot;, title = &quot;Comunas chilenas según su porcentaje de población rural&quot;, caption = &quot;Fuente: Casen (2017)&quot;) + scale_x_continuous(breaks = seq(from = 0, to = 100, by = 10)) + scale_y_continuous(breaks = seq(from = 0, to = 60, by = 10)) (Nueva base de datos) Ahora trabajaremos con una base de datos con información de carreras universitarias en Estados Unidos. Su fuente es FiveThirtyEight (2018), aunque estos datos específicos fueron editados para Tidy Tuesday. carreras_eeuu &lt;- read_csv(&quot;datos/carreras_eeuu.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## carrera_codigo = col_double(), ## carrera = col_character(), ## carrera_tipo1 = col_character(), ## carrera_tipo2 = col_character(), ## estudiantes_total = col_double(), ## estudiantes_muj = col_double(), ## estudiantes_hom = col_double(), ## salario_mediana = col_double(), ## salario_q1 = col_double(), ## salario_q3 = col_double(), ## en_part_time = col_double(), ## en_trabajos_calificados = col_double(), ## en_trabajos_no_calificados = col_double(), ## en_trabajos_sueldo_min = col_double(), ## desempleados = col_double() ## ) glimpse(carreras_eeuu) ## Rows: 171 ## Columns: 15 ## $ carrera_codigo &lt;dbl&gt; … ## $ carrera &lt;chr&gt; … ## $ carrera_tipo1 &lt;chr&gt; … ## $ carrera_tipo2 &lt;chr&gt; … ## $ estudiantes_total &lt;dbl&gt; … ## $ estudiantes_muj &lt;dbl&gt; … ## $ estudiantes_hom &lt;dbl&gt; … ## $ salario_mediana &lt;dbl&gt; … ## $ salario_q1 &lt;dbl&gt; … ## $ salario_q3 &lt;dbl&gt; … ## $ en_part_time &lt;dbl&gt; … ## $ en_trabajos_calificados &lt;dbl&gt; … ## $ en_trabajos_no_calificados &lt;dbl&gt; … ## $ en_trabajos_sueldo_min &lt;dbl&gt; … ## $ desempleados &lt;dbl&gt; … (Ejercicio A) Antes de comenzar a trabajar con los datos, crea una nueva base de datos llamada “carreras_eeuu2” que tenga tres nuevas variables: porc_mujeres, porc_desempleo, porc_en_trabajos_calificados (todas calculadas con respecto al total de cada carrera). Tu código: En el resto de la clase utilizaremos esta base modificada. Elegir buenas escalas de colores Escalas de colores categóricas Comencemos dibujando solo el plano de coordenadas, sin geoms. ¿Qué esperan ver en el siguiente gráfico, una vez que añadamos geom_point()? ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = carrera_tipo1)) Veamos el gráfico: ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = carrera_tipo1)) + geom_point() La paleta de colores categóricos por defecto de ggplot2, lamentablemente, es difícil de ver para los/as daltónicos/as. Podemos cambiarla por una de ColorBrewer con el comando scale_color_brewer(): ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = carrera_tipo1)) + geom_point() + scale_color_brewer(palette = &quot;PuOr&quot;) Escalas de colores numéricas Grafiquemos la misma relación de antes, pero esta vez añadamos color a los puntos con una variable continua (porc_mujeres): ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres)) + geom_point() De nuevo, la paleta de colores por defecto es subóptima. La mejor paleta para visualizar escalas continuas en color es “viridis”. Podemos utilizarla con el comando scale_color_viridis_c(): ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres)) + geom_point() + scale_color_viridis_c() # de la escala (Ejercicio B) Genera un gráfico de dispersión para dos variables numéricas en la base de datos. Añade color a las observaciones de acuerdo al tipo de carrera (amplio). Utiliza una escala de ColorBrewer distinta a la de antes. Recuerda utilizar buenos labs (etiquetas). Tu código: Texto dentro del gráfico Para el último gráfico que hicimos, nos puede interesar ver la posición de carreras específicas. Podemos generar esto añadiendo texto dentro del gráfico: ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres, label = carrera)) + geom_point() + geom_label() + # esto genera los textos, ojo que necesita el mapeo de &quot;label&quot; antes! scale_color_viridis_c() Esto último es inútil, pues no se entiende nada. Podemos destacar solo una carrera si construimos geom_label() usando datos parciales. Coloquemos solo el texto para ciencia política: ggplot(data = carreras_eeuu2, mapping = aes(x = porc_desempleo, y = porc_en_trabajos_calificados, color = porc_mujeres, label = carrera)) + geom_point() + geom_label(data = carreras_eeuu2 %&gt;% filter(carrera == &quot;Ciencia Política&quot;), alpha = 0.7) + scale_color_viridis_c() Texto dentro de gráficos de columna Calculemos la mediana de porcentaje de desempleo por tipo (amplio) de carrera: ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(median_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = median_porc_desempleo)) + geom_col() Para añadir cajas de texto con los valores numéricos al gráfico, de nuevo podemos utilizar geom_label(), luego de haber indicado el mapeo estético para “label”: ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(median_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = median_porc_desempleo, label = median_porc_desempleo)) + geom_col() + geom_label() Un tip: podemos redondear los números utilizando round() en el mapeo de label: ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(median_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = median_porc_desempleo, label = round(median_porc_desempleo, 2))) + geom_col() + geom_label() Por cierto, aparte de geom_label() está geom_text(), que no dibuja una caja alrededor del texto. ggplot(data = carreras_eeuu2 %&gt;% group_by(carrera_tipo1) %&gt;% summarize(mediana_porc_desempleo = median(porc_desempleo)), mapping = aes(x = carrera_tipo1, y = mediana_porc_desempleo, label = round(mediana_porc_desempleo, 2))) + geom_col() + geom_text(vjust = -0.4) # solo esto cambió. vjust cambia ligeramente la posición del texto (Ejercicio D) Genera un gráfico de tipo “ránking” con la diez carreras con mayor salario mediano. Registra con texto los valores de salarios medianos. ¡Utiliza buenos labs (etiquetas)! "],["busqueda-ayuda.html", "04 - Guía búsqueda de ayuda Leer archivos de ayuda de R Encontrar funciones en línea Solucionar problemas Pedir ayuda con ejemplos reproducibles (reprex)", " 04 - Guía búsqueda de ayuda En esta guía vamos a revisar algunos tips y recursos para buscar ayuda efectivamente, en el contexto de proyectos de análisis de datos. Leer archivos de ayuda de R Todas las funciones en R tienen un archivo de ayuda asociado. Podemos acceder a estos simplemente antecediendo el nombre de la función con un signo de interrogación: ?mean ?`%&gt;%` # con estos tildes invertidos podemos ingresar funciones que tengan caracteres especiales ?`%in%` Podemos leer un archivo de ayuda de R de la siguiente forma: Figure 1: Traducido de Healy (2018). Encontrar funciones en línea CRAN packages CRAN es el sitio de los repositorios oficiales de R. La página web es un poco confusa, pero usualmente encontramos los paquetes que queremos buscando en Google cran &lt;paquete&gt;. Por ejemplo, este es el sitio para el paquete dplyr. Contiene información útil sobre el paquete. Tres campos muy importantes a mirar son (a) “URL”, que nos lleva al sitio oficial del paquete, usualmente en la página del autor/a, (B) “Vignettes”, que son pequeñas guías oficiales de cómo usarlo y (C) “Reference manual”, un manual con todos los archivos de ayuda de sus funciones. rdrr.io En este sitio podemos buscar funciones y mirar sus archivos de ayuda en línea. Su buscador integrado no es particularmente bueno, así que recomiendo usar Google. Así llegaremos a esta página, por ejemplo: “mutate rdrr”. CRAN Task Views CRAN Task Views son guías muy completas sobre qué paquetes nos pueden ayudar a lidiar con tópicos específicos. Por ejemplo, veamos el CTV de “Estadística para las Ciencias Sociales”. Solucionar problemas Problemas con paréntesis y comas Vamos a usar una base de ejemplo de ggplot2, llamada midwest. Contiene información demográfica sobre distintos condados en Estados Unidos, parte de la zona geográfica llamada “Midwest”. midwest ## # A tibble: 437 x 28 ## PID county state area poptotal ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 561 ADAMS IL 0.052 66090 ## 2 562 ALEXAN… IL 0.014 10626 ## 3 563 BOND IL 0.022 14991 ## 4 564 BOONE IL 0.017 30806 ## 5 565 BROWN IL 0.018 5836 ## 6 566 BUREAU IL 0.05 35688 ## 7 567 CALHOUN IL 0.017 5322 ## 8 568 CARROLL IL 0.027 16805 ## 9 569 CASS IL 0.024 13437 ## 10 570 CHAMPA… IL 0.058 173025 ## # … with 427 more rows, and 23 more ## # variables: popdensity &lt;dbl&gt;, ## # popwhite &lt;int&gt;, popblack &lt;int&gt;, ## # popamerindian &lt;int&gt;, ## # popasian &lt;int&gt;, popother &lt;int&gt;, ## # percwhite &lt;dbl&gt;, ## # percblack &lt;dbl&gt;, ## # percamerindan &lt;dbl&gt;, ## # percasian &lt;dbl&gt;, ## # percother &lt;dbl&gt;, ## # popadults &lt;int&gt;, perchsd &lt;dbl&gt;, ## # percollege &lt;dbl&gt;, ## # percprof &lt;dbl&gt;, ## # poppovertyknown &lt;int&gt;, ## # percpovertyknown &lt;dbl&gt;, ## # percbelowpoverty &lt;dbl&gt;, ## # percchildbelowpovert &lt;dbl&gt;, ## # percadultpoverty &lt;dbl&gt;, ## # percelderlypoverty &lt;dbl&gt;, ## # inmetro &lt;int&gt;, category &lt;chr&gt; Generemos un gráfico con ella: ggplot(data = midwest, mapping = aes(x = as.factor(inmetro), y = percbelowpoverty)) + geom_boxplot() + labs(title = &quot;Relación entre carácter metropolitano y pobreza en los condados del Midwest&quot;, caption = &quot;Fuente: Wickham (2018)&quot;, x = &quot;Carácter metropolitano&quot;, y = &quot;Porcentaje de pobreza&quot;) La gran mayoría de los errores que se cometen en R tienen que ver con sintaxis. Como hemos visto, R (como cualquier lenguaje de programación) espera instrucciones muy precisas de nuestra parte. Aquí algunos tips para detectar problemas de este tipo: Revisar dónde abren/cierran paréntesis sospechosos. Si ponemos el teclado al lado de uno de ellos, RStudio resaltará el paréntesis par a este: Con respecto a las comas, debemos recordar que se utilizan para separar argumentos de funciones, por lo que siempre deben estar adentro de ellas. Fíjate en los argumentos de la función labs() en el código de arriba. Otro error de sintaxis es dejar cadenas de código (%&gt;% o +) abiertas. Esto es, dejar un pipe o “+” extra al final. R seguirá esperando la continuación de la cadena! Un truco para ver dónde está fallando nuestro código es “ponerle sangría” línea a línea. Si tenemos un código desordenado, podemos ir ordenándolo línea a línea con Ctrl + I. Probablemente esto nos dé una mejor perspectiva para encontrar errores de comas, pipes, etc: Leer los mensajes de error de R Veamos el siguiente error, cuando intentamos multiplicar una variable categórica: midwest %&gt;% filter(county == &quot;IL&quot;) %&gt;% mutate(county5 = county * 5) ## Error: Problem with `mutate()` column `county5`. ## ℹ `county5 = county * 5`. ## x non-numeric argument to binary operator El mensaje nos menciona que el error sucedió en mutate(), lo que ya es útil. Luego, el concepto de “non-numeric” nos da una idea de lo que puede estar pasando. Buscar en internet A veces entendemos el mensaje de error y sabemos cómo solucionarlo. Pero a menudo una buena idea es buscar el error en Google (la mayoría de los errores ya han sido preguntados en línea), acompañado de la función y/o paquete. Para hacer estas búsquedas eficientemente, deberíamos eliminar cualquier información del error que sea específica de nuestra base de datos (“generalizándolo”). Por ejemplo, una buena búsqueda para el error anterior podría ser la siguiente. r dplyr mutate non-numeric argument to binary operator En Google podemos poner una palabra o frase entre comillas para que los resultados deban necesariamente contenerla tal como está escrita. Podríamos buscar algo como esto: r dplyr mutate “non-numeric argument to binary operator” Por lejos, los mejores resultados vienen de StackOverflow, un sitio web de preguntas y respuestas de programación. En Google a menudo querrán clickear en “Más resultados de stackoverflow.com”, si es que no encuentran la solución en los primeros resultados. Podemos hacer nuestra búsqueda anterior directamente en StackOverflow a través de Google, de la siguiente forma: site:stackoverflow.com r dplyr mutate “non-numeric argument to binary operator” Pedir ayuda con ejemplos reproducibles (reprex) Cuando tenemos un problema y queremos compartirlo con alguien (colegas, StackOverflow, etc.), lo ideal es que generemos un ejemplo mínimo que reproduzca nuestro problema (reprex). La idea es que la otra persona no tenga que lidiar con todo nuestro código, sino que solo con la parte que nos está dando problemas. Adicionalmente, no queremos que esa otra persona tenga que entender nuestra base de datos en particular, por lo que los reprex usualmente están hechos con bases de datos pequeñas creadas o con bases de datos que vienen por defecto con R o el tidyverse (mtcars, midwest, mpg, diamonds, etc.). Por último, queremos que esa otra persona pueda correr rápidamente nuestro código, sin tener que preocuparse de nada más aparte de nuestro problema. Nuestro problema de antes: midwest %&gt;% filter(county == &quot;IL&quot;) %&gt;% mutate(county5 = county * 5) ## Error: Problem with `mutate()` column `county5`. ## ℹ `county5 = county * 5`. ## x non-numeric argument to binary operator Utilizar la base “midwest” está bien, pero vamos a generar nuestro reprex con otra de ejemplo en el paquete ggplot2, llamada mpg. Esta base se ve de la siguiente forma. No importa mucho su contenido, pero sí que tenemos una variable categórica para usar. En este caso, “model” nos servirá. ## # A tibble: 234 x 11 ## manufacturer model displ year ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 audi a4 1.8 1999 ## 2 audi a4 1.8 1999 ## 3 audi a4 2 2008 ## 4 audi a4 2 2008 ## 5 audi a4 2.8 1999 ## 6 audi a4 2.8 1999 ## 7 audi a4 3.1 2008 ## 8 audi a4 quatt… 1.8 1999 ## 9 audi a4 quatt… 1.8 1999 ## 10 audi a4 quatt… 2 2008 ## # … with 224 more rows, and 7 more ## # variables: cyl &lt;int&gt;, ## # trans &lt;chr&gt;, drv &lt;chr&gt;, ## # cty &lt;int&gt;, hwy &lt;int&gt;, fl &lt;chr&gt;, ## # class &lt;chr&gt; Debemos pensar hacer la misma operación con la nueva base, y que nos dé el mismo error. Además, el reprex debe incluir la carga de todos los paquetes necesarios: library(tidyverse) # carga filter(), mutate() y mpg mpg %&gt;% filter(model == &quot;a4&quot;) %&gt;% mutate(model = model * 5) # Error: Problem with `mutate()` input `model`. # x non-numeric argument to binary operator # i Input `model` is `model * 5`. Una ventaja de los reprex es que a menudo en el proceso de hacerlos, encontramos la raíz de los problemas. Por ejemplo, es posible que en la reducción anterior nos demos cuenta que filter() no tiene nada que ver con nuestro problema, por lo que el reprex podría quedar así: library(tidyverse) # carga filter(), mutate() y mpg mpg %&gt;% mutate(model = model * 5) # Error: Problem with `mutate()` input `model`. # x non-numeric argument to binary operator # i Input `model` is `model * 5`. "],["manejo-av.html", "05A - Manejo avanzado de datos (intro) Inicio: cargar paquetes, base de datos Pivotear bases de datos (wide &lt;-&gt; long) Recodificar variables Valores perdidos/missing/NA Unir bases de datos", " 05A - Manejo avanzado de datos (intro) Si quieres correr estos scripts localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (05A, 05B): tidyverse. Inicio: cargar paquetes, base de datos library(tidyverse) df_tasa_robos &lt;- read_csv(&quot;datos/tasa_robos_wide.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## comuna = col_character(), ## comuna_id = col_double(), ## `2012` = col_double(), ## `2013` = col_double(), ## `2014` = col_double(), ## `2015` = col_double(), ## `2016` = col_double() ## ) Tenemos una base de datos con los casos policiales de robos cada 1.000 habitantes. Contiene información para 340 comunas de Chile, 2012-2016. Su fuente es la Subsecretaría de Prevención del Delito (2017). Pivotear bases de datos (wide &lt;-&gt; long) ¿Qué pasa si queremos graficar estos datos, por ejemplo viendo la evolución temporal de la variable en una comuna? El formato de los datos no es el ideal. Aquí los valores de una variable (año) se expandieron hacia las columnas, generando una base en formato wide. Podemos “alargar” esta base usando la función pivot_longer(), de la siguiente manera: df_tasa_robos_long &lt;- df_tasa_robos %&gt;% pivot_longer(cols = -c(comuna, comuna_id), # descartamos vars. que no queremos transformar names_to = &quot;anio&quot;, values_to = &quot;tasa_robos&quot;) df_tasa_robos_long ## # A tibble: 1,700 x 4 ## comuna comuna_id anio tasa_robos ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Algarr… 5602 2012 4031. ## 2 Algarr… 5602 2013 3612. ## 3 Algarr… 5602 2014 3734. ## 4 Algarr… 5602 2015 4231. ## 5 Algarr… 5602 2016 3665. ## 6 Alhué 13502 2012 796. ## 7 Alhué 13502 2013 950. ## 8 Alhué 13502 2014 1167. ## 9 Alhué 13502 2015 606. ## 10 Alhué 13502 2016 956. ## # … with 1,690 more rows Esta estructura de datos es mucho más amigable para ggplot2: ggplot(data = df_tasa_robos_long %&gt;% filter(comuna %in% c(&quot;San-Joaquín&quot;, &quot;Macul&quot;)), mapping = aes(x = as.factor(anio), y = tasa_robos, color = comuna, group = comuna)) + geom_line() # podríamos seguir añadiendo escalas, labs, etc... Noten que pivot_longer() tiene una función recíproca, pivot_wider(): df_tasa_robos_long %&gt;% pivot_wider(names_from = &quot;anio&quot;, values_from = &quot;tasa_robos&quot;) ## # A tibble: 340 x 7 ## comuna comuna_id `2012` `2013` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algarrobo 5602 4031. 3612. ## 2 Alhué 13502 796. 950. ## 3 Alto-Biob… 8314 225. 305. ## 4 Alto-del-… 3302 208. 209. ## 5 Alto-Hosp… 1107 2589. 2218. ## 6 Ancud 10202 579. 763. ## 7 Andacollo 4103 759. 640. ## 8 Angol 9201 1400. 1515. ## 9 Antártica 12202 0 0 ## 10 Antofagas… 2101 2178. 1892. ## # … with 330 more rows, and 3 more ## # variables: 2014 &lt;dbl&gt;, ## # 2015 &lt;dbl&gt;, 2016 &lt;dbl&gt; Recodificar variables Supongamos que, usando nuestra nueva base long, queremos crear una variable binaria/dummy que indique si la observación es para el gobierno de Piñera I o Bachelet II. Podemos usar if_else() dentro de mutate(): df_tasa_robos_long %&gt;% mutate(d_gob_bachelet = if_else(condition = anio &gt;= 2014, true = 1, false = 0)) ## # A tibble: 1,700 x 5 ## comuna comuna_id anio tasa_robos ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Algarr… 5602 2012 4031. ## 2 Algarr… 5602 2013 3612. ## 3 Algarr… 5602 2014 3734. ## 4 Algarr… 5602 2015 4231. ## 5 Algarr… 5602 2016 3665. ## 6 Alhué 13502 2012 796. ## 7 Alhué 13502 2013 950. ## 8 Alhué 13502 2014 1167. ## 9 Alhué 13502 2015 606. ## 10 Alhué 13502 2016 956. ## # … with 1,690 more rows, and 1 more ## # variable: d_gob_bachelet &lt;dbl&gt; if_else() nos sirve si es que queremos crear variables binarias (numéricas o no). Pero a menudo queremos asignar más categorías. En esos casos podemos usar case_when(): df_tasa_robos_long %&gt;% mutate(gobierno = case_when(anio &lt; 2014 ~ &quot;Piñera I&quot;, # condición ~ valor anio == 2014 ~ &quot;Cambio de mando&quot;, anio &gt; 2014 ~ &quot;Bachelet II&quot;)) ## # A tibble: 1,700 x 5 ## comuna comuna_id anio tasa_robos ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Algarr… 5602 2012 4031. ## 2 Algarr… 5602 2013 3612. ## 3 Algarr… 5602 2014 3734. ## 4 Algarr… 5602 2015 4231. ## 5 Algarr… 5602 2016 3665. ## 6 Alhué 13502 2012 796. ## 7 Alhué 13502 2013 950. ## 8 Alhué 13502 2014 1167. ## 9 Alhué 13502 2015 606. ## 10 Alhué 13502 2016 956. ## # … with 1,690 more rows, and 1 more ## # variable: gobierno &lt;chr&gt; Una opción válida al usar case_when() es asignar un valor para “cualquier otro caso”: df_tasa_robos_long %&gt;% mutate(gobierno = case_when(anio &lt; 2014 ~ &quot;Piñera I&quot;, anio == 2014 ~ &quot;Cambio de mando&quot;, TRUE ~ &quot;Bachelet II&quot;)) # en cualquier otro caso ## # A tibble: 1,700 x 5 ## comuna comuna_id anio tasa_robos ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Algarr… 5602 2012 4031. ## 2 Algarr… 5602 2013 3612. ## 3 Algarr… 5602 2014 3734. ## 4 Algarr… 5602 2015 4231. ## 5 Algarr… 5602 2016 3665. ## 6 Alhué 13502 2012 796. ## 7 Alhué 13502 2013 950. ## 8 Alhué 13502 2014 1167. ## 9 Alhué 13502 2015 606. ## 10 Alhué 13502 2016 956. ## # … with 1,690 more rows, and 1 more ## # variable: gobierno &lt;chr&gt; Mini-ejercicio Crea la variable d_gob_bachelet de antes, pero esta vez usando case_when(). Tu código: Valores perdidos/missing/NA Para el resto de la clase trabajaremos también con datos de robos, esta vez para los países del Cono Sur (2006-2016). La fuente es la Oficina de las Naciones Unidas contra la Droga y el Delito (UNODC). df_robos_cono_sur &lt;- read_csv(&quot;datos/robos_cono_sur.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## pais = col_character(), ## pais_codigo = col_character(), ## anio = col_double(), ## robos_c100k = col_double() ## ) df_robos_cono_sur ## # A tibble: 33 x 4 ## pais pais_codigo anio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 ## 2 Argentina ARG 2007 ## 3 Argentina ARG 2008 ## 4 Argentina ARG 2009 ## 5 Argentina ARG 2010 ## 6 Argentina ARG 2011 ## 7 Argentina ARG 2012 ## 8 Argentina ARG 2013 ## 9 Argentina ARG 2014 ## 10 Argentina ARG 2015 ## # … with 23 more rows, and 1 more ## # variable: robos_c100k &lt;dbl&gt; Veamos los datos. ¿Qué pasó con las datos de Argentina, 2009-2013? R registra los valores perdidos como “NA”. Esto no es un caracter con las letras N y A, sino que un valor especial dentro del vector, sin importar su tipo. Realizar operaciones básicas en vectores con NA Intentemos calcular la media por país para la variable “robos_c100k”: df_robos_cono_sur %&gt;% group_by(pais) %&gt;% summarize(media_robos_c100k = mean(robos_c100k)) ## # A tibble: 3 x 2 ## pais media_robos_c100k ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina NA ## 2 Chile 1070. ## 3 Uruguay 2984. La mayoría de las operaciones básicas en R (median(), sd(), sum(), etc.) fallarán cuando alguno de los valores en el cálculo sea un NA. Si es que de todas formas queremos utilizar la función, tomando en cuenta solo los valores existentes, prácticamente todas estas operaciones incluyen un argumento na.rm = (NA remove): df_robos_cono_sur %&gt;% group_by(pais) %&gt;% summarize(media_robos_c100k = mean(robos_c100k, na.rm = T)) ## # A tibble: 3 x 2 ## pais media_robos_c100k ## &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina 669. ## 2 Chile 1070. ## 3 Uruguay 2984. Por defecto, los modelos de regresión hacen algo como esto, omiten las observaciones que tengan NA en alguna de las variables del modelo. Siempre que estemos en la duda sobre cómo se comporta alguna función ante NAs, deberíamos revisar su archivo de ayuda y buscar algún argumento que incluya “na”: ?lm Filtrar NAs de una base Lo siguiente no funcionará: df_robos_cono_sur %&gt;% filter(robos_c100k == NA) Lo que debemos utilizar en operaciones lógicas para testear la presencia de NAs es la función is.na(): df_robos_cono_sur %&gt;% filter(is.na(robos_c100k)) ## # A tibble: 5 x 4 ## pais pais_codigo anio robos_c100k ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Arge… ARG 2009 NA ## 2 Arge… ARG 2010 NA ## 3 Arge… ARG 2011 NA ## 4 Arge… ARG 2012 NA ## 5 Arge… ARG 2013 NA Podemos realizar una negación en una operación lógica antecediéndola de un signo de exclamación. En este caso, obtendremos solo las observaciones que no tienen NA en “robos_c100k”: df_robos_cono_sur %&gt;% filter(!is.na(robos_c100k)) ## # A tibble: 28 x 4 ## pais pais_codigo anio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 ## 2 Argentina ARG 2007 ## 3 Argentina ARG 2008 ## 4 Argentina ARG 2014 ## 5 Argentina ARG 2015 ## 6 Argentina ARG 2016 ## 7 Chile CHL 2006 ## 8 Chile CHL 2007 ## 9 Chile CHL 2008 ## 10 Chile CHL 2009 ## # … with 18 more rows, and 1 more ## # variable: robos_c100k &lt;dbl&gt; Crear valores perdidos df_robos_cono_sur ## # A tibble: 33 x 4 ## pais pais_codigo anio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 ## 2 Argentina ARG 2007 ## 3 Argentina ARG 2008 ## 4 Argentina ARG 2009 ## 5 Argentina ARG 2010 ## 6 Argentina ARG 2011 ## 7 Argentina ARG 2012 ## 8 Argentina ARG 2013 ## 9 Argentina ARG 2014 ## 10 Argentina ARG 2015 ## # … with 23 more rows, and 1 more ## # variable: robos_c100k &lt;dbl&gt; Supongamos que no confiamos en los datos más antiguos para Argentina (2006-2008) y también queremos asignarlos como valores perdidos. Una opción podría ser eliminar dichas observaciones con filter(), pero tal vez tenemos información útil en otras variables. Podríamos asignarle el valor de NA a dichas observaciones con if_else() o case_when(): df_robos_cono_sur %&gt;% mutate(robos_c100k = case_when( pais == &quot;Argentina&quot; &amp; anio &lt;= 2008 ~ NA, TRUE ~ robos_c100k )) Lo anterior falla, pese a que la sintaxis de case_when() es correcta! El problema es que cuando creamos valores perdidos debemos decirle explícitamente a R qué tipo de NAs utilizaremos, según el tipo de vector. Los tipos más comunes son NA_character_ (para vectores de caracteres, chr) o NA_real_ (para vectores de números reales, dbl). Veamos cómo ahora funcionará: df_robos_cono_sur %&gt;% mutate(robos_c100k = case_when( pais == &quot;Argentina&quot; &amp; anio &lt;= 2008 ~ NA_real_, TRUE ~ robos_c100k )) ## # A tibble: 33 x 4 ## pais pais_codigo anio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 ## 2 Argentina ARG 2007 ## 3 Argentina ARG 2008 ## 4 Argentina ARG 2009 ## 5 Argentina ARG 2010 ## 6 Argentina ARG 2011 ## 7 Argentina ARG 2012 ## 8 Argentina ARG 2013 ## 9 Argentina ARG 2014 ## 10 Argentina ARG 2015 ## # … with 23 more rows, and 1 more ## # variable: robos_c100k &lt;dbl&gt; Unir bases de datos Aquí tenemos una base con muchos datos de los World Development Indicators del Banco Mundial. Están para los tres países del Cono Sur, pero desde 2007 a 2016 (falta 2006, en comparación a los datos anteriores). df_wdi &lt;- read_csv(&quot;datos/wdi_cono_sur.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## .default = col_double(), ## pais_codigo = col_character(), ## external_debt_stocks_total_dod_current_us = col_logical(), ## total_debt_service_percent_of_exports_of_goods_services_and_primary_income = col_logical() ## ) ## ℹ Use `spec()` for the full column specifications. df_wdi ## # A tibble: 30 x 57 ## pais_codigo anio population_total ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ARG 2007 39684295 ## 2 CHL 2007 16530195 ## 3 URY 2007 3331749 ## 4 ARG 2008 40080160 ## 5 CHL 2008 16708258 ## 6 URY 2008 3340221 ## 7 ARG 2009 40482788 ## 8 CHL 2009 16886186 ## 9 URY 2009 3349676 ## 10 ARG 2010 40788453 ## # … with 20 more rows, and 54 more ## # variables: ## # population_growth_annual_percent &lt;dbl&gt;, ## # surface_area_sq_km &lt;dbl&gt;, ## # population_density_people_per_sq_km_of_land_area &lt;dbl&gt;, ## # poverty_headcount_ratio_at_national_poverty_lines_percent_of_population &lt;dbl&gt;, ## # poverty_headcount_ratio_at_1_90_a_day_2011_ppp_percent_of_population &lt;dbl&gt;, ## # gni_atlas_method_current_us &lt;dbl&gt;, ## # gni_per_capita_atlas_method_current_us &lt;dbl&gt;, ## # gni_ppp_current_international &lt;dbl&gt;, ## # gni_per_capita_ppp_current_international &lt;dbl&gt;, ## # income_share_held_by_lowest_20_percent &lt;dbl&gt;, ## # life_expectancy_at_birth_total_years &lt;dbl&gt;, ## # fertility_rate_total_births_per_woman &lt;dbl&gt;, ## # adolescent_fertility_rate_births_per_1_000_women_ages_15_19 &lt;dbl&gt;, ## # contraceptive_prevalence_any_methods_percent_of_women_ages_15_49 &lt;dbl&gt;, ## # births_attended_by_skilled_health_staff_percent_of_total &lt;dbl&gt;, ## # mortality_rate_under_5_per_1_000_live_births &lt;dbl&gt;, ## # prevalence_of_underweight_weight_for_age_percent_of_children_under_5 &lt;dbl&gt;, ## # immunization_measles_percent_of_children_ages_12_23_months &lt;dbl&gt;, ## # primary_completion_rate_total_percent_of_relevant_age_group &lt;dbl&gt;, ## # school_enrollment_primary_percent_gross &lt;dbl&gt;, ## # school_enrollment_secondary_percent_gross &lt;dbl&gt;, ## # school_enrollment_primary_and_secondary_gross_gender_parity_index_gpi &lt;dbl&gt;, ## # prevalence_of_hiv_total_percent_of_population_ages_15_49 &lt;dbl&gt;, ## # forest_area_sq_km &lt;dbl&gt;, ## # terrestrial_and_marine_protected_areas_percent_of_total_territorial_area &lt;dbl&gt;, ## # annual_freshwater_withdrawals_total_percent_of_internal_resources &lt;dbl&gt;, ## # urban_population_growth_annual_percent &lt;dbl&gt;, ## # energy_use_kg_of_oil_equivalent_per_capita &lt;dbl&gt;, ## # co2_emissions_metric_tons_per_capita &lt;dbl&gt;, ## # electric_power_consumption_k_wh_per_capita &lt;dbl&gt;, ## # gdp_current_us &lt;dbl&gt;, ## # gdp_growth_annual_percent &lt;dbl&gt;, ## # inflation_gdp_deflator_annual_percent &lt;dbl&gt;, ## # agriculture_forestry_and_fishing_value_added_percent_of_gdp &lt;dbl&gt;, ## # industry_including_construction_value_added_percent_of_gdp &lt;dbl&gt;, ## # exports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # imports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # gross_capital_formation_percent_of_gdp &lt;dbl&gt;, ## # revenue_excluding_grants_percent_of_gdp &lt;dbl&gt;, ## # time_required_to_start_a_business_days &lt;dbl&gt;, ## # domestic_credit_provided_by_financial_sector_percent_of_gdp &lt;dbl&gt;, ## # tax_revenue_percent_of_gdp &lt;dbl&gt;, ## # military_expenditure_percent_of_gdp &lt;dbl&gt;, ## # mobile_cellular_subscriptions_per_100_people &lt;dbl&gt;, ## # high_technology_exports_percent_of_manufactured_exports &lt;dbl&gt;, ## # statistical_capacity_score_overall_average &lt;dbl&gt;, ## # merchandise_trade_percent_of_gdp &lt;dbl&gt;, ## # net_barter_terms_of_trade_index_2000_100 &lt;dbl&gt;, ## # external_debt_stocks_total_dod_current_us &lt;lgl&gt;, ## # total_debt_service_percent_of_exports_of_goods_services_and_primary_income &lt;lgl&gt;, ## # net_migration &lt;dbl&gt;, ## # personal_remittances_received_current_us &lt;dbl&gt;, ## # foreign_direct_investment_net_inflows_bo_p_current_us &lt;dbl&gt;, ## # net_official_development_assistance_and_official_aid_received_current_us &lt;dbl&gt; ¿Cómo podemos añadir toda esta nueva información a nuestra base original? No podemos simplemente pegar las columnas unas al lado de otras con bind_cols() (los números de filas son distintos, lo mismo con el orden de las observaciones). Como ejemplos: bind_cols(tibble(x = 1), tibble(y = 2)) ## # A tibble: 1 x 2 ## x y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 bind_rows(tibble(x = 1), tibble(x = 2)) ## # A tibble: 2 x 1 ## x ## &lt;dbl&gt; ## 1 1 ## 2 2 Lo mejor es realizar una unión de bases (merge/join). Lejos la más común de estas operaciones es la unión izquierda, en la que queremos añadir información a una base (la izquierda) a partir de otra (la derecha). left_join() nos permitirá hacer esto, mirando las observaciones de ambas bases donde las columnas de identificación toman los mismos valores: df_robos_cono_sur_con_wdi &lt;- left_join( x = df_robos_cono_sur, y = df_wdi, by = c(&quot;pais_codigo&quot;, &quot;anio&quot;) # by dice cuáles son las variables de id. ) df_robos_cono_sur_con_wdi ## # A tibble: 33 x 59 ## pais pais_codigo anio ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argentina ARG 2006 ## 2 Argentina ARG 2007 ## 3 Argentina ARG 2008 ## 4 Argentina ARG 2009 ## 5 Argentina ARG 2010 ## 6 Argentina ARG 2011 ## 7 Argentina ARG 2012 ## 8 Argentina ARG 2013 ## 9 Argentina ARG 2014 ## 10 Argentina ARG 2015 ## # … with 23 more rows, and 56 more ## # variables: robos_c100k &lt;dbl&gt;, ## # population_total &lt;dbl&gt;, ## # population_growth_annual_percent &lt;dbl&gt;, ## # surface_area_sq_km &lt;dbl&gt;, ## # population_density_people_per_sq_km_of_land_area &lt;dbl&gt;, ## # poverty_headcount_ratio_at_national_poverty_lines_percent_of_population &lt;dbl&gt;, ## # poverty_headcount_ratio_at_1_90_a_day_2011_ppp_percent_of_population &lt;dbl&gt;, ## # gni_atlas_method_current_us &lt;dbl&gt;, ## # gni_per_capita_atlas_method_current_us &lt;dbl&gt;, ## # gni_ppp_current_international &lt;dbl&gt;, ## # gni_per_capita_ppp_current_international &lt;dbl&gt;, ## # income_share_held_by_lowest_20_percent &lt;dbl&gt;, ## # life_expectancy_at_birth_total_years &lt;dbl&gt;, ## # fertility_rate_total_births_per_woman &lt;dbl&gt;, ## # adolescent_fertility_rate_births_per_1_000_women_ages_15_19 &lt;dbl&gt;, ## # contraceptive_prevalence_any_methods_percent_of_women_ages_15_49 &lt;dbl&gt;, ## # births_attended_by_skilled_health_staff_percent_of_total &lt;dbl&gt;, ## # mortality_rate_under_5_per_1_000_live_births &lt;dbl&gt;, ## # prevalence_of_underweight_weight_for_age_percent_of_children_under_5 &lt;dbl&gt;, ## # immunization_measles_percent_of_children_ages_12_23_months &lt;dbl&gt;, ## # primary_completion_rate_total_percent_of_relevant_age_group &lt;dbl&gt;, ## # school_enrollment_primary_percent_gross &lt;dbl&gt;, ## # school_enrollment_secondary_percent_gross &lt;dbl&gt;, ## # school_enrollment_primary_and_secondary_gross_gender_parity_index_gpi &lt;dbl&gt;, ## # prevalence_of_hiv_total_percent_of_population_ages_15_49 &lt;dbl&gt;, ## # forest_area_sq_km &lt;dbl&gt;, ## # terrestrial_and_marine_protected_areas_percent_of_total_territorial_area &lt;dbl&gt;, ## # annual_freshwater_withdrawals_total_percent_of_internal_resources &lt;dbl&gt;, ## # urban_population_growth_annual_percent &lt;dbl&gt;, ## # energy_use_kg_of_oil_equivalent_per_capita &lt;dbl&gt;, ## # co2_emissions_metric_tons_per_capita &lt;dbl&gt;, ## # electric_power_consumption_k_wh_per_capita &lt;dbl&gt;, ## # gdp_current_us &lt;dbl&gt;, ## # gdp_growth_annual_percent &lt;dbl&gt;, ## # inflation_gdp_deflator_annual_percent &lt;dbl&gt;, ## # agriculture_forestry_and_fishing_value_added_percent_of_gdp &lt;dbl&gt;, ## # industry_including_construction_value_added_percent_of_gdp &lt;dbl&gt;, ## # exports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # imports_of_goods_and_services_percent_of_gdp &lt;dbl&gt;, ## # gross_capital_formation_percent_of_gdp &lt;dbl&gt;, ## # revenue_excluding_grants_percent_of_gdp &lt;dbl&gt;, ## # time_required_to_start_a_business_days &lt;dbl&gt;, ## # domestic_credit_provided_by_financial_sector_percent_of_gdp &lt;dbl&gt;, ## # tax_revenue_percent_of_gdp &lt;dbl&gt;, ## # military_expenditure_percent_of_gdp &lt;dbl&gt;, ## # mobile_cellular_subscriptions_per_100_people &lt;dbl&gt;, ## # high_technology_exports_percent_of_manufactured_exports &lt;dbl&gt;, ## # statistical_capacity_score_overall_average &lt;dbl&gt;, ## # merchandise_trade_percent_of_gdp &lt;dbl&gt;, ## # net_barter_terms_of_trade_index_2000_100 &lt;dbl&gt;, ## # external_debt_stocks_total_dod_current_us &lt;lgl&gt;, ## # total_debt_service_percent_of_exports_of_goods_services_and_primary_income &lt;lgl&gt;, ## # net_migration &lt;dbl&gt;, ## # personal_remittances_received_current_us &lt;dbl&gt;, ## # foreign_direct_investment_net_inflows_bo_p_current_us &lt;dbl&gt;, ## # net_official_development_assistance_and_official_aid_received_current_us &lt;dbl&gt; "],["manejo-av-ej.html", "05B - Visualización de datos (extensiones)", " 05B - Visualización de datos (extensiones) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica al comienzo del script 05A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). library(tidyverse) En el ejercicio trabajaremos con un panel de datos de países latinoamericanos en este milenio. Tenemos información sobre gasto en burocracia y pobreza; buscaremos responder a las preguntas (c) y (d). Los siguientes son los datos de gasto en burocracia, 2000-2017, que tienen por fuente el Banco Mundial (2017), compilados por Our World in Data: ## (este no es el formato original de OWID, aunque se parece bastante) df_gasto_burocracia &lt;- read_csv(&quot;datos/gasto_burocracia.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## PAÍS = col_character(), ## AÑO = col_double(), ## `% DE BUROCRACIA EN GASTO FISCAL` = col_double() ## ) df_gasto_burocracia ## # A tibble: 216 x 3 ## PAÍS AÑO `% DE BUROCRACIA EN… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argent… 2000 14.7 ## 2 Argent… 2001 14.2 ## 3 Argent… 2002 11.3 ## 4 Argent… 2003 11.7 ## 5 Argent… 2004 11.5 ## 6 Argent… 2005 NA ## 7 Argent… 2006 NA ## 8 Argent… 2007 NA ## 9 Argent… 2008 NA ## 10 Argent… 2009 NA ## # … with 206 more rows Estos son los datos de (extrema) pobreza, 2001-2017, medida como el porcentaje de la población que vive con menos de USD 1.90 al día (Banco Mundial, 2019): ## (este no es el formato original del Banco Mundial, aunque se parece bastante) df_pobreza &lt;- read_csv(&quot;datos/pobreza.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## country = col_character(), ## `2001` = col_double(), ## `2002` = col_double(), ## `2003` = col_double(), ## `2004` = col_double(), ## `2005` = col_double(), ## `2006` = col_double(), ## `2007` = col_double(), ## `2008` = col_double(), ## `2009` = col_double(), ## `2010` = col_double(), ## `2011` = col_double(), ## `2012` = col_double(), ## `2013` = col_double(), ## `2014` = col_double(), ## `2015` = col_double(), ## `2016` = col_double(), ## `2017` = col_double() ## ) df_pobreza ## # A tibble: 12 x 18 ## country `2001` `2002` `2003` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 9.4 14 7 ## 2 Bolivia 22.8 24.7 NA ## 3 Brazil 11.6 10.3 11.1 ## 4 Chile NA NA 4.2 ## 5 Colombia 19.7 14.3 12 ## 6 Ecuador NA NA 14.5 ## 7 Guyana NA NA NA ## 8 Peru 17.2 15 11.7 ## 9 Paraguay 8.9 13.2 8.3 ## 10 Suriname NA NA NA ## 11 Uruguay NA NA NA ## 12 Venezuela 11 18.2 22.7 ## # … with 14 more variables: ## # 2004 &lt;dbl&gt;, 2005 &lt;dbl&gt;, ## # 2006 &lt;dbl&gt;, 2007 &lt;dbl&gt;, ## # 2008 &lt;dbl&gt;, 2009 &lt;dbl&gt;, ## # 2010 &lt;dbl&gt;, 2011 &lt;dbl&gt;, ## # 2012 &lt;dbl&gt;, 2013 &lt;dbl&gt;, ## # 2014 &lt;dbl&gt;, 2015 &lt;dbl&gt;, ## # 2016 &lt;dbl&gt;, 2017 &lt;dbl&gt; ¿Qué necesitamos hacer con nuestros datos para poder contestar las preguntas C) y D)? A continuación, enumera las distintas modificaciones que debemos hacer para limpiar los datos, tomando en cuenta los contenidos de esta unidad. Modificación A Modificación B Etc. Ejecuta el plan de modificación/limpieza de A). Para Latinoamérica en su conjunto, ¿cómo ha evolucionado en el tiempo la media del % de gasto fiscal invertido en burocracia? C1) Genera un gráfico con dicha evolución. C2) Encuentra los valores promedios antes y después de la crisis del 2008 (te ayudará crear una variable dummy/binaria a partir de los años). A nivel latinoamericano, ¿existe una relación entre pobreza y % de gasto fiscal invertido en burocracia? Genera un gráfico para responder esta pregunta. Para cada país, utiliza el año más reciente en el que hay datos para ambas variables. "],["part-análisis-de-texto.html", "(PART) Análisis de texto", " (PART) Análisis de texto "],["texto-analisis.html", "06A - Análisis de texto Inicio: cargar paquetes, base de datos Tokens y frecuencias Separar el análisis de frecuencias por secciones Comparar frecuencias de palabras entre documentos Obtener las palabras más distintivas entre documentos", " 06A - Análisis de texto Si quieres correr estos scripts localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (06A, 06B, 06C): tidyverse, tidytext, stopwords, gutenbergr. Inicio: cargar paquetes, base de datos library(tidyverse) # install.packages(&quot;tidytext&quot;) # install.packages(&quot;stopwords&quot;) library(tidytext) library(SnowballC) # se instala solo con tidytext library(stopwords) Hoy trabajaremos con el texto de tres libros clásicos de teoría política: “Leviathan” de Hobbes (1651), “A Vindication of the Rights of Woman” de Mary Wollstonecraft (1792) y “On Liberty” de John Stuart Mill (1859). Como son libros antiguos, ya son parte del dominio público y se pueden descargar desde Project Gutenberg. Hay un paquete de R que ayuda a hacer esto automáticamente: pueden ver cómo descargué los libros y edité ligeramente las bases en el script 06c de este proyecto. Carguemos las bases: leviathan &lt;- read_csv(&quot;datos/leviathan.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## author = col_character(), ## book = col_character(), ## gutenberg_id = col_double(), ## chapter = col_double(), ## line = col_double(), ## text = col_character() ## ) rights &lt;- read_csv(&quot;datos/rights_of_women.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## author = col_character(), ## book = col_character(), ## gutenberg_id = col_double(), ## chapter = col_double(), ## line = col_double(), ## text = col_character() ## ) on_liberty &lt;- read_csv(&quot;datos/on_liberty.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## author = col_character(), ## book = col_character(), ## gutenberg_id = col_double(), ## chapter = col_double(), ## line = col_double(), ## text = col_character() ## ) Vamos a comenzar trabajando con “Leviathan” y “A Vindication of the Rights of Woman”, dejando “On Liberty” para algunos ejercicios. Tokens y frecuencias La unidad de análisis de estas bases de datos es la línea de texto. Esto es bastante común en los cuerpos de texto que provienen de libros / recursos impresos (la mayoría). Es probable que sea igual en, por ejemplo, programas de candidaturas políticas. Lo más común en análisis de texto, sin embargo, es analizar palabras o n-gramas (conjuntos de palabras). Esto no quita que a veces otras unidades de análisis sean interesantes (líneas, párrafos, capítulos, etc.), dependiendo de nuestras preguntas de investigación. Estas diferentes unidades de análisis de texto se llaman “tokens” en tidytext, y es posible pasar una base a una unidad de análisis más pequeña con la función unnest_tokens(). Obtengamos las palabras en “Leviathan”: palabras_leviathan &lt;- leviathan %&gt;% unnest_tokens(output = word, input = text, token = &quot;words&quot;) ¿Cuáles son las palabras más usadas en el libro? palabras_leviathan %&gt;% count(word, sort = TRUE) ## # A tibble: 9,965 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 the 14969 ## 2 of 10867 ## 3 and 7336 ## 4 to 7275 ## 5 is 4863 ## 6 that 4810 ## 7 in 4155 ## 8 a 3145 ## 9 by 2635 ## 10 for 2523 ## # … with 9,955 more rows Eliminar palabras vacías (stop words) y enraizar (stem) Que este tipo de palabras sean las más comunes es lógico. Sin embargo, no suelen darnos mucha información sobre los textos. Por suerte existen diccionarios de palabras vacías (stop words), que nos permitirán eliminarlas de nuestra base: stop_words_en &lt;- stopwords(language = &quot;en&quot;, source = &quot;smart&quot;) # si es que fuera en español... # stop_words_es &lt;- stopwords(language = &quot;es&quot;, source = &quot;snowball&quot;) stop_words_en ## [1] &quot;a&quot; &quot;a&#39;s&quot; ## [3] &quot;able&quot; &quot;about&quot; ## [5] &quot;above&quot; &quot;according&quot; ## [7] &quot;accordingly&quot; &quot;across&quot; ## [9] &quot;actually&quot; &quot;after&quot; ## [11] &quot;afterwards&quot; &quot;again&quot; ## [13] &quot;against&quot; &quot;ain&#39;t&quot; ## [15] &quot;all&quot; &quot;allow&quot; ## [17] &quot;allows&quot; &quot;almost&quot; ## [19] &quot;alone&quot; &quot;along&quot; ## [21] &quot;already&quot; &quot;also&quot; ## [23] &quot;although&quot; &quot;always&quot; ## [25] &quot;am&quot; &quot;among&quot; ## [27] &quot;amongst&quot; &quot;an&quot; ## [29] &quot;and&quot; &quot;another&quot; ## [31] &quot;any&quot; &quot;anybody&quot; ## [33] &quot;anyhow&quot; &quot;anyone&quot; ## [35] &quot;anything&quot; &quot;anyway&quot; ## [37] &quot;anyways&quot; &quot;anywhere&quot; ## [39] &quot;apart&quot; &quot;appear&quot; ## [41] &quot;appreciate&quot; &quot;appropriate&quot; ## [43] &quot;are&quot; &quot;aren&#39;t&quot; ## [45] &quot;around&quot; &quot;as&quot; ## [47] &quot;aside&quot; &quot;ask&quot; ## [49] &quot;asking&quot; &quot;associated&quot; ## [51] &quot;at&quot; &quot;available&quot; ## [53] &quot;away&quot; &quot;awfully&quot; ## [55] &quot;b&quot; &quot;be&quot; ## [57] &quot;became&quot; &quot;because&quot; ## [59] &quot;become&quot; &quot;becomes&quot; ## [61] &quot;becoming&quot; &quot;been&quot; ## [63] &quot;before&quot; &quot;beforehand&quot; ## [65] &quot;behind&quot; &quot;being&quot; ## [67] &quot;believe&quot; &quot;below&quot; ## [69] &quot;beside&quot; &quot;besides&quot; ## [71] &quot;best&quot; &quot;better&quot; ## [73] &quot;between&quot; &quot;beyond&quot; ## [75] &quot;both&quot; &quot;brief&quot; ## [77] &quot;but&quot; &quot;by&quot; ## [79] &quot;c&quot; &quot;c&#39;mon&quot; ## [81] &quot;c&#39;s&quot; &quot;came&quot; ## [83] &quot;can&quot; &quot;can&#39;t&quot; ## [85] &quot;cannot&quot; &quot;cant&quot; ## [87] &quot;cause&quot; &quot;causes&quot; ## [89] &quot;certain&quot; &quot;certainly&quot; ## [91] &quot;changes&quot; &quot;clearly&quot; ## [93] &quot;co&quot; &quot;com&quot; ## [95] &quot;come&quot; &quot;comes&quot; ## [97] &quot;concerning&quot; &quot;consequently&quot; ## [99] &quot;consider&quot; &quot;considering&quot; ## [101] &quot;contain&quot; &quot;containing&quot; ## [103] &quot;contains&quot; &quot;corresponding&quot; ## [105] &quot;could&quot; &quot;couldn&#39;t&quot; ## [107] &quot;course&quot; &quot;currently&quot; ## [109] &quot;d&quot; &quot;definitely&quot; ## [111] &quot;described&quot; &quot;despite&quot; ## [113] &quot;did&quot; &quot;didn&#39;t&quot; ## [115] &quot;different&quot; &quot;do&quot; ## [117] &quot;does&quot; &quot;doesn&#39;t&quot; ## [119] &quot;doing&quot; &quot;don&#39;t&quot; ## [121] &quot;done&quot; &quot;down&quot; ## [123] &quot;downwards&quot; &quot;during&quot; ## [125] &quot;e&quot; &quot;each&quot; ## [127] &quot;edu&quot; &quot;eg&quot; ## [129] &quot;eight&quot; &quot;either&quot; ## [131] &quot;else&quot; &quot;elsewhere&quot; ## [133] &quot;enough&quot; &quot;entirely&quot; ## [135] &quot;especially&quot; &quot;et&quot; ## [137] &quot;etc&quot; &quot;even&quot; ## [139] &quot;ever&quot; &quot;every&quot; ## [141] &quot;everybody&quot; &quot;everyone&quot; ## [143] &quot;everything&quot; &quot;everywhere&quot; ## [145] &quot;ex&quot; &quot;exactly&quot; ## [147] &quot;example&quot; &quot;except&quot; ## [149] &quot;f&quot; &quot;far&quot; ## [151] &quot;few&quot; &quot;fifth&quot; ## [153] &quot;first&quot; &quot;five&quot; ## [155] &quot;followed&quot; &quot;following&quot; ## [157] &quot;follows&quot; &quot;for&quot; ## [159] &quot;former&quot; &quot;formerly&quot; ## [161] &quot;forth&quot; &quot;four&quot; ## [163] &quot;from&quot; &quot;further&quot; ## [165] &quot;furthermore&quot; &quot;g&quot; ## [167] &quot;get&quot; &quot;gets&quot; ## [169] &quot;getting&quot; &quot;given&quot; ## [171] &quot;gives&quot; &quot;go&quot; ## [173] &quot;goes&quot; &quot;going&quot; ## [175] &quot;gone&quot; &quot;got&quot; ## [177] &quot;gotten&quot; &quot;greetings&quot; ## [179] &quot;h&quot; &quot;had&quot; ## [181] &quot;hadn&#39;t&quot; &quot;happens&quot; ## [183] &quot;hardly&quot; &quot;has&quot; ## [185] &quot;hasn&#39;t&quot; &quot;have&quot; ## [187] &quot;haven&#39;t&quot; &quot;having&quot; ## [189] &quot;he&quot; &quot;he&#39;s&quot; ## [191] &quot;hello&quot; &quot;help&quot; ## [193] &quot;hence&quot; &quot;her&quot; ## [195] &quot;here&quot; &quot;here&#39;s&quot; ## [197] &quot;hereafter&quot; &quot;hereby&quot; ## [199] &quot;herein&quot; &quot;hereupon&quot; ## [201] &quot;hers&quot; &quot;herself&quot; ## [203] &quot;hi&quot; &quot;him&quot; ## [205] &quot;himself&quot; &quot;his&quot; ## [207] &quot;hither&quot; &quot;hopefully&quot; ## [209] &quot;how&quot; &quot;howbeit&quot; ## [211] &quot;however&quot; &quot;i&quot; ## [213] &quot;i&#39;d&quot; &quot;i&#39;ll&quot; ## [215] &quot;i&#39;m&quot; &quot;i&#39;ve&quot; ## [217] &quot;ie&quot; &quot;if&quot; ## [219] &quot;ignored&quot; &quot;immediate&quot; ## [221] &quot;in&quot; &quot;inasmuch&quot; ## [223] &quot;inc&quot; &quot;indeed&quot; ## [225] &quot;indicate&quot; &quot;indicated&quot; ## [227] &quot;indicates&quot; &quot;inner&quot; ## [229] &quot;insofar&quot; &quot;instead&quot; ## [231] &quot;into&quot; &quot;inward&quot; ## [233] &quot;is&quot; &quot;isn&#39;t&quot; ## [235] &quot;it&quot; &quot;it&#39;d&quot; ## [237] &quot;it&#39;ll&quot; &quot;it&#39;s&quot; ## [239] &quot;its&quot; &quot;itself&quot; ## [241] &quot;j&quot; &quot;just&quot; ## [243] &quot;k&quot; &quot;keep&quot; ## [245] &quot;keeps&quot; &quot;kept&quot; ## [247] &quot;know&quot; &quot;knows&quot; ## [249] &quot;known&quot; &quot;l&quot; ## [251] &quot;last&quot; &quot;lately&quot; ## [253] &quot;later&quot; &quot;latter&quot; ## [255] &quot;latterly&quot; &quot;least&quot; ## [257] &quot;less&quot; &quot;lest&quot; ## [259] &quot;let&quot; &quot;let&#39;s&quot; ## [261] &quot;like&quot; &quot;liked&quot; ## [263] &quot;likely&quot; &quot;little&quot; ## [265] &quot;look&quot; &quot;looking&quot; ## [267] &quot;looks&quot; &quot;ltd&quot; ## [269] &quot;m&quot; &quot;mainly&quot; ## [271] &quot;many&quot; &quot;may&quot; ## [273] &quot;maybe&quot; &quot;me&quot; ## [275] &quot;mean&quot; &quot;meanwhile&quot; ## [277] &quot;merely&quot; &quot;might&quot; ## [279] &quot;more&quot; &quot;moreover&quot; ## [281] &quot;most&quot; &quot;mostly&quot; ## [283] &quot;much&quot; &quot;must&quot; ## [285] &quot;my&quot; &quot;myself&quot; ## [287] &quot;n&quot; &quot;name&quot; ## [289] &quot;namely&quot; &quot;nd&quot; ## [291] &quot;near&quot; &quot;nearly&quot; ## [293] &quot;necessary&quot; &quot;need&quot; ## [295] &quot;needs&quot; &quot;neither&quot; ## [297] &quot;never&quot; &quot;nevertheless&quot; ## [299] &quot;new&quot; &quot;next&quot; ## [301] &quot;nine&quot; &quot;no&quot; ## [303] &quot;nobody&quot; &quot;non&quot; ## [305] &quot;none&quot; &quot;noone&quot; ## [307] &quot;nor&quot; &quot;normally&quot; ## [309] &quot;not&quot; &quot;nothing&quot; ## [311] &quot;novel&quot; &quot;now&quot; ## [313] &quot;nowhere&quot; &quot;o&quot; ## [315] &quot;obviously&quot; &quot;of&quot; ## [317] &quot;off&quot; &quot;often&quot; ## [319] &quot;oh&quot; &quot;ok&quot; ## [321] &quot;okay&quot; &quot;old&quot; ## [323] &quot;on&quot; &quot;once&quot; ## [325] &quot;one&quot; &quot;ones&quot; ## [327] &quot;only&quot; &quot;onto&quot; ## [329] &quot;or&quot; &quot;other&quot; ## [331] &quot;others&quot; &quot;otherwise&quot; ## [333] &quot;ought&quot; &quot;our&quot; ## [335] &quot;ours&quot; &quot;ourselves&quot; ## [337] &quot;out&quot; &quot;outside&quot; ## [339] &quot;over&quot; &quot;overall&quot; ## [341] &quot;own&quot; &quot;p&quot; ## [343] &quot;particular&quot; &quot;particularly&quot; ## [345] &quot;per&quot; &quot;perhaps&quot; ## [347] &quot;placed&quot; &quot;please&quot; ## [349] &quot;plus&quot; &quot;possible&quot; ## [351] &quot;presumably&quot; &quot;probably&quot; ## [353] &quot;provides&quot; &quot;q&quot; ## [355] &quot;que&quot; &quot;quite&quot; ## [357] &quot;qv&quot; &quot;r&quot; ## [359] &quot;rather&quot; &quot;rd&quot; ## [361] &quot;re&quot; &quot;really&quot; ## [363] &quot;reasonably&quot; &quot;regarding&quot; ## [365] &quot;regardless&quot; &quot;regards&quot; ## [367] &quot;relatively&quot; &quot;respectively&quot; ## [369] &quot;right&quot; &quot;s&quot; ## [371] &quot;said&quot; &quot;same&quot; ## [373] &quot;saw&quot; &quot;say&quot; ## [375] &quot;saying&quot; &quot;says&quot; ## [377] &quot;second&quot; &quot;secondly&quot; ## [379] &quot;see&quot; &quot;seeing&quot; ## [381] &quot;seem&quot; &quot;seemed&quot; ## [383] &quot;seeming&quot; &quot;seems&quot; ## [385] &quot;seen&quot; &quot;self&quot; ## [387] &quot;selves&quot; &quot;sensible&quot; ## [389] &quot;sent&quot; &quot;serious&quot; ## [391] &quot;seriously&quot; &quot;seven&quot; ## [393] &quot;several&quot; &quot;shall&quot; ## [395] &quot;she&quot; &quot;should&quot; ## [397] &quot;shouldn&#39;t&quot; &quot;since&quot; ## [399] &quot;six&quot; &quot;so&quot; ## [401] &quot;some&quot; &quot;somebody&quot; ## [403] &quot;somehow&quot; &quot;someone&quot; ## [405] &quot;something&quot; &quot;sometime&quot; ## [407] &quot;sometimes&quot; &quot;somewhat&quot; ## [409] &quot;somewhere&quot; &quot;soon&quot; ## [411] &quot;sorry&quot; &quot;specified&quot; ## [413] &quot;specify&quot; &quot;specifying&quot; ## [415] &quot;still&quot; &quot;sub&quot; ## [417] &quot;such&quot; &quot;sup&quot; ## [419] &quot;sure&quot; &quot;t&quot; ## [421] &quot;t&#39;s&quot; &quot;take&quot; ## [423] &quot;taken&quot; &quot;tell&quot; ## [425] &quot;tends&quot; &quot;th&quot; ## [427] &quot;than&quot; &quot;thank&quot; ## [429] &quot;thanks&quot; &quot;thanx&quot; ## [431] &quot;that&quot; &quot;that&#39;s&quot; ## [433] &quot;thats&quot; &quot;the&quot; ## [435] &quot;their&quot; &quot;theirs&quot; ## [437] &quot;them&quot; &quot;themselves&quot; ## [439] &quot;then&quot; &quot;thence&quot; ## [441] &quot;there&quot; &quot;there&#39;s&quot; ## [443] &quot;thereafter&quot; &quot;thereby&quot; ## [445] &quot;therefore&quot; &quot;therein&quot; ## [447] &quot;theres&quot; &quot;thereupon&quot; ## [449] &quot;these&quot; &quot;they&quot; ## [451] &quot;they&#39;d&quot; &quot;they&#39;ll&quot; ## [453] &quot;they&#39;re&quot; &quot;they&#39;ve&quot; ## [455] &quot;think&quot; &quot;third&quot; ## [457] &quot;this&quot; &quot;thorough&quot; ## [459] &quot;thoroughly&quot; &quot;those&quot; ## [461] &quot;though&quot; &quot;three&quot; ## [463] &quot;through&quot; &quot;throughout&quot; ## [465] &quot;thru&quot; &quot;thus&quot; ## [467] &quot;to&quot; &quot;together&quot; ## [469] &quot;too&quot; &quot;took&quot; ## [471] &quot;toward&quot; &quot;towards&quot; ## [473] &quot;tried&quot; &quot;tries&quot; ## [475] &quot;truly&quot; &quot;try&quot; ## [477] &quot;trying&quot; &quot;twice&quot; ## [479] &quot;two&quot; &quot;u&quot; ## [481] &quot;un&quot; &quot;under&quot; ## [483] &quot;unfortunately&quot; &quot;unless&quot; ## [485] &quot;unlikely&quot; &quot;until&quot; ## [487] &quot;unto&quot; &quot;up&quot; ## [489] &quot;upon&quot; &quot;us&quot; ## [491] &quot;use&quot; &quot;used&quot; ## [493] &quot;useful&quot; &quot;uses&quot; ## [495] &quot;using&quot; &quot;usually&quot; ## [497] &quot;uucp&quot; &quot;v&quot; ## [499] &quot;value&quot; &quot;various&quot; ## [501] &quot;very&quot; &quot;via&quot; ## [503] &quot;viz&quot; &quot;vs&quot; ## [505] &quot;w&quot; &quot;want&quot; ## [507] &quot;wants&quot; &quot;was&quot; ## [509] &quot;wasn&#39;t&quot; &quot;way&quot; ## [511] &quot;we&quot; &quot;we&#39;d&quot; ## [513] &quot;we&#39;ll&quot; &quot;we&#39;re&quot; ## [515] &quot;we&#39;ve&quot; &quot;welcome&quot; ## [517] &quot;well&quot; &quot;went&quot; ## [519] &quot;were&quot; &quot;weren&#39;t&quot; ## [521] &quot;what&quot; &quot;what&#39;s&quot; ## [523] &quot;whatever&quot; &quot;when&quot; ## [525] &quot;whence&quot; &quot;whenever&quot; ## [527] &quot;where&quot; &quot;where&#39;s&quot; ## [529] &quot;whereafter&quot; &quot;whereas&quot; ## [531] &quot;whereby&quot; &quot;wherein&quot; ## [533] &quot;whereupon&quot; &quot;wherever&quot; ## [535] &quot;whether&quot; &quot;which&quot; ## [537] &quot;while&quot; &quot;whither&quot; ## [539] &quot;who&quot; &quot;who&#39;s&quot; ## [541] &quot;whoever&quot; &quot;whole&quot; ## [543] &quot;whom&quot; &quot;whose&quot; ## [545] &quot;why&quot; &quot;will&quot; ## [547] &quot;willing&quot; &quot;wish&quot; ## [549] &quot;with&quot; &quot;within&quot; ## [551] &quot;without&quot; &quot;won&#39;t&quot; ## [553] &quot;wonder&quot; &quot;would&quot; ## [555] &quot;would&quot; &quot;wouldn&#39;t&quot; ## [557] &quot;x&quot; &quot;y&quot; ## [559] &quot;yes&quot; &quot;yet&quot; ## [561] &quot;you&quot; &quot;you&#39;d&quot; ## [563] &quot;you&#39;ll&quot; &quot;you&#39;re&quot; ## [565] &quot;you&#39;ve&quot; &quot;your&quot; ## [567] &quot;yours&quot; &quot;yourself&quot; ## [569] &quot;yourselves&quot; &quot;z&quot; ## [571] &quot;zero&quot; palabras_leviathan_limpio &lt;- leviathan %&gt;% unnest_tokens(output = word, input = text, token = &quot;words&quot;) %&gt;% # filtrar stop words! filter(!(word %in% stop_words_en)) palabras_leviathan_limpio ## # A tibble: 79,118 x 6 ## author book gutenberg_id chapter ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Thomas… Levi… 3207 0 ## 2 Thomas… Levi… 3207 0 ## 3 Thomas… Levi… 3207 0 ## 4 Thomas… Levi… 3207 0 ## 5 Thomas… Levi… 3207 0 ## 6 Thomas… Levi… 3207 0 ## 7 Thomas… Levi… 3207 0 ## 8 Thomas… Levi… 3207 0 ## 9 Thomas… Levi… 3207 0 ## 10 Thomas… Levi… 3207 0 ## # … with 79,108 more rows, and 2 ## # more variables: line &lt;dbl&gt;, ## # word &lt;chr&gt; Ahora calculemos las frecuencias: palabras_leviathan_limpio %&gt;% count(word, sort = T) ## # A tibble: 9,559 x 2 ## word n ## &lt;chr&gt; &lt;int&gt; ## 1 man 1071 ## 2 god 1068 ## 3 men 998 ## 4 power 745 ## 5 law 662 ## 6 common 632 ## 7 soveraign 497 ## 8 hath 446 ## 9 wealth 438 ## 10 nature 420 ## # … with 9,549 more rows Por cierto, otra herramienta útil para limpiar el análisis posterior es el stemming, el ejercicio de llevar las palabras a su raíz. Por ejemplo: SnowballC::wordStem(c(&quot;caminaba&quot;, &quot;caminó&quot;), language = &quot;es&quot;) ## [1] &quot;camin&quot; &quot;camin&quot; Podríamos realizar esto para las palabras de nuestra base: palabras_leviathan_limpio_ej_stemming &lt;- palabras_leviathan_limpio %&gt;% mutate(word = SnowballC::wordStem(word, language = &quot;en&quot;)) length(unique(palabras_leviathan_limpio$word)) ## [1] 9559 length(unique(palabras_leviathan_limpio_ej_stemming$word)) ## [1] 6351 (Ejercicio a) ¿Cuáles son las palabras más comunes en “A Vindication of the Rights of Woman” de Mary Wollstonecraft, eliminando stop words? Incluye una columna con la proporción de aparición de cada palabra en el libro. Crea una base “palabras_rights_limpio”, similar a la que hicimos antes, en el proceso. Tu código: palabras_rights_limpio &lt;- rights %&gt;% unnest_tokens(output = word, input = text, token = &quot;words&quot;) %&gt;% # filtrar stop words! filter(!(word %in% stop_words_en)) Hacer un ránking de las palabras más comunes Hagamos un gráfico de “ránking” para las diez palabras más comunes en el libro de Wollstonecraft: rank_rights &lt;- palabras_rights_limpio %&gt;% count(word, sort = T) %&gt;% slice(1:10) ggplot(data = rank_rights, mapping = aes(x = n, y = fct_reorder(as.factor(word), n), label = n)) + geom_col() + geom_label() + labs(title = &quot;Palabras más comunes en el libro&quot;, subtitle = &quot;&#39;A Vindication of the Rights of Woman&#39; (1792)&quot;, x = &quot;Frecuencia&quot;, y = &quot;&quot;, caption = &quot;Fuente: Elaboración propia en base a Wollstonecraft (1792)&quot;) (Ejercicio b) Genera un gráfico con las palabras más comunes en “On Liberty” de John Stuart Mill. Tu código: Separar el análisis de frecuencias por secciones Obtengamos las diez palabras más comunes de cada capítulo, con un combo de count(), group_by() y slice(): rank_rights_caps &lt;- palabras_rights_limpio %&gt;% count(word, chapter, sort = T) %&gt;% group_by(chapter) %&gt;% slice(1:10) %&gt;% ungroup() Ahora podemos graficarlas con las “facetas” de ggplot2: ggplot(data = rank_rights_caps %&gt;% filter(chapter != 0), mapping = aes(x = n, # permite ordenar las barras dentro de cada faceta: y = reorder_within(as.factor(word), n, chapter))) + geom_col() + facet_wrap(~chapter, scales = &quot;free_y&quot;) + # permite ordenar las barras dentro de cada faceta: scale_y_reordered() + labs(x = &quot;Frecuencia&quot;, y = &quot;&quot;, title = &quot;Palabras más comunes en cada capítulo&quot;, subtitle = &quot;&#39;A Vindication of the Rights of Woman&#39; (1792)&quot;, caption = &quot;Elaboración propia en base a Wollstonecraft (1792)&quot;) Por cierto, cuando se separa el análisis decimos que este se realiza por “documentos”. Estos documentos pueden ser capítulos/secciones, como vimos ahora, o simplemente distintos textos/libros. Comparar frecuencias de palabras entre documentos Es claro que los dos libros (documentos) ocupan un vocabulario marcadamente distinto. Podemos graficar esta diferencia. Primero vamos a crear bases de datos para ambos libros, que contengan la proporción de cada palabra en el texto: prop_palabras_leviathan &lt;- palabras_leviathan_limpio %&gt;% count(word, sort = T) %&gt;% mutate(prop_leviathan = n / sum(n)) %&gt;% select(-n) prop_palabras_leviathan ## # A tibble: 9,559 x 2 ## word prop_leviathan ## &lt;chr&gt; &lt;dbl&gt; ## 1 man 0.0135 ## 2 god 0.0135 ## 3 men 0.0126 ## 4 power 0.00942 ## 5 law 0.00837 ## 6 common 0.00799 ## 7 soveraign 0.00628 ## 8 hath 0.00564 ## 9 wealth 0.00554 ## 10 nature 0.00531 ## # … with 9,549 more rows prop_palabras_rights &lt;- palabras_rights_limpio %&gt;% count(word, sort = T) %&gt;% mutate(prop_rights = n / sum(n)) %&gt;% select(-n) prop_palabras_rights ## # A tibble: 7,386 x 2 ## word prop_rights ## &lt;chr&gt; &lt;dbl&gt; ## 1 women 0.0124 ## 2 man 0.00857 ## 3 men 0.00832 ## 4 reason 0.00735 ## 5 mind 0.00645 ## 6 virtue 0.00551 ## 7 woman 0.00529 ## 8 love 0.00481 ## 9 life 0.00473 ## 10 nature 0.00409 ## # … with 7,376 more rows Ahora vamos a unir las bases de datos, utilizando un full_join(), que básicamente conservará todas las filas y columnas de ambas. Cuando no encuentre un match para llenar una celda, full_join dejará un NA, por lo que en el segundo comando reemplazaremos esos NA por 0, utilizando replace_na(): props_lev_women &lt;- full_join(prop_palabras_leviathan, prop_palabras_rights, by = &quot;word&quot;) %&gt;% replace_na(replace = list(prop_leviathan = 0, prop_rights = 0)) props_lev_women ## # A tibble: 13,731 x 3 ## word prop_leviathan prop_rights ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 man 0.0135 0.00857 ## 2 god 0.0135 0.00153 ## 3 men 0.0126 0.00832 ## 4 power 0.00942 0.00267 ## 5 law 0.00837 0.000445 ## 6 common 0.00799 0.00198 ## 7 sovera… 0.00628 0 ## 8 hath 0.00564 0.000223 ## 9 wealth 0.00554 0.000390 ## 10 nature 0.00531 0.00409 ## # … with 13,721 more rows Ya podemos graficar la relación entre los dos libros: ggplot(data = props_lev_women, mapping = aes(x = prop_leviathan, y = prop_rights, label = word)) + geom_text() + geom_abline() + scale_x_continuous(limits = c(0, 0.015)) + scale_y_continuous(limits = c(0, 0.015)) + labs(title = &quot;Comparación de palabras en los libros&quot;, x = &quot;Frecuencia proporcial de la palabra en Hobbes (1651)&quot;, y = &quot;Frecuencia proporcial de la palabra en Wollstonecraft (1792)&quot;, caption = &quot;Elaboración propia en base a Hobbes (1651) y Wollstonecraft (1792)&quot;) La mayoría de las palabras se repite con proporciones similares en ambos documentos, por eso poblan el sector inferior izquierdo del gráfico. Esta distribución es muy común. En la próxima sección veremos cómo obtener la palabras más distintivas de cada documento. (Ejercicio c) Grafica la relación de palabras entre dos documentos: los capítulos 2 y 4 de “On liberty” de John Stuart Mill. Tu código: Obtener las palabras más distintivas entre documentos Tal vez nuestro objetivo al comparar documentos es encontrar las palabras más distintivas de cada uno (¿por qué mirar las frecuencias puede no ser la mejor forma de hacer esto?). Un cálculo relativamente sencillo de esto es el llamado tf-idf (term frequency - inverse document frequency; Silge &amp; Robinson (2019, cap. 3)). El tf-idf busca medir la frecuencia relativa de un término en un documento (tf) ponderada por qué tan raro es ese término a lo largo de todos los documentos (idf). Tiene dos partes: tf: La frecuencia del término \\(i\\) en el documento \\(d\\) (\\(\\textit{tf}_{i,d}\\)) es simplemente el número de veces que este aparece en el documento divido el total de palabras en el documento. Esto espera ser una medida de qué tanto se repite la palabra en el documento: \\[ tf_{i,d} = \\frac{n_{\\ i\\;en\\;d}}{n_{\\ total\\ términos\\ en\\ d}} \\] idf: Mientras tanto, la frecuencia inversa del término \\(i\\) en los documentos (\\(\\textit{idf}_{i}\\)) es un poco más complicada. Busca ser una medida de qué tan poco común es el uso de una palabra a lo largo de varios documentos. Es el logaritmo natural de la división entre el número de documentos totales y el número de documentos que contienen el término \\(i\\): \\[ idf_i = ln(\\frac{n_{\\ docs}}{n_{\\ docs\\ que\\ contienen\\ i}}) \\] La tf-idf (term frequency - inverse document frequency) es simplemente la multiplicación de ambos números. \\[ \\textit{tf-idf}_{i,d} = \\textit{tf}_{i,d} \\cdot \\textit{idf}_i \\] Por ejemplo: (10 / 100) * # término que aparece en un 10% de los términos del doc. log(8 / 8) # está presente en todos los documentos ## [1] 0 (10 / 100) * # término que aparece en un 10% de los términos del doc. log(8 / 4) # está presente en la mitad de los documentos ## [1] 0.06931472 (10 / 100) * # término que aparece en un 10% de los términos del doc. log(8 / 1) # está presente en un solo documento ## [1] 0.2079442 La función bind_tf_idf() nos permite calcular rápidamente el tf_idf para un conteo de palabras. Obtengamos las diez palabras más distintivas de cada capítulo del libro de Wollstonecraft: tf_idf_rights &lt;- palabras_rights_limpio %&gt;% filter(chapter != 0) %&gt;% count(word, chapter, sort = T) %&gt;% # fíjense en los argumentos: bind_tf_idf(term = word, document = chapter, n = n) tf_idf_rights ## # A tibble: 18,020 x 6 ## word chapter n tf idf ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 women 4 86 0.0183 0 ## 2 reas… 5 68 0.0104 0 ## 3 man 5 61 0.00934 0 ## 4 women 12 51 0.0124 0 ## 5 women 13 51 0.0171 0 ## 6 women 2 48 0.0140 0 ## 7 men 4 47 0.0100 0.0800 ## 8 woman 5 45 0.00689 0.167 ## 9 man 2 43 0.0126 0 ## 10 man 4 43 0.00917 0 ## # … with 18,010 more rows, and 1 ## # more variable: tf_idf &lt;dbl&gt; # ahora vamos a quedarnos solo con los diez tf-idf más altos por documento (capítulo): rank_tf_idf_rights &lt;- tf_idf_rights %&gt;% group_by(chapter) %&gt;% arrange(-tf_idf) %&gt;% slice(1:10) %&gt;% ungroup() rank_tf_idf_rights ## # A tibble: 130 x 6 ## word chapter n tf idf ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 profe… 1 5 0.00382 1.47 ## 2 barba… 1 3 0.00229 1.87 ## 3 thous… 1 3 0.00229 1.87 ## 4 curate 1 2 0.00153 2.56 ## 5 defor… 1 2 0.00153 2.56 ## 6 monar… 1 2 0.00153 2.56 ## 7 pushes 1 2 0.00153 2.56 ## 8 unsou… 1 2 0.00153 2.56 ## 9 perfe… 1 5 0.00382 0.956 ## 10 civil… 1 6 0.00458 0.773 ## # … with 120 more rows, and 1 more ## # variable: tf_idf &lt;dbl&gt; Ahora podemos graficarlas: ggplot(data = rank_tf_idf_rights, mapping = aes(x = tf_idf, # permite ordenar las barras dentro de cada faceta: y = reorder_within(as.factor(word), tf_idf, chapter))) + geom_col() + # permite ordenar las barras dentro de cada faceta: scale_y_reordered() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + facet_wrap(~chapter, scales = &quot;free_y&quot;) + labs(x = &quot;tf-idf&quot;, y = &quot;&quot;, title = &quot;Palabras más distintivas de cada capítulo&quot;, subtitle = &quot;&#39;A Vindication of the Rights of Woman&#39; (1792)&quot;, caption = &quot;Elaboración propia en base a Wollstonecraft (1792)&quot;) (Ejercicio d) Grafica las palabras más distintivas al comparar los tres libros. Tip: un paso debería ser unir las tres bases. Hay varias formas de hacer esto, pero te recomiendo experimentar con bind_rows(). Tu código: "],["texto-cadenas.html", "06B - Cadenas de texto Inicio: cargar paquetes, base de datos Cadenas de texto Algunas operaciones simples con texto Funciones para trabajar con patrones Patrones más complejos con expresiones regulares (regex) (Ejercicio f)", " 06B - Cadenas de texto Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos en RStudio Cloud con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). Inicio: cargar paquetes, base de datos library(tidyverse) df_legisladores_cargos &lt;- read_csv(&quot;datos/df_legisladores_cargos.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## nombre_comp = col_character(), ## id = col_double(), ## caja_trayectoria = col_character() ## ) Esta base de datos contiene información de las reseñas parlamentarias de la BCN, para legisladores con cargos entre 1990-presente (ejemplo). La unidad de análisis de esta base es legislador-cargo. Cadenas de texto Los elementos en un vector de caracteres se pueden denominar “strings” o cadenas de texto. Veamos los primeros elementos del vector “caja_trayectoria”: head(df_legisladores_cargos$caja_trayectoria) ## [1] &quot;\\nSenador institucional \\n1998- 2006\\n&quot; ## [2] &quot;\\nDiputado \\n2010- 2014\\nDistrito N° 24Partido por la DemocraciaSucedido por: Jaime Hernán Gonzalo Pilowsky Greene&quot; ## [3] &quot;\\nDiputado \\n2006- 2010\\nDistrito N° 24Partido por la Democracia&quot; ## [4] &quot;\\nDiputado \\n2002- 2006\\nDistrito N° 24Partido por la DemocraciaPrecedido por: Tomás Jocelyn Holt Letelier&quot; ## [5] &quot;\\nDiputado \\n1998- 2002\\nDistrito N° 52Partido Demócrata CristianoSucedido por: Fernando Meza Moncada&quot; ## [6] &quot;\\nDiputado \\n1994- 1998\\nDistrito N° 52Partido Demócrata Cristiano&quot; Cada una de estas cadenas de texto contiene información que podría distribuirse en al menos cinco variables: cargo (diputado, senador*), año de inicio del período, año de término del período, distrito, partido. Nuestro objetivo será poder trabajar con dicha información, que por ahora está perdida en las cadenas (y es inútil). Para esto utilizaremos el paquete stringr, que se carga con el tidyverse. Por cierto, los \\n que se leen en las cadenas de texto significan “salto de párrafo”, como podemos ver en la caja de la reseña parlamentaria de ejemplo. Algunas operaciones simples con texto Cambiar mayúsculas df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_to_lower(caja_trayectoria)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador insti… &quot;\\nsenador inst… ## 2 &quot;\\nDiputado \\n20… &quot;\\ndiputado \\n2… ## 3 &quot;\\nDiputado \\n20… &quot;\\ndiputado \\n2… ## 4 &quot;\\nDiputado \\n20… &quot;\\ndiputado \\n2… ## 5 &quot;\\nDiputado \\n19… &quot;\\ndiputado \\n1… ## 6 &quot;\\nDiputado \\n19… &quot;\\ndiputado \\n1… ## 7 &quot;\\nDiputado \\n19… &quot;\\ndiputado \\n1… ## 8 &quot;\\nDiputado \\n20… &quot;\\ndiputado \\n2… ## 9 &quot;\\nDiputado \\n20… &quot;\\ndiputado \\n2… ## 10 &quot;\\nDiputado \\n20… &quot;\\ndiputado \\n2… ## # … with 1,181 more rows (Ejercicio a) Mira el archivo de ayuda de str_to_lower(). ¿Qué otras operaciones podemos hacer con las mayúsculas? Pruébalas con el ejemplo anterior. Tu código: Eliminar espacios innecesarios df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_squish(caja_trayectoria)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador insti… Senador institu… ## 2 &quot;\\nDiputado \\n20… Diputado 2010- … ## 3 &quot;\\nDiputado \\n20… Diputado 2006- … ## 4 &quot;\\nDiputado \\n20… Diputado 2002- … ## 5 &quot;\\nDiputado \\n19… Diputado 1998- … ## 6 &quot;\\nDiputado \\n19… Diputado 1994- … ## 7 &quot;\\nDiputado \\n19… Diputado 1990- … ## 8 &quot;\\nDiputado \\n20… Diputado 2006- … ## 9 &quot;\\nDiputado \\n20… Diputado 2014- … ## 10 &quot;\\nDiputado \\n20… Diputado 2010- … ## # … with 1,181 more rows Obtener número de caracteres df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_length(caja_trayectoria)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;int&gt; ## 1 &quot;\\nSenador insti… 35 ## 2 &quot;\\nDiputado \\n20… 111 ## 3 &quot;\\nDiputado \\n20… 61 ## 4 &quot;\\nDiputado \\n20… 103 ## 5 &quot;\\nDiputado \\n19… 98 ## 6 &quot;\\nDiputado \\n19… 63 ## 7 &quot;\\nDiputado \\n19… 63 ## 8 &quot;\\nDiputado \\n20… 133 ## 9 &quot;\\nDiputado \\n20… 50 ## 10 &quot;\\nDiputado \\n20… 56 ## # … with 1,181 more rows Funciones para trabajar con patrones En general, podemos encontrar patrones en las cadenas que nos permitirán interpretar la información que contienen. Como los datos de texto suelen ser desestructurados, tendremos que idear estos patrones ad hoc, caso a caso. El patrón más sencillo es simplemente una serie textual de caracteres. Por ejemplo, podemos ocupar la función lógica str_detect() para marcar todas las observaciones que incluyen la serie de caracteres “Diputad” en la variable “caja_trayectoria”: df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_detect(caja_trayectoria, pattern = &quot;Diputad&quot;)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;lgl&gt; ## 1 &quot;\\nSenador insti… FALSE ## 2 &quot;\\nDiputado \\n20… TRUE ## 3 &quot;\\nDiputado \\n20… TRUE ## 4 &quot;\\nDiputado \\n20… TRUE ## 5 &quot;\\nDiputado \\n19… TRUE ## 6 &quot;\\nDiputado \\n19… TRUE ## 7 &quot;\\nDiputado \\n19… TRUE ## 8 &quot;\\nDiputado \\n20… TRUE ## 9 &quot;\\nDiputado \\n20… TRUE ## 10 &quot;\\nDiputado \\n20… TRUE ## # … with 1,181 more rows Como sabemos, las funciones lógicas nos permiten filtrar bases: df_legisladores_cargos %&gt;% filter(str_detect(caja_trayectoria, pattern = &quot;Diputad&quot;)) %&gt;% select(caja_trayectoria) # solo para ver mejor el resultado ## # A tibble: 985 x 1 ## caja_trayectoria ## &lt;chr&gt; ## 1 &quot;\\nDiputado \\n2010- 2014\\nDistrit… ## 2 &quot;\\nDiputado \\n2006- 2010\\nDistrit… ## 3 &quot;\\nDiputado \\n2002- 2006\\nDistrit… ## 4 &quot;\\nDiputado \\n1998- 2002\\nDistrit… ## 5 &quot;\\nDiputado \\n1994- 1998\\nDistrit… ## 6 &quot;\\nDiputado \\n1990- 1994\\nDistrit… ## 7 &quot;\\nDiputado \\n2006- 2010\\nDistrit… ## 8 &quot;\\nDiputado \\n2014- 2018\\nDistrit… ## 9 &quot;\\nDiputado \\n2010- 2014\\nDistrit… ## 10 &quot;\\nDiputado \\n2006- 2010\\nDistrit… ## # … with 975 more rows También podemos ocupar una negación para obtener las observaciones de senadores: df_legisladores_cargos %&gt;% filter(!str_detect(caja_trayectoria, pattern = &quot;Diputad&quot;)) %&gt;% select(caja_trayectoria) # solo para ver mejor el resultado ## # A tibble: 206 x 1 ## caja_trayectoria ## &lt;chr&gt; ## 1 &quot;\\nSenador institucional \\n1998- … ## 2 &quot;\\nSenador \\n2014- 2022\\n7ª Circu… ## 3 &quot;\\nSenador \\n2014- 2022\\n8ª Circu… ## 4 &quot;\\nSenador \\n2006- 2014\\nTérmino … ## 5 &quot;\\nSenadora \\n2018- 2026\\n6ª Circ… ## 6 &quot;\\nSenadora \\n2010- 2018\\n3ª Circ… ## 7 &quot;\\nSenadora \\n2006- 2014\\n8ª Circ… ## 8 &quot;\\nSenador \\n2002- 2010\\n6ª Circu… ## 9 &quot;\\nSenadora \\n2018- 2026\\n11ª Cir… ## 10 &quot;\\nSenador \\n2014- 2022\\nCircunsc… ## # … with 196 more rows Ahora introduciremos tres funciones que utilizan patrones, str_extract(), str_replace() y str_remove(). ¿Qué hace cada una? Tus notas: df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_extract(caja_trayectoria, pattern = &quot;Diputad&quot;)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador insti… &lt;NA&gt; ## 2 &quot;\\nDiputado \\n20… Diputad ## 3 &quot;\\nDiputado \\n20… Diputad ## 4 &quot;\\nDiputado \\n20… Diputad ## 5 &quot;\\nDiputado \\n19… Diputad ## 6 &quot;\\nDiputado \\n19… Diputad ## 7 &quot;\\nDiputado \\n19… Diputad ## 8 &quot;\\nDiputado \\n20… Diputad ## 9 &quot;\\nDiputado \\n20… Diputad ## 10 &quot;\\nDiputado \\n20… Diputad ## # … with 1,181 more rows df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_replace(caja_trayectoria, pattern = &quot;institucional&quot;, replacement = &quot;designado&quot;)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador insti… &quot;\\nSenador desi… ## 2 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 3 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 4 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 5 &quot;\\nDiputado \\n19… &quot;\\nDiputado \\n1… ## 6 &quot;\\nDiputado \\n19… &quot;\\nDiputado \\n1… ## 7 &quot;\\nDiputado \\n19… &quot;\\nDiputado \\n1… ## 8 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 9 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 10 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## # … with 1,181 more rows df_legisladores_cargos %&gt;% mutate(caja_trayectoria_edit = str_remove(caja_trayectoria, pattern = &quot;N° &quot;)) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) %&gt;% select(caja_trayectoria, caja_trayectoria_edit) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria caja_trayectori… ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador insti… &quot;\\nSenador inst… ## 2 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 3 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 4 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 5 &quot;\\nDiputado \\n19… &quot;\\nDiputado \\n1… ## 6 &quot;\\nDiputado \\n19… &quot;\\nDiputado \\n1… ## 7 &quot;\\nDiputado \\n19… &quot;\\nDiputado \\n1… ## 8 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 9 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## 10 &quot;\\nDiputado \\n20… &quot;\\nDiputado \\n2… ## # … with 1,181 more rows Patrones más complejos con expresiones regulares (regex) Fuentes: Kelly Vaughn, Programmer Humor y Towards Data Science. Hasta aquí hemos utilizado patrones muy simples y específicos, por medio de series textuales de caracteres. Pero a menudo la información de nuestras cadenas de texto sigue patrones más generales. Por ejemplo, ¿cómo podemos obtener el año de inicio de cada período? Sabemos que todos tienen cuatro dígitos, y siempre son los primeros cuatro dígitos que aparecen. Conociendo esto, podemos extraerlos de nuestras cadenas: df_legisladores_cargos %&gt;% mutate(inicio_per = str_extract(caja_trayectoria, pattern = &quot;\\\\d{4}&quot;)) %&gt;% select(caja_trayectoria, inicio_per) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria inicio_per ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador institucion… 1998 ## 2 &quot;\\nDiputado \\n2010- 20… 2010 ## 3 &quot;\\nDiputado \\n2006- 20… 2006 ## 4 &quot;\\nDiputado \\n2002- 20… 2002 ## 5 &quot;\\nDiputado \\n1998- 20… 1998 ## 6 &quot;\\nDiputado \\n1994- 19… 1994 ## 7 &quot;\\nDiputado \\n1990- 19… 1990 ## 8 &quot;\\nDiputado \\n2006- 20… 2006 ## 9 &quot;\\nDiputado \\n2014- 20… 2014 ## 10 &quot;\\nDiputado \\n2010- 20… 2010 ## # … with 1,181 more rows Nuestro patrón esta escrito en el lenguaje de las expresiones regulares, que permite crear patrones generales en vez de específicos. Así, \\\\d significa “un dígito” y {4} significa cuatro veces. Puedes consultar una guía sobre las expresiones regulares en la segunda página del “torpedo” de esta unidad. Por cierto, podemos obtener el año de fin del período haciendo un combo de extracción + remoción. A continuación tenemos una cadena de pipes dentro de otra! Tomamos “caja_trayectoria”, extraemos “- cuatro dígitos”, removemos “-” y pasamos a número, todo en una operación. df_legisladores_cargos %&gt;% mutate(fin_per = caja_trayectoria %&gt;% str_extract(pattern = &quot;- \\\\d{4}&quot;) %&gt;% str_remove(&quot;- &quot;) %&gt;% as.numeric()) %&gt;% select(caja_trayectoria, fin_per) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria fin_per ## &lt;chr&gt; &lt;dbl&gt; ## 1 &quot;\\nSenador institucional … 2006 ## 2 &quot;\\nDiputado \\n2010- 2014\\… 2014 ## 3 &quot;\\nDiputado \\n2006- 2010\\… 2010 ## 4 &quot;\\nDiputado \\n2002- 2006\\… 2006 ## 5 &quot;\\nDiputado \\n1998- 2002\\… 2002 ## 6 &quot;\\nDiputado \\n1994- 1998\\… 1998 ## 7 &quot;\\nDiputado \\n1990- 1994\\… 1994 ## 8 &quot;\\nDiputado \\n2006- 2010\\… 2010 ## 9 &quot;\\nDiputado \\n2014- 2018\\… 2018 ## 10 &quot;\\nDiputado \\n2010- 2014\\… 2014 ## # … with 1,181 more rows Hay tres tipos de constructos básicos en las expresiones regulares: pronombres o clases de caracteres (como \\\\d), cuantificadores (como {4}) y anclas. Pronombres o clases de caracteres Ya vimos \\\\d, que es equivalente a “un dígito”. Otros pronombres comunes son: [:alpha:] (una letra), \\\\w (un caracter de “palabra”: letra o dígito), \\\\s (un caracter de espacio) y . (cualquier cosa). Por cierto, ¿qué pasa si queremos buscar por algún caracter especial en expresiones regulares, como “.”? vector_prueba &lt;- c(&quot;Ley 20.000.&quot;, &quot;Reglamento 201&quot;) str_extract(vector_prueba, pattern = &quot;\\\\d{2}.&quot;) # esto no es lo que queremos! ## [1] &quot;20.&quot; &quot;201&quot; Debemos “escapar” el caracter, antecediéndolo de “\\”: str_extract(vector_prueba, pattern = &quot;\\\\d{2}\\\\.&quot;) ## [1] &quot;20.&quot; NA (Ejercicio b) Genera una nueva variable en la base, que tenga solo la primera letra del nombre del(la) legislador(a). Tu código: Cuantificadores Vimos que {4} busca exactamente cuatro repeticiones de un caracter en específico. También podemos pedir rangos: {2, 4} (entre dos y cuatro), {2, } (dos o más). Muy utilizados son los cuantificadores * (cero o más) y + (uno o más), que pueden pensarse como abreviaciones para los rangos anteriores. Por ejemplo, obtengamos la primera palabra de “caja_trayectoria”, utilizando el patrón “una o más letras”: df_legisladores_cargos %&gt;% mutate(primera_pal_trayectoria = str_extract(caja_trayectoria, pattern = &quot;[:alpha:]+&quot;)) %&gt;% select(caja_trayectoria, primera_pal_trayectoria) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## caja_trayectoria primera_pal_tra… ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;\\nSenador insti… Senador ## 2 &quot;\\nDiputado \\n20… Diputado ## 3 &quot;\\nDiputado \\n20… Diputado ## 4 &quot;\\nDiputado \\n20… Diputado ## 5 &quot;\\nDiputado \\n19… Diputado ## 6 &quot;\\nDiputado \\n19… Diputado ## 7 &quot;\\nDiputado \\n19… Diputado ## 8 &quot;\\nDiputado \\n20… Diputado ## 9 &quot;\\nDiputado \\n20… Diputado ## 10 &quot;\\nDiputado \\n20… Diputado ## # … with 1,181 more rows (Ejercicio c) Genera una nueva variable en la base, que tenga el distrito que aparece en “caja_trayectoria”. Aparte de cuantificadores, aquí vale la pena utilizar un combo de extracción + remoción. Tu código: Anclas Podemos utilizar anclas para solo capturar las partes iniciales o finales de la cadena. Ancla final ($): df_legisladores_cargos %&gt;% mutate(ult_apellido = str_extract(nombre_comp, pattern = &quot;\\\\w+$&quot;)) %&gt;% select(nombre_comp, ult_apellido) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## nombre_comp ult_apellido ## &lt;chr&gt; &lt;chr&gt; ## 1 Marcos Aurelio Aburt… Ochoa ## 2 Enrique Accorsi Opazo Opazo ## 3 Enrique Accorsi Opazo Opazo ## 4 Enrique Accorsi Opazo Opazo ## 5 Mario Alberto Acuña … Cisternas ## 6 Mario Alberto Acuña … Cisternas ## 7 Mario Alberto Acuña … Cisternas ## 8 René Aedo Ormeño Ormeño ## 9 Sergio Aguiló Melo Melo ## 10 Sergio Aguiló Melo Melo ## # … with 1,181 more rows Ancla inicial (^): df_legisladores_cargos %&gt;% mutate(primer_nombre = str_extract(nombre_comp, pattern = &quot;^\\\\w+&quot;)) %&gt;% select(nombre_comp, primer_nombre) # solo para ver mejor el resultado ## # A tibble: 1,191 x 2 ## nombre_comp primer_nombre ## &lt;chr&gt; &lt;chr&gt; ## 1 Marcos Aurelio Abur… Marcos ## 2 Enrique Accorsi Opa… Enrique ## 3 Enrique Accorsi Opa… Enrique ## 4 Enrique Accorsi Opa… Enrique ## 5 Mario Alberto Acuña… Mario ## 6 Mario Alberto Acuña… Mario ## 7 Mario Alberto Acuña… Mario ## 8 René Aedo Ormeño René ## 9 Sergio Aguiló Melo Sergio ## 10 Sergio Aguiló Melo Sergio ## # … with 1,181 more rows En este caso, el ancla inicial no es necesaria, pero a veces es útil para tomar en cuenta ambigüedades. (Ejercicio d) Genera una nueva base de datos, que tenga variables con el cargo, año de inicio (ya lo hicimos), año de término (ya lo hicimos), distrito (ya lo hicimos) y partido. Con esto listo, habremos conseguido nuestro objetivo inicial. Asegúrate de que las variables tengan los tipos correctos de vectores –utiliza as.numeric() cuando corresponda–. Tu código: Combinar pronombres en expresiones regulares ¿Qué pasa si queremos extraer la cadena “Diputado” o “Diputada”, según corresponda? Podríamos hacer algo como esto, por ejemplo: df_legisladores_cargos %&gt;% mutate(cadena = str_extract(caja_trayectoria, &quot;Diputad\\\\w&quot;)) %&gt;% select(cadena) ## # A tibble: 1,191 x 1 ## cadena ## &lt;chr&gt; ## 1 &lt;NA&gt; ## 2 Diputado ## 3 Diputado ## 4 Diputado ## 5 Diputado ## 6 Diputado ## 7 Diputado ## 8 Diputado ## 9 Diputado ## 10 Diputado ## # … with 1,181 more rows Funciona bien, pero tal vez es demasiado general. A veces queremos ser más específicos/as y decir, con expresiones regulares, la cadena que comience con “Diputad” y siga con “a” u “o”. Podemos hacer esto de la siguiente forma: df_legisladores_cargos %&gt;% mutate(cadena = str_extract(caja_trayectoria, &quot;Diputad[ao]&quot;)) %&gt;% # caracteres permitidos select(cadena) ## # A tibble: 1,191 x 1 ## cadena ## &lt;chr&gt; ## 1 &lt;NA&gt; ## 2 Diputado ## 3 Diputado ## 4 Diputado ## 5 Diputado ## 6 Diputado ## 7 Diputado ## 8 Diputado ## 9 Diputado ## 10 Diputado ## # … with 1,181 more rows Fíjate en el siguiente ejemplo. Estaríamos capturando solo los elementos número 2 y 3. c(&quot;Diputación&quot;, &quot;Diputado&quot;, &quot;Diputada&quot;) %&gt;% str_detect(&quot;Diputad[ao]&quot;) ## [1] FALSE TRUE TRUE (Ejercicio e) Genera una nueva base de datos, que tenga variables con el cargo, año de inicio (ya lo hicimos), año de término (ya lo hicimos), distrito (ya lo hicimos) y partido. Con esto listo, habremos conseguido nuestro objetivo inicial. Asegúrate de que las variables tengan los tipos correctos de vectores –utiliza as.numeric() cuando corresponda–. Tu código: (Ejercicio f) Carguemos esta nueva base, que tiene la caja de antecedentes para cada legislador (noten cómo cambia la unidad de análisis de la base). df_legisladores &lt;- read_csv(&quot;datos/df_legisladores.csv&quot;) ## ## ── Column specification ───────────── ## cols( ## nombre_comp = col_character(), ## id = col_double(), ## caja_antecedentes = col_character() ## ) head(df_legisladores$caja_antecedentes) ## [1] &quot;\\n Nombre: Marcos Aurelio Aburto Ochoa\\n Nacimiento: \\n25 de Mayo de 1916\\n\\nValdivia\\n Profesión: Abogado&quot; ## [2] &quot;\\n Nombre: Enrique Accorsi Opazo\\n Nacimiento: \\n17 de Agosto de 1948\\n\\nSantiago\\n Profesión: Médico&quot; ## [3] &quot;\\n Nombre: Mario Alberto Acuña Cisternas\\n Nacimiento: \\n26 de Septiembre de 1951\\n\\n\\n Profesión: Ingeniero Agrónomo&quot; ## [4] &quot;\\n Nombre: René Aedo Ormeño\\n Nacimiento: \\n4 de Febrero de 1960\\n\\n\\n Profesión: Médico Cirujano&quot; ## [5] &quot;\\n Nombre: Sergio Aguiló Melo\\n Nacimiento: \\n9 de Febrero de 1953\\n\\nSantiago\\n Profesión: Ingeniero Comercial&quot; ## [6] &quot;\\n Nombre: Raúl Florcita Alarcón Rojas\\n Nacimiento: \\n15 de Octubre de 1945\\n\\n\\n Profesión: Profesor normalista y Músico&quot; Genera variables para fecha de nacimiento y profesión. Calcula la edad actual de cada legislador(a). Utiliza una fórmula sencilla, 2019 - año de nacimiento. Obtén la distribución de edad para los/as diputados/as del período actual. Tip: para esto debes juntar las dos bases; puedes utilizar left_join(). (Difícil) Divide la distribución anterior por coalición. "],["texto-libros.html", "06C - Descarga de libros", " 06C - Descarga de libros Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos en RStudio Cloud con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). El siguiente código se utilizó para descargar los libros del script 06A: # Cargar paquetes ---- library(tidyverse) # install.packages(&quot;tidytext&quot;) library(tidytext) library(stopwords) # install.packages(&quot;gutenbergr&quot;) library(gutenbergr) # descargar libros de dominio público desde Project Gutenberg # Leviathan ---- leviathan &lt;- gutenberg_download(3207, strip = T) leviathan2 &lt;- leviathan %&gt;% # eliminar las lineas sin info (espacios o separadores) filter(!str_detect(text, &quot;^[\\\\s[:punct:]]*$&quot;)) %&gt;% # generar variable con capítulos mutate(chapter = cumsum(str_detect(text, &quot;(CHAPTER )&quot;)), line = 1:nrow(.)) %&gt;% # incluir información sobre el libro mutate(author = &quot;Thomas Hobbes&quot;, book = &quot;Leviathan&quot;) %&gt;% # reordenar columnas select(author, book, gutenberg_id, chapter, line, text) write_csv(leviathan2, &quot;datos/leviathan.csv&quot;) # On Liberty ---- on_liberty &lt;- gutenberg_download(34901, strip = T) on_liberty2 &lt;- on_liberty %&gt;% # eliminar las lineas sin info (espacios o separadores) filter(!str_detect(text, &quot;^[\\\\s[:punct:]]*$&quot;)) %&gt;% # generar variable con caps. (es imposible no contar las del índice usando expr. regulares, por eso las arreglo ex post) mutate(text = str_remove_all(text, &quot;(&lt;i&gt;)|(&lt;/i&gt;)&quot;), chapter = cumsum(str_detect(text, &quot;(CHAPTER )&quot;)), line = 1:nrow(.)) %&gt;% mutate(chapter = chapter - 5) %&gt;% mutate(chapter = if_else(chapter &lt; 0, 0, chapter)) %&gt;% # incluir información sobre el libro mutate(author = &quot;John Stuart Mill&quot;, book = &quot;On Liberty&quot;) %&gt;% # reordenar columnas select(author, book, gutenberg_id, chapter, line, text) write_csv(on_liberty2, &quot;datos/on_liberty.csv&quot;) # A Vindication of the Rights of Women ---- rights_of_women &lt;- gutenberg_download(3420, strip = T) rights_of_women2 &lt;- rights_of_women %&gt;% # eliminar las lineas sin info (espacios o separadores) filter(!str_detect(text, &quot;^[\\\\s[:punct:]]*$&quot;)) %&gt;% # generar variable con caps. (es muy difícil no contar las del índice usando expr. regulares, por eso las arreglo ex post) mutate(text = str_remove_all(text, &quot;(&lt;i&gt;)|(&lt;/i&gt;)&quot;), chapter = cumsum(str_detect(text, &quot;(CHAPTER )&quot;)), line = 1:nrow(.)) %&gt;% mutate(chapter = chapter - 13) %&gt;% mutate(chapter = if_else(chapter &lt; 0, 0, chapter)) %&gt;% # incluir información sobre el libro mutate(author = &quot;Mary Wollstonecraft&quot;, book = &quot;A Vindication of the Rights of Woman&quot;) %&gt;% # reordenar columnas select(author, book, gutenberg_id, chapter, line, text) write_csv(rights_of_women2, &quot;datos/rights_of_women.csv&quot;) "],["part-minería-de-datos-y-r-avanzado.html", "(PART) Minería de datos y R avanzado", " (PART) Minería de datos y R avanzado "],["herr-prog.html", "07A - Herramientas de programación Funciones personalizadas y control de flujo Iteraciones con purrr Aplicación 1: programas de candidaturas Aplicación 2: varios archivos Excel", " 07A - Herramientas de programación Si quieres correr estos scripts localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (07A, 07B): tidyverse, pdftools. library(tidyverse) library(readxl) # se instala con el tidyverse ## install.packages(&quot;pdftools&quot;) library(pdftools) Funciones personalizadas y control de flujo Supongamos que queremos obtener el rango de un vector numérico (la diferencia entre su valor máximo y su valor mínimo) vector_num_prueba &lt;- c(1, 7, 3, 4, 9, 8) max(vector_num_prueba) - min(vector_num_prueba) ## [1] 8 Podemos generalizar esto creando una “receta”, en otras palabras, una función. f_rango &lt;- function(x){ valor &lt;- max(x) - min(x) return(valor) } f_rango(vector_num_prueba) ## [1] 8 Lo bueno de esta función que creamos, f_rango() es que es generalizable: f_rango(c(29, 3, 4)) ## [1] 26 midwest &lt;- midwest f_rango(midwest$percadultpoverty) ## [1] 41.37396 ¿Qué pasa si aplicamos nuestra función a un vector de caracteres? vector_car_prueba &lt;- c(&quot;Manzana&quot;, &quot;Pera&quot;, &quot;Uva&quot;, &quot;Naranja&quot;, &quot;Plátano&quot;, &quot;Sandía&quot;) f_rango(vector_car_prueba) # devuelve un error Tal vez queremos contar los caracteres de cada elemento y calcular el rango considerando esas longitudes. Podemos generalizar más nuestra función ocupando control de flujo (if/else) f_rango_gen &lt;- function(x){ if (is.character(x)) { # si es que es el vector es de caracteres ... valor &lt;- max(nchar(x)) - min(nchar(x)) } else { # en cualquier otro caso... valor &lt;- max(x) - min(x) } return(valor) # lo que queremos que devuelva la función } f_rango_gen(vector_car_prueba) # ahora funciona con el vector de caracteres ## [1] 4 f_rango_gen(vector_num_prueba) # sigue funcionando con el vector numérico ## [1] 8 Iteraciones con purrr Las iteraciones permiten repetir tareas en series de elementos. En el tidyverse, el paquete purrr ofrece iteración funcional, que es lo que aprenderemos aquí. Supongamos que tenemos una lista con múltiples vectores y queremos obtener el rango de cada uno: lista_vectores &lt;- list( v1 = c(89, 3, 4), v2 = c(5, 98, 1), v3 = c(98, 3, 190) ) Podemos hacer algo como esto para el primer vector: f_rango(lista_vectores[[1]]) ## [1] 86 f_rango(lista_vectores[[&quot;v1&quot;]]) # lo mismo ## [1] 86 Entonces, podríamos obtener los rangos así: f_rango(lista_vectores[[1]]) ## [1] 86 f_rango(lista_vectores[[2]]) ## [1] 97 f_rango(lista_vectores[[3]]) ## [1] 187 Si queríamos los resultados en un vector: vector_resultados &lt;- c( f_rango(lista_vectores[[1]]), f_rango(lista_vectores[[2]]), f_rango(lista_vectores[[3]]) ) vector_resultados ## [1] 86 97 187 Bien, ¿pero qué pasa si tenemos 500 elementos en vez de 3? No queremos hacer copy-paste 500 veces. Para esto es que existen las iteraciones: vector_resultados2 &lt;- map_dbl( .x = lista_vectores, # objeto en cuyos elementos queremos iterar .f = ~ f_rango(.x) # en el contexto de la iteración, cada elemento es .x ) map_dbl() significa que el resultado es un vector numérico. También está map_chr(), para tener de resultado un vector de caracteres. Mientras tanto, map_dfr() devolverá un data frame. map() es la función más general, simplemente devolverá una lista. Por otro lado, walk() no devolverá nada, pero sí iterará en los elementos del objeto que le pasemos (esto puede ser útil, lo veremos en las aplicaciones). (Ejercicio a) Genera la iteración anterior con map() en vez de map_dbl(). ¿Qué cambia? Aplicación 1: programas de candidaturas Cargar texto desde pdfs y limpiarlo En “datos/programas_gob_rm_2021” tenemos los programas para las candidaturas a la Gobernación Regional de la RM, obtenidos desde el sitio web del Servel. Vamos a obtener todos sus textos y dejarlos en una base tidy para el análisis. Comencemos obteniendo el texto del programa de Maltés, gracias al paquete pdftools: texto_maltes &lt;- pdftools::pdf_text(&quot;datos/programas_gob_rm_2021/13_PABLO_ANTONIO_ANDRES_MALTES_BISKUPOVIC.pdf&quot;) texto_maltes ## [1] &quot;Pablo Maltés Biskupovic\\nGOBERNADOR REGIÓN METROPOLITANA\\n PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\n&quot; ## [2] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nINTRODUCCIÓN\\n E\\n sta propuesta de programa surge del convencimiento social, político\\n y cultural de que es posible construir una convivencia y una forma\\n de vida más justa y digna para los habitantes de la Región Metropo-\\n litana (RM), sin distinción de ningún tipo.\\n Estamos convencidos que nuestra diversidad y multiculturalidad son una for-\\n taleza, como también una motivación para crecer y desarrollarnos de forma\\n equilibrada, con igualdad de oportunidades para todas, todos y todes.\\n Hoy vivimos un proceso de cambio que se ha logrado gracias a la valentía y he-\\n roísmo de miles jóvenes, estudiantes, pobladores, trabajadoras y trabajadores,\\n entre otros actores sociales que por décadas han visto frustrados sus anhelos\\n de tener una vida más justa en diferentes ámbitos, como la salud, la educación,\\n el trabajo, la seguridad social, la vivienda, el acceso a la cultura, la seguridad\\n ciudadana, además de una infancia con equidad y una vejez con dignidad.\\n Nuestra propuesta para elaborar una Estrategia Regional de Desarrollo con-\\n sidera como una cuestión insoslayable la participación ciudadana transversal,\\n rigurosamente democrática.\\n Creemos que es urgente dinamizar la economía de la región, garantizar la\\n seguridad ciudadana y la paz en los barrios y poblaciones liberándolos de la\\n maldición de las drogas, desarrollar acciones concretas por la protección del\\n medioambiente y promover con eficacia la cultura y la educación como ejes\\n para una mejor calidad de vida.\\n 2\\n&quot; ## [3] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nII\\nESTRATEGIA REGIONAL DE DESARROLLO:\\nUNA REGIÓN PARA EL SIGLO XXI\\n P\\n ara abordar en propiedad la idea de una Región para el Siglo XXI\\n hay que plantearse claramente lo que significa implementar para el\\n período 2021 – 2031 un Nuevo Plan de Desarrollo para la Región\\n Metropolitana. Este plan no puede ser otra cosa que la carta de navegación,\\n que guíe las acciones y las políticas públicas que debemos impulsar como\\n Gobierno Regional. Todos estos planes y programas esperamos construirlos\\n conjuntamente con la ciudadanía a través de un sistema de consulta ciudadana\\n permanente. Buscaremos de este modo un diseño participativo y responsable,\\n de acuerdo con las dificultades y restricciones que enfrentamos debido a la\\n crisis sanitaria.\\n Solo así vamos a saber bien en donde están las debilidades y las fortalezas\\n que nos permitirán poner los énfasis en los problemas que debemos resolver,\\n como también en nuestras prioridades y urgencias.\\n 3\\n&quot; ## [4] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nIII\\nEJES PROGRAMÁTICOS\\n a) ACCESO A LA CULTURA Y LAS ARTES\\n b) TRABAJO Y ECONOMÍA COOPERATIVA\\n c) MEDIO AMBIENTE Y SOCIEDAD AMABLE\\n d) DIVERSIDAD E INCLUSIÓN\\n e) PROTECCIÓN SOCIAL\\n f) MOVILIDAD Y TRANSPORTE\\n g) LUCHA CONTRA EL NARCOTRÁFICO\\n h) GOBIERNO DE LA CIUDAD,TRANSPARENCIA\\n Y ALIANZA CON MACROCOMUNAS\\n 4\\n&quot; ## [5] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\na) ACCESO A LA CULTURA Y LAS ARTES\\n Será urgente y una prioridad poner a la cultura y las artes como uno de los pilares de\\n nuestro programa de trabajo. De esta forma impulsaremos iniciativas desde el Gobier-\\n no Regional para movilizar y disponer de más recursos para que creadores, gestores\\n y artistas locales como también para que los centros culturales de barrios, comunas y\\n localidades aisladas tengan el apoyo necesario para el desarrollo de su gestión y trabajo.\\n La cultura no puede ser el privilegio de una élite y tampoco puede estar monopolizada\\n solo por algunas pocas instituciones. Nos interesa democratizar el acceso a la población\\n al goce de la creación y empatizar con artistas que tengan una verdadera vocación social.\\n El arte y la comunidad deben ser una amalgama productiva y alegre.\\n Impulsaremos en el ámbito de la formación escuelas-talleres de capacitación para el\\n desarrollo de proyectos con impacto social positivo en el ámbito de la creación. Es im-\\n portante que tanto artistas como gestores tengan formación y capacitación en el diseño\\n y gestión de sus proyectos.\\n Desarrollaremos el primer laboratorio e incubadora de proyectos creativos en conjunto\\n con la CORFO para el impulso de la industria y la gestión con fines de desarrollo comu-\\n nitario y local.\\n Crearemos el primer Registro Regional de Creadores y Trabajadores del Sector Cultural,\\n que permitirá por un lado realizar un censo de la actividad creativa, artística, patrimonial\\n y cultural en toda su diversidad en la región. Este proyecto permitirá abrir nuevos polos\\n y espacios de desarrollo.\\n Impulsaremos decididamente un plan de recuperación de teatros patrimoniales en la Re-\\n gión Metropolitana, en conjunto con el Consejo de Monumentos Nacionales y el Servicio\\n Nacional del Patrimonio Cultural.\\n 5\\n&quot; ## [6] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\n En el ámbito de la comunicación, vamos a fortalecer el rol de las radios comunitarias a\\n través de la búsqueda de financiamiento para nuevos proyectos de orden digital.\\n De la misma forma, apoyaremos a canales locales de televisión acompañando sus pro-\\n yectos y nuevas fórmulas de financiamiento a través de Fondos Regionales de Cultura y\\n la Secretaría Regional Ministerial del Ministerio de las Culturas, las Artes y el Patrimonio.\\n Potenciaremos certámenes para la diversidad cultural, la tradición y la expresión identi-\\n taria por zonas de la Región Metropolitana como también el fomento de espacios para\\n artistas de calle.\\n Potenciaremos toda la red de creadores y artes a nivel regional como una expresión de\\n diversidad e inclusión de diferentes expresiones artísticas y sociales como una comuni-\\n dad regional.\\nb) TRABAJO Y ECONOMÍA COOPERATIVA\\n El desempleo es una realidad que básicamente golpea a las comunas más pobres y a\\n una clase media desprotegida por el Estado. Por esta razón, trabajaremos en incentivar\\n la economía local de las comunas más desfavorecidas que se han visto perjudicadas por\\n la crisis sanitaria.\\n Fomentaremos el emprendimiento colaborativo y creativo en el máximo de espacios\\n posibles como las juntas de vecinos, organizaciones comunitarias, centros de adultos\\n mayores, establecimientos deportivos, ferias libres y el comercio local que lucha contra\\n los grandes monopolios.\\n 6\\n&quot; ## [7] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nUna economía colaborativa y circular a escala local debe ser fomentada por el Gobierno\\nRegional con planes concretos de acuerdo con las especificidades y potencialidades de\\ncada comuna y zonas de la región.\\nConstruir una economía cooperativa y asociativa entre todos los actores sociales de\\nla comunidad será una prioridad como eje de nuestro Plan Estratégico de Desarrollo.\\nPotenciar planes para reforzar el teletrabajo será una misión importante como tam-\\nbién flexibilizar horarios de algunas labores especialmente para cientos de mujeres que\\nrealizan trabajos en sus casas y deben estar al cuidado además de sus grupos familiares.\\nNo apoyamos una economía en base solo a la competencia despiadada y el enrique-\\ncimiento de pequeños grupos privilegiados. Nuestra apuesta consistirá en potenciar al\\nmáximo una economía creativa y local en base al desarrollo e impulso de cooperativas\\nde trabajo solidario.\\nTenemos claro que Santiago sigue siendo la capital y que para apoyar la recuperación\\neconómica del país se necesita una ciudad pujante. Sin embargo, eso debe estar en coor-\\ndinación con el Gobierno Central para que el máximo de empresas productivas en su\\nmayoría del Gran Santiago esté al servicio de la población con planes de reinserción y\\nprotección social que apunten a una mejor calidad de vida de todos.\\nImpulsaremos iniciativas para fomentar el Comercio Justo y la vinculación con proyec-\\ntos que impacten positivamente en la economía, en el gobierno local y cada provincia\\nde la región a través de alternativas como la Banca Ética. Para ello realizaremos una\\nprofunda capacitación en el diseño y desarrollo de proyectos a escala de cada comuna\\nde la región. Nuestra tarea será de cara al siglo XXI, construir Polos de Desarrollo Eco-\\nnómicos Locales en la RM.\\n 7\\n&quot; ## [8] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nc) MEDIO AMBIENTE Y SOCIEDAD AMABLE\\n Para vivir en un entorno saludable y gozar de una calidad de vida que haga feliz a todos\\n los habitantes sin exclusión alguna debemos trabajar y potenciar todo tipo de políticas\\n ambientales para hacer de la Región Metropolitana una Sociedad Amable. Este concep-\\n to no se puede lograr sin políticas públicas que integren en la vida de los ciudadanos\\n una conciencia más social, más inclusiva, de autocuidado y de protección del medio\\n ambiente y el ecosistema natural y cultural.\\n Gestionaremos un plan de fiscalización a los vertederos que existen en la RM, como\\n también un levantamiento de los estudios de impacto ambiental en nuestra región. Es\\n fundamental que tengamos diagnósticos actualizados en estas materias.\\n Las autoridades deben estar al tanto de la realidad medioambiental y la población infor-\\n mada. Este no debe ser un secreto solo para las instituciones o quienes hacen acuerdos\\n económicos con el sector privado. No, todos los ciudadanos deben conocer a fondo\\n la realidad medioambiental en la que viven, y las medidas que están llevando a cabo\\n quienes dirigen las instituciones.\\n Impulsaremos una cultura medioambiental que será parte de nuestras prioridades y\\n programas y que también deberá ser transversal a todas las instituciones de la región,\\n tanto públicas como privadas.\\n El reciclaje de desechos y basura también será parte de nuestras prioridades para\\n una mejor descontaminación. Para ello realizaremos estudios y abordaremos nuevas\\n propuestas de alta tecnología para el reciclaje de desechos y basura. También poten-\\n ciaremos puntos de reciclaje en los barrios y juntas vecinales juntamente con planes\\n educativos.\\n Todos los servicios públicos y los establecimientos educacionales deberán tener pun-\\n 8\\n&quot; ## [9] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\ntos obligatorios de reciclaje como también estándares de eficiencia energética.\\nImpulsaremos en conjunto con el Ministerio de Educación un plan para implementar\\nuna Educación Ambiental en todos los liceos públicos de la RM.Trabajaremos en una\\nconciencia ambiental desde la niñez.\\nPotenciaremos el desarrollo de áreas verdes en todas las comunas y los barrios\\ncomo también planes de reforestación, especialemente árboles nativos, que sabemos\\nmejoran el ecosistema.\\nGeneraremos nuevos parques metropolitanos que apunten a cubrir a las zonas ex-\\ncluidas de nuestra región.\\nTodas las comunas, o al menos algunas macrozonas definidas territorialmente, de-\\nberán contar con Parques Temáticos y Culturales como propuesta de una mejora\\ncalidad de vida y educación ambiental.\\nEstimularemos el uso de energías verdes para ser implementadas en nuestros barrios.\\nTendremos que regular y fiscalizar rigurosamente los planos reguladores de las co-\\nmunas. No podemos permitir guetos de altura que van en desmedro de la calidad de\\nvida, la seguridad y la convivencia.\\nFomentaremos el reconocimiento de barrios y zonas típicas para la recuperación de\\nespacios históricos. Hay muchas zonas y edificaciones de gran valor arquitectónico\\nque se encuentran en malas condiciones y hay que buscar las fórmulas de gestión y\\nfinanciamiento para recuperarlas.\\nDesarrollaremos en todas las comunas planes para la implementación vecinal de\\nhuertos urbanos que embellezcan el barrio y conecten a los vecinos con formas de\\nabastecimiento local.\\n 9\\n&quot; ## [10] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nd) DIVERSIDAD E INCLUSION\\n Nuestra región tiene una gran diversidad cultural y distintas identidades que van desde\\n zonas rurales cordilleranas como el Cajón del Maipo y Pirque, hasta zonas urbanas y\\n campestres.\\n Sin embargo, también Santiago como capital es cada día más cosmopolita y concentra\\n a una población migrante que ya es parte de nuestra convivencia diaria, la que a su vez\\n también se ha insertado en distintas comunas del país, dando vida a un nuevo mapa so-\\n cial y cultural que debemos potenciar en todo sentido.\\n Cuando hablamos de diversidad tenemos también que pensar en las diferencias de gé-\\n nero y las comunidades que integran por ejemplo al mundo homosexual, la comunidad\\n trans, queer, bisexuales, lesbianas y otras. Todos segmentos que hoy tienen más voz,\\n mayor influencia y que han hecho respetar sus derechos en forma legítima. Con todes\\n elles trabajaremos.\\n Me preocuparé de diseñar programas locales con enfoque de género y fomentaré la\\n creación de Oficinas de la Diversidad en todos los gobiernos locales que entren en\\n coordinación directa con los distintos departamentos de la diversidad que tienen los\\n municipios y estimular la presencia de estos programas en los municipios que aún no\\n lo tienen.\\n Crearemos en las comunas espacios para promover políticas impulsadas por mujeres en\\n distintos ámbitos como derechos, violencia, trabajo comunitario, enseñanza, etc.\\n En este contexto ampliaremos la prevención en contra de cualquier forma de violencia\\n de género. Estableceremos las competencias necesarias para fortalecer el trabajo de\\n asistencia.\\n Crearemos también programas y proyectos para la integración concreta de los pueblos\\n 10\\n&quot; ## [11] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\n originarios a la convivencia local y nacional. Apostamos por una nación plurinacional y\\n creemos que la incorporación de nuestras culturas ancestrales en nuestra vida coti-\\n diana se debe realizar en paz, con igualdad de derechos y nuevas oportunidades.\\n Una cultura orientada al respeto de los Derechos Humanos también será fomentada\\n por el Gobierno Regional. Para ello motivaré un trabajo transversal en todas las áreas,\\n empezando por los servicios públicos y los gobiernos locales.\\n Trabajaremos incesantemente para promover al máximo una cultura por los Dere-\\n chos de los Niños, Niñas y Adolescentes en la Región Metropolitana a través de los\\n barrios y juntas vecinales.\\n Desarrollaremos planes de inserción para niños vulnerados en sus derechos que son\\n víctimas de la pobreza y el abandono en coordinación con organizaciones responsa-\\n bles y de conducta ética irreprochable.\\n Potenciaremos iniciativas como la adopción de forma responsable con altos estánda-\\n res de apoyo por parte de las instituciones pertinentes.\\n No permitiremos ningún tipo de forma de violencia en contra de la niñez, como el\\n trabajo y la explotación infantil. Una infancia feliz será otro de nuestros lemas y prin-\\n cipios que guiarán nuestra labor.\\ne) PROTECCIÓN SOCIAL\\n La Pandemia que vivimos producto del COVID -19 ha generado problemas graves\\n en diversos ámbitos, pero fundamentalmente en el mundo del trabajo. La cantidad\\n de gente que puede hacer teletrabajo no alcanza al 30% y se concentra en las co-\\n munas más ricas del sector oriente.\\n 11\\n&quot; ## [12] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nLa pandemia deja en evidencia la desigualdad y debemos generar mayor empleabi-\\nlidad y un retorno a las fuentes laborales con más protección sanitaria y mejor\\ninformación a la comunidad.\\nDesarrollaremos planes de trabajo realistas como Gobierno Regional en el marco\\nde la pandemia.\\nApoyaremos a la Red Pública de Salud con proyectos para mejorar su infraestructu-\\nra, además del necesario abastecimiento de materiales e insumos para la población.\\nUn fuerte plan de información a la comunidad en cooperación con el aparato pú-\\nblico de salud será necesario priorizar para que la atención primaria cuente con la\\nconfianza y la colaboración de la comunidad y viceversa.\\nApoyaremos e implementaremos un plan de control sanitario para todo el comer-\\ncio local y los barrios como también para todos los establecimientos educacionales.\\nLos sectores más vulnerables y la población de mayor riesgo deben estar en la pri-\\nmera prioridad, pero no podemos permitir que nadie quede excluido de una obli-\\ngación que es del Estado. Nos comprometemos a proteger nuestra salud pública y\\na sus trabajadores.\\nLlevaremos también un plan para la salud mental de la población que se ha visto\\nperjudicada por la pandemia. Para ellos trabajaremos con universidades chilenas\\nque busquen ampliar su conocimiento y práctica en las comunas de la RM. Pondre-\\nmos énfasis en la protección de las personas en situación de calle, implementando\\ny potenciando planes que lleven tratamientos de salud digna en todos sus aspectos\\ny así también como el acceso a la vivienda, educación, trabajo y justicia.\\nDe acuerdo con los datos que entrega la Cámara Chilena de la Construcción\\n 12\\n&quot; ## [13] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\n (CCHC), en la Región Metropolitana existiría un déficit de 314.488 viviendas, lo\\n que representa un 11% respecto de su población y un 42,5% respecto del déficit\\n total nacional. Esta realidad debemos cambiarla y para eso nos comprometemos a\\n desarrollar un Programa de Vivienda para los sectores y familias más vulnerables con\\n la finalidad de erradicar progresivamente los campamentos y la precariedad habita-\\n cional creciente. Los campamentos se han duplicado en los ultimos tres años en la\\n Región Metropolitana\\nf) MOVILIDAD Y TRANSPORTE\\n El transporte es sin duda un problema estructural y uno de los mayores desafíos\\n de un Gobierno Regional.\\n Tenemos problemas con el creciente parque automotriz, con el Transantiago y la\\n congestión en el Metro de Santiago que traslada en un día laboral a más de 2 mi-\\n llones de habitantes entre los casi 20 millones de viajes que se realizan en la región\\n en un solo día. Son muchas veces largas horas de viajes que deterioran la calidad\\n de vida de las personas y disminuye su energía en sus espacios de trabajo y en la\\n convivencia familiar.\\n Nuestro compromiso en esta área será en una primera fase aportar en conjunto\\n con el Ministerio de Transporte a una mejor coordinación de las diferentes ofici-\\n nas y servicios públicos de transporte con el fin de mejorar y optimizar todo tipo\\n de traslados para la población.\\n Revisaremos y haremos un diagnóstico del mapa vial de nuestras comunas a fin de\\n 13\\n&quot; ## [14] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\n construir nuevas y modernas propuestas en torno al diseño de calles y carreteras\\n de la región.\\n En esta misma línea impulsaremos la creación de un tren rápido que mejore toda\\n la red de enlace entre la Región Metropolitana y la Quinta Región, ampliando la\\n conectividad con el Metro de Santiago y todas las líneas del Metro de Valparaíso.\\n Impulsaremos una cultura del uso de la bicicleta en toda la región y potenciaremos\\n la creación de ciclovías en todos los barrios para motivar e instalar esta nueva\\n forma de transporte.\\n En ese sentido, la creación de un nuevo Plan Maestro de Ciclovías para la Región\\n Metropolitana será fundamental para dar continuidad a una política urbana que\\n fortalezca el uso de la bicicleta como medio de transporte.\\ng) LUCHA CONTRA EL NARCOTRÁFICO\\n Si bien la seguridad no es un tema que el gobernador debe asumir en sí mismo,\\n sentimos la obligación de involucrarnos porque finalmente el desarrollo social y la\\n cohesión social de una ciudad tiene que ver con tener una ciudad más segura. Es\\n difícil obviar hoy los funerales narcos, con balazos al aire, los fuegos de artificio y\\n estridencia; las balas locas y el poder que han adquirido las bandas de narcotrafican-\\n tes en distintas poblaciones de la Región Metropolitana. Esa realidad es pan de cada\\n día para una parte importante de la población regional y, pese a las advertencias de\\n diversos actores que han levantado la voz, es una situación que se sigue\\n escondiendo bajo la alfombra, al punto que hay zonas de\\n 14\\n&quot; ## [15] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\nla RM, callejuelas, poblaciones, donde las policías no entran, a pesar de las denuncias\\no evidencias.\\nNo creemos que el incremento de penas sea una solución. Hoy quienes forman parte\\nde estas asociaciones delictivas y quienes están detrás de las balaceras que provocan\\nterror en la población son en su mayoría jóvenes marginados del Gran Santiago y, por\\nconsiguiente, sus familias, dotadas de mujeres y niños quienes en contraron en el\\ncrimen organizado lo que el Estado y el modelo económico les negó. Remitirse a\\nencarcelar más pobres que la pobreza no solo se mide en ingresos económicos no es\\natacar el problema con eficacia, como tampoco lo son los recuentos policiales con la\\nestadística anual de droga incautada. Está visto que la solución del problema no pasa\\npor ahí.\\nEl narcotráfico es una pandemia, pero peor aún, es una dictadura porque esclaviza a\\nlos consumidores y a niños y jóvenes que trabajan para ellos. Son grupos con alto\\npoder de fuego, que intimidan a la gente, que no conversan y solo disparan para hacer\\ncrecer su negocio, provocando un daño irreparable a nuestro tejido social ya tan\\ndañado, pero también a nuestra democracia que tanto nos cuesta construir día a día.\\nPara arrebatarles el poder a los narcos hay que ganarles la batalla en las poblaciones con\\nuna mayor presencia del Estado, a través de programas de reinserción social,\\nfomento a los pequeños emprendedores, mejor educación, mayor cantidad de áreas\\nverdes y, en definitiva, recuperando espacios y la legitimidad perdida. Todo eso de la\\nmano con un fuerte combate a grupos o bandas que intimidan a la gente y se\\napropian del territorio. En las poblaciones pocos creen en la acción del Estado y esa\\ncredibilidad se debe recuperar, para así juntos desenredar la madeja tejida por el\\nnarcotráfico.\\n 15\\n&quot; ## [16] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\n Además, desde el espacio de la Gobernación se deben dar señales potentes para lla-\\n mar a las autoridades pertinentes a poner también el acento en el lavado de activos,\\n donde está la verdadera cabeza del problema.\\n Para construir un tejido social digno, debemos como Estado, trabajar en políticas y\\n programas públicos desde y para la gente. Cualquier tipo de exclusión siempre ter-\\n minará por convertirse en una amenaza. Por ello, debemos combatir toda forma de\\n desigualdad. Solo así avanzaremos responsablemente para tener una región alegre,\\n viva y democrática.\\nh) GOBIERNO DE LA CIUDAD,TRANSPARENCIA Y ALIANZAS\\n Necesitamos enfocar el desarrollo regional especializando las medidas de acuerdo\\n a la gobernabilidad de la ciudad de Santiago en equilibrio con las demás realidades\\n urbanas y rurales de las comunas. Gobernabilidad regional y desarrollo equilibrado\\n y sinérgico para las personas y sus comunidades. Hoy las unidades metropolitanas\\n abarcan todos los recursos, dejando fuera del radio de acción a comunas que están\\n en el borde o comunas rurales.\\n Por tal razón es de gran trascendencia un Plan de Ordenamiento Territorial que\\n considere este propósito, impulsando el dialogo productivo y transparente entre\\n los intereses de los distintos actores que deben participar, para que prevalezca el\\n interés público como eje rector de esta importante política pública. Hay que re-\\n conocer los intereses de cada actor que está involucrado y los objetivos que tiene\\n 16\\n&quot; ## [17] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\ncada cual. Propongo una declaración de intereses donde privados y actores publi-\\ncos clarifiquen lo que buscan en cada proyecto o intervencion que realicen. Hoy\\nlas inmobiliaras logran apropiarse de paños y construcciones haciendo reuniones\\npor el lado, lo que ha significado que en la actualidad practicamente no existan\\npaños privados en toda la región para que el Estado por ejemplo realice viviendas\\nsociales. Esto ha sido producto de acuerdos entre cuatro paredes de empresarios\\ny tambien municipios. Una ciudad distinta parte por la transparencia y por la capa-\\ncidad de reinventarse y mostrar los intereses de cada cual\\nEl control del suelo metropolitano es un verdadero problema. El hecho de los\\nprivados tengan control de todos los paños privados hace que los precios hayan\\nsubido sustancialmente incluso en las comunas intrametropolitanas, que tenían\\nprecios accesibles para la gente comun y corriente. Hoy la cosntrucción de nuevas\\nviviendas está sometida a un monopoliio privado que eleva al doble o al triple los\\nprecios de los terrenos, lo que redunda en un encarecimiento de la vida para todos\\nlos capitalinos.\\nAdemás de todo eso, las inmobiliarias con la complicidad de muchos municipios,\\nconstruyen en lugares donde no hay redes de agua potable, luminarias y falta de\\nservicios. El desarrollo de cualquier conjunto habitacional social o privado debe\\ncontemplar la integralidad de todos los factores y no solamente la casa en sí mis-\\nma. Ahí también hay un tema que queremos corregir.\\nDebemos reconocer y fortalecer la relación del gobierno regional con las munici-\\n 17\\n&quot; ## [18] &quot; Pablo Maltés Biskupovic\\n GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE\\n 2021 – 2025\\npalidades para el desarrollo equitativo de los territorios e impulsar especialmente\\nplanes y programas supracomunales, considerando el rol de las asociaciones mu-\\nnicipales que se encuentren funcionando o que se conformen en este proceso. El\\nplan de ordenamiento territorial no debe contemplar contactos por separado con\\nlas municipalidades, sino debe ser a partir de grupos de municipios que integren\\nterritorios de manera de fortalecer y desarrollar las macrozonas urbanas, lo que\\nademás hará más eficiente la entrega de recursos.\\nPara apoyar el desarrollo de estos planes y programas se instalarán fondos re-\\ngionales que buscarán asociar recursos públicos centrales, comunales y privados\\ncomo parte de los instrumentos del Plan de Desarrollo Regional. Necesitamos po-\\nlos de desarrollo, trabajo y empleo decente en los territorios. Los microproyectos\\nque hoy están en poder de los Cores deben dar cabida a macroproyectos que por\\nejemplo generen empleabilidad, trabajo, desarrollo sustentable, emprendimiento.\\nLa idea de proyecto que se consigue a través de los cores solo se presta para\\nalianzas politicas y financiamiento de candidaturas locales que no sirven de mucho\\npara el desarrollo de la ciudad.\\n 18\\n&quot; Si miramos el pdf o el texto que nos devuelve, veremos que hay un tema con los guiones que separan palabras en los saltos de línea. Esto es bastante común en textos diagramados para impresión. Podemos corregir esto con una expresión regular. También eliminaremos espacios extra y dejaremos todo en un string. texto_maltes2 &lt;- texto_maltes %&gt;% # elimina cuando suceda un guión, salto de párrafo y luego espacios (o no) str_remove_all(&quot;-\\\\n\\\\s*&quot;) %&gt;% # eliminar espacios extra str_squish() %&gt;% # dejar todo en un string str_c(collapse = &quot;&quot;) texto_maltes2 ## [1] &quot;Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA PARTIDO HUMANISTA DE CHILE 2021 – 2025Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 INTRODUCCIÓN E sta propuesta de programa surge del convencimiento social, político y cultural de que es posible construir una convivencia y una forma de vida más justa y digna para los habitantes de la Región Metropolitana (RM), sin distinción de ningún tipo. Estamos convencidos que nuestra diversidad y multiculturalidad son una fortaleza, como también una motivación para crecer y desarrollarnos de forma equilibrada, con igualdad de oportunidades para todas, todos y todes. Hoy vivimos un proceso de cambio que se ha logrado gracias a la valentía y heroísmo de miles jóvenes, estudiantes, pobladores, trabajadoras y trabajadores, entre otros actores sociales que por décadas han visto frustrados sus anhelos de tener una vida más justa en diferentes ámbitos, como la salud, la educación, el trabajo, la seguridad social, la vivienda, el acceso a la cultura, la seguridad ciudadana, además de una infancia con equidad y una vejez con dignidad. Nuestra propuesta para elaborar una Estrategia Regional de Desarrollo considera como una cuestión insoslayable la participación ciudadana transversal, rigurosamente democrática. Creemos que es urgente dinamizar la economía de la región, garantizar la seguridad ciudadana y la paz en los barrios y poblaciones liberándolos de la maldición de las drogas, desarrollar acciones concretas por la protección del medioambiente y promover con eficacia la cultura y la educación como ejes para una mejor calidad de vida. 2Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 II ESTRATEGIA REGIONAL DE DESARROLLO: UNA REGIÓN PARA EL SIGLO XXI P ara abordar en propiedad la idea de una Región para el Siglo XXI hay que plantearse claramente lo que significa implementar para el período 2021 – 2031 un Nuevo Plan de Desarrollo para la Región Metropolitana. Este plan no puede ser otra cosa que la carta de navegación, que guíe las acciones y las políticas públicas que debemos impulsar como Gobierno Regional. Todos estos planes y programas esperamos construirlos conjuntamente con la ciudadanía a través de un sistema de consulta ciudadana permanente. Buscaremos de este modo un diseño participativo y responsable, de acuerdo con las dificultades y restricciones que enfrentamos debido a la crisis sanitaria. Solo así vamos a saber bien en donde están las debilidades y las fortalezas que nos permitirán poner los énfasis en los problemas que debemos resolver, como también en nuestras prioridades y urgencias. 3Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 III EJES PROGRAMÁTICOS a) ACCESO A LA CULTURA Y LAS ARTES b) TRABAJO Y ECONOMÍA COOPERATIVA c) MEDIO AMBIENTE Y SOCIEDAD AMABLE d) DIVERSIDAD E INCLUSIÓN e) PROTECCIÓN SOCIAL f) MOVILIDAD Y TRANSPORTE g) LUCHA CONTRA EL NARCOTRÁFICO h) GOBIERNO DE LA CIUDAD,TRANSPARENCIA Y ALIANZA CON MACROCOMUNAS 4Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 a) ACCESO A LA CULTURA Y LAS ARTES Será urgente y una prioridad poner a la cultura y las artes como uno de los pilares de nuestro programa de trabajo. De esta forma impulsaremos iniciativas desde el Gobierno Regional para movilizar y disponer de más recursos para que creadores, gestores y artistas locales como también para que los centros culturales de barrios, comunas y localidades aisladas tengan el apoyo necesario para el desarrollo de su gestión y trabajo. La cultura no puede ser el privilegio de una élite y tampoco puede estar monopolizada solo por algunas pocas instituciones. Nos interesa democratizar el acceso a la población al goce de la creación y empatizar con artistas que tengan una verdadera vocación social. El arte y la comunidad deben ser una amalgama productiva y alegre. Impulsaremos en el ámbito de la formación escuelas-talleres de capacitación para el desarrollo de proyectos con impacto social positivo en el ámbito de la creación. Es importante que tanto artistas como gestores tengan formación y capacitación en el diseño y gestión de sus proyectos. Desarrollaremos el primer laboratorio e incubadora de proyectos creativos en conjunto con la CORFO para el impulso de la industria y la gestión con fines de desarrollo comunitario y local. Crearemos el primer Registro Regional de Creadores y Trabajadores del Sector Cultural, que permitirá por un lado realizar un censo de la actividad creativa, artística, patrimonial y cultural en toda su diversidad en la región. Este proyecto permitirá abrir nuevos polos y espacios de desarrollo. Impulsaremos decididamente un plan de recuperación de teatros patrimoniales en la Región Metropolitana, en conjunto con el Consejo de Monumentos Nacionales y el Servicio Nacional del Patrimonio Cultural. 5Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 En el ámbito de la comunicación, vamos a fortalecer el rol de las radios comunitarias a través de la búsqueda de financiamiento para nuevos proyectos de orden digital. De la misma forma, apoyaremos a canales locales de televisión acompañando sus proyectos y nuevas fórmulas de financiamiento a través de Fondos Regionales de Cultura y la Secretaría Regional Ministerial del Ministerio de las Culturas, las Artes y el Patrimonio. Potenciaremos certámenes para la diversidad cultural, la tradición y la expresión identitaria por zonas de la Región Metropolitana como también el fomento de espacios para artistas de calle. Potenciaremos toda la red de creadores y artes a nivel regional como una expresión de diversidad e inclusión de diferentes expresiones artísticas y sociales como una comunidad regional. b) TRABAJO Y ECONOMÍA COOPERATIVA El desempleo es una realidad que básicamente golpea a las comunas más pobres y a una clase media desprotegida por el Estado. Por esta razón, trabajaremos en incentivar la economía local de las comunas más desfavorecidas que se han visto perjudicadas por la crisis sanitaria. Fomentaremos el emprendimiento colaborativo y creativo en el máximo de espacios posibles como las juntas de vecinos, organizaciones comunitarias, centros de adultos mayores, establecimientos deportivos, ferias libres y el comercio local que lucha contra los grandes monopolios. 6Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 Una economía colaborativa y circular a escala local debe ser fomentada por el Gobierno Regional con planes concretos de acuerdo con las especificidades y potencialidades de cada comuna y zonas de la región. Construir una economía cooperativa y asociativa entre todos los actores sociales de la comunidad será una prioridad como eje de nuestro Plan Estratégico de Desarrollo. Potenciar planes para reforzar el teletrabajo será una misión importante como también flexibilizar horarios de algunas labores especialmente para cientos de mujeres que realizan trabajos en sus casas y deben estar al cuidado además de sus grupos familiares. No apoyamos una economía en base solo a la competencia despiadada y el enriquecimiento de pequeños grupos privilegiados. Nuestra apuesta consistirá en potenciar al máximo una economía creativa y local en base al desarrollo e impulso de cooperativas de trabajo solidario. Tenemos claro que Santiago sigue siendo la capital y que para apoyar la recuperación económica del país se necesita una ciudad pujante. Sin embargo, eso debe estar en coordinación con el Gobierno Central para que el máximo de empresas productivas en su mayoría del Gran Santiago esté al servicio de la población con planes de reinserción y protección social que apunten a una mejor calidad de vida de todos. Impulsaremos iniciativas para fomentar el Comercio Justo y la vinculación con proyectos que impacten positivamente en la economía, en el gobierno local y cada provincia de la región a través de alternativas como la Banca Ética. Para ello realizaremos una profunda capacitación en el diseño y desarrollo de proyectos a escala de cada comuna de la región. Nuestra tarea será de cara al siglo XXI, construir Polos de Desarrollo Económicos Locales en la RM. 7Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 c) MEDIO AMBIENTE Y SOCIEDAD AMABLE Para vivir en un entorno saludable y gozar de una calidad de vida que haga feliz a todos los habitantes sin exclusión alguna debemos trabajar y potenciar todo tipo de políticas ambientales para hacer de la Región Metropolitana una Sociedad Amable. Este concepto no se puede lograr sin políticas públicas que integren en la vida de los ciudadanos una conciencia más social, más inclusiva, de autocuidado y de protección del medio ambiente y el ecosistema natural y cultural. Gestionaremos un plan de fiscalización a los vertederos que existen en la RM, como también un levantamiento de los estudios de impacto ambiental en nuestra región. Es fundamental que tengamos diagnósticos actualizados en estas materias. Las autoridades deben estar al tanto de la realidad medioambiental y la población informada. Este no debe ser un secreto solo para las instituciones o quienes hacen acuerdos económicos con el sector privado. No, todos los ciudadanos deben conocer a fondo la realidad medioambiental en la que viven, y las medidas que están llevando a cabo quienes dirigen las instituciones. Impulsaremos una cultura medioambiental que será parte de nuestras prioridades y programas y que también deberá ser transversal a todas las instituciones de la región, tanto públicas como privadas. El reciclaje de desechos y basura también será parte de nuestras prioridades para una mejor descontaminación. Para ello realizaremos estudios y abordaremos nuevas propuestas de alta tecnología para el reciclaje de desechos y basura. También potenciaremos puntos de reciclaje en los barrios y juntas vecinales juntamente con planes educativos. Todos los servicios públicos y los establecimientos educacionales deberán tener pun8Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 tos obligatorios de reciclaje como también estándares de eficiencia energética. Impulsaremos en conjunto con el Ministerio de Educación un plan para implementar una Educación Ambiental en todos los liceos públicos de la RM.Trabajaremos en una conciencia ambiental desde la niñez. Potenciaremos el desarrollo de áreas verdes en todas las comunas y los barrios como también planes de reforestación, especialemente árboles nativos, que sabemos mejoran el ecosistema. Generaremos nuevos parques metropolitanos que apunten a cubrir a las zonas excluidas de nuestra región. Todas las comunas, o al menos algunas macrozonas definidas territorialmente, deberán contar con Parques Temáticos y Culturales como propuesta de una mejora calidad de vida y educación ambiental. Estimularemos el uso de energías verdes para ser implementadas en nuestros barrios. Tendremos que regular y fiscalizar rigurosamente los planos reguladores de las comunas. No podemos permitir guetos de altura que van en desmedro de la calidad de vida, la seguridad y la convivencia. Fomentaremos el reconocimiento de barrios y zonas típicas para la recuperación de espacios históricos. Hay muchas zonas y edificaciones de gran valor arquitectónico que se encuentran en malas condiciones y hay que buscar las fórmulas de gestión y financiamiento para recuperarlas. Desarrollaremos en todas las comunas planes para la implementación vecinal de huertos urbanos que embellezcan el barrio y conecten a los vecinos con formas de abastecimiento local. 9Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 d) DIVERSIDAD E INCLUSION Nuestra región tiene una gran diversidad cultural y distintas identidades que van desde zonas rurales cordilleranas como el Cajón del Maipo y Pirque, hasta zonas urbanas y campestres. Sin embargo, también Santiago como capital es cada día más cosmopolita y concentra a una población migrante que ya es parte de nuestra convivencia diaria, la que a su vez también se ha insertado en distintas comunas del país, dando vida a un nuevo mapa social y cultural que debemos potenciar en todo sentido. Cuando hablamos de diversidad tenemos también que pensar en las diferencias de género y las comunidades que integran por ejemplo al mundo homosexual, la comunidad trans, queer, bisexuales, lesbianas y otras. Todos segmentos que hoy tienen más voz, mayor influencia y que han hecho respetar sus derechos en forma legítima. Con todes elles trabajaremos. Me preocuparé de diseñar programas locales con enfoque de género y fomentaré la creación de Oficinas de la Diversidad en todos los gobiernos locales que entren en coordinación directa con los distintos departamentos de la diversidad que tienen los municipios y estimular la presencia de estos programas en los municipios que aún no lo tienen. Crearemos en las comunas espacios para promover políticas impulsadas por mujeres en distintos ámbitos como derechos, violencia, trabajo comunitario, enseñanza, etc. En este contexto ampliaremos la prevención en contra de cualquier forma de violencia de género. Estableceremos las competencias necesarias para fortalecer el trabajo de asistencia. Crearemos también programas y proyectos para la integración concreta de los pueblos 10Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 originarios a la convivencia local y nacional. Apostamos por una nación plurinacional y creemos que la incorporación de nuestras culturas ancestrales en nuestra vida cotidiana se debe realizar en paz, con igualdad de derechos y nuevas oportunidades. Una cultura orientada al respeto de los Derechos Humanos también será fomentada por el Gobierno Regional. Para ello motivaré un trabajo transversal en todas las áreas, empezando por los servicios públicos y los gobiernos locales. Trabajaremos incesantemente para promover al máximo una cultura por los Derechos de los Niños, Niñas y Adolescentes en la Región Metropolitana a través de los barrios y juntas vecinales. Desarrollaremos planes de inserción para niños vulnerados en sus derechos que son víctimas de la pobreza y el abandono en coordinación con organizaciones responsables y de conducta ética irreprochable. Potenciaremos iniciativas como la adopción de forma responsable con altos estándares de apoyo por parte de las instituciones pertinentes. No permitiremos ningún tipo de forma de violencia en contra de la niñez, como el trabajo y la explotación infantil. Una infancia feliz será otro de nuestros lemas y principios que guiarán nuestra labor. e) PROTECCIÓN SOCIAL La Pandemia que vivimos producto del COVID -19 ha generado problemas graves en diversos ámbitos, pero fundamentalmente en el mundo del trabajo. La cantidad de gente que puede hacer teletrabajo no alcanza al 30% y se concentra en las comunas más ricas del sector oriente. 11Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 La pandemia deja en evidencia la desigualdad y debemos generar mayor empleabilidad y un retorno a las fuentes laborales con más protección sanitaria y mejor información a la comunidad. Desarrollaremos planes de trabajo realistas como Gobierno Regional en el marco de la pandemia. Apoyaremos a la Red Pública de Salud con proyectos para mejorar su infraestructura, además del necesario abastecimiento de materiales e insumos para la población. Un fuerte plan de información a la comunidad en cooperación con el aparato público de salud será necesario priorizar para que la atención primaria cuente con la confianza y la colaboración de la comunidad y viceversa. Apoyaremos e implementaremos un plan de control sanitario para todo el comercio local y los barrios como también para todos los establecimientos educacionales. Los sectores más vulnerables y la población de mayor riesgo deben estar en la primera prioridad, pero no podemos permitir que nadie quede excluido de una obligación que es del Estado. Nos comprometemos a proteger nuestra salud pública y a sus trabajadores. Llevaremos también un plan para la salud mental de la población que se ha visto perjudicada por la pandemia. Para ellos trabajaremos con universidades chilenas que busquen ampliar su conocimiento y práctica en las comunas de la RM. Pondremos énfasis en la protección de las personas en situación de calle, implementando y potenciando planes que lleven tratamientos de salud digna en todos sus aspectos y así también como el acceso a la vivienda, educación, trabajo y justicia. De acuerdo con los datos que entrega la Cámara Chilena de la Construcción 12Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 (CCHC), en la Región Metropolitana existiría un déficit de 314.488 viviendas, lo que representa un 11% respecto de su población y un 42,5% respecto del déficit total nacional. Esta realidad debemos cambiarla y para eso nos comprometemos a desarrollar un Programa de Vivienda para los sectores y familias más vulnerables con la finalidad de erradicar progresivamente los campamentos y la precariedad habitacional creciente. Los campamentos se han duplicado en los ultimos tres años en la Región Metropolitana f) MOVILIDAD Y TRANSPORTE El transporte es sin duda un problema estructural y uno de los mayores desafíos de un Gobierno Regional. Tenemos problemas con el creciente parque automotriz, con el Transantiago y la congestión en el Metro de Santiago que traslada en un día laboral a más de 2 millones de habitantes entre los casi 20 millones de viajes que se realizan en la región en un solo día. Son muchas veces largas horas de viajes que deterioran la calidad de vida de las personas y disminuye su energía en sus espacios de trabajo y en la convivencia familiar. Nuestro compromiso en esta área será en una primera fase aportar en conjunto con el Ministerio de Transporte a una mejor coordinación de las diferentes oficinas y servicios públicos de transporte con el fin de mejorar y optimizar todo tipo de traslados para la población. Revisaremos y haremos un diagnóstico del mapa vial de nuestras comunas a fin de 13Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 construir nuevas y modernas propuestas en torno al diseño de calles y carreteras de la región. En esta misma línea impulsaremos la creación de un tren rápido que mejore toda la red de enlace entre la Región Metropolitana y la Quinta Región, ampliando la conectividad con el Metro de Santiago y todas las líneas del Metro de Valparaíso. Impulsaremos una cultura del uso de la bicicleta en toda la región y potenciaremos la creación de ciclovías en todos los barrios para motivar e instalar esta nueva forma de transporte. En ese sentido, la creación de un nuevo Plan Maestro de Ciclovías para la Región Metropolitana será fundamental para dar continuidad a una política urbana que fortalezca el uso de la bicicleta como medio de transporte. g) LUCHA CONTRA EL NARCOTRÁFICO Si bien la seguridad no es un tema que el gobernador debe asumir en sí mismo, sentimos la obligación de involucrarnos porque finalmente el desarrollo social y la cohesión social de una ciudad tiene que ver con tener una ciudad más segura. Es difícil obviar hoy los funerales narcos, con balazos al aire, los fuegos de artificio y estridencia; las balas locas y el poder que han adquirido las bandas de narcotraficantes en distintas poblaciones de la Región Metropolitana. Esa realidad es pan de cada día para una parte importante de la población regional y, pese a las advertencias de diversos actores que han levantado la voz, es una situación que se sigue escondiendo bajo la alfombra, al punto que hay zonas de 14Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 la RM, callejuelas, poblaciones, donde las policías no entran, a pesar de las denuncias o evidencias. No creemos que el incremento de penas sea una solución. Hoy quienes forman parte de estas asociaciones delictivas y quienes están detrás de las balaceras que provocan terror en la población son en su mayoría jóvenes marginados del Gran Santiago y, por consiguiente, sus familias, dotadas de mujeres y niños quienes en contraron en el crimen organizado lo que el Estado y el modelo económico les negó. Remitirse a encarcelar más pobres que la pobreza no solo se mide en ingresos económicos no es atacar el problema con eficacia, como tampoco lo son los recuentos policiales con la estadística anual de droga incautada. Está visto que la solución del problema no pasa por ahí. El narcotráfico es una pandemia, pero peor aún, es una dictadura porque esclaviza a los consumidores y a niños y jóvenes que trabajan para ellos. Son grupos con alto poder de fuego, que intimidan a la gente, que no conversan y solo disparan para hacer crecer su negocio, provocando un daño irreparable a nuestro tejido social ya tan dañado, pero también a nuestra democracia que tanto nos cuesta construir día a día. Para arrebatarles el poder a los narcos hay que ganarles la batalla en las poblaciones con una mayor presencia del Estado, a través de programas de reinserción social, fomento a los pequeños emprendedores, mejor educación, mayor cantidad de áreas verdes y, en definitiva, recuperando espacios y la legitimidad perdida. Todo eso de la mano con un fuerte combate a grupos o bandas que intimidan a la gente y se apropian del territorio. En las poblaciones pocos creen en la acción del Estado y esa credibilidad se debe recuperar, para así juntos desenredar la madeja tejida por el narcotráfico. 15Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 Además, desde el espacio de la Gobernación se deben dar señales potentes para llamar a las autoridades pertinentes a poner también el acento en el lavado de activos, donde está la verdadera cabeza del problema. Para construir un tejido social digno, debemos como Estado, trabajar en políticas y programas públicos desde y para la gente. Cualquier tipo de exclusión siempre terminará por convertirse en una amenaza. Por ello, debemos combatir toda forma de desigualdad. Solo así avanzaremos responsablemente para tener una región alegre, viva y democrática. h) GOBIERNO DE LA CIUDAD,TRANSPARENCIA Y ALIANZAS Necesitamos enfocar el desarrollo regional especializando las medidas de acuerdo a la gobernabilidad de la ciudad de Santiago en equilibrio con las demás realidades urbanas y rurales de las comunas. Gobernabilidad regional y desarrollo equilibrado y sinérgico para las personas y sus comunidades. Hoy las unidades metropolitanas abarcan todos los recursos, dejando fuera del radio de acción a comunas que están en el borde o comunas rurales. Por tal razón es de gran trascendencia un Plan de Ordenamiento Territorial que considere este propósito, impulsando el dialogo productivo y transparente entre los intereses de los distintos actores que deben participar, para que prevalezca el interés público como eje rector de esta importante política pública. Hay que reconocer los intereses de cada actor que está involucrado y los objetivos que tiene 16Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 cada cual. Propongo una declaración de intereses donde privados y actores publicos clarifiquen lo que buscan en cada proyecto o intervencion que realicen. Hoy las inmobiliaras logran apropiarse de paños y construcciones haciendo reuniones por el lado, lo que ha significado que en la actualidad practicamente no existan paños privados en toda la región para que el Estado por ejemplo realice viviendas sociales. Esto ha sido producto de acuerdos entre cuatro paredes de empresarios y tambien municipios. Una ciudad distinta parte por la transparencia y por la capacidad de reinventarse y mostrar los intereses de cada cual El control del suelo metropolitano es un verdadero problema. El hecho de los privados tengan control de todos los paños privados hace que los precios hayan subido sustancialmente incluso en las comunas intrametropolitanas, que tenían precios accesibles para la gente comun y corriente. Hoy la cosntrucción de nuevas viviendas está sometida a un monopoliio privado que eleva al doble o al triple los precios de los terrenos, lo que redunda en un encarecimiento de la vida para todos los capitalinos. Además de todo eso, las inmobiliarias con la complicidad de muchos municipios, construyen en lugares donde no hay redes de agua potable, luminarias y falta de servicios. El desarrollo de cualquier conjunto habitacional social o privado debe contemplar la integralidad de todos los factores y no solamente la casa en sí misma. Ahí también hay un tema que queremos corregir. Debemos reconocer y fortalecer la relación del gobierno regional con las munici17Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / PARTIDO HUMANISTA DE CHILE 2021 – 2025 palidades para el desarrollo equitativo de los territorios e impulsar especialmente planes y programas supracomunales, considerando el rol de las asociaciones municipales que se encuentren funcionando o que se conformen en este proceso. El plan de ordenamiento territorial no debe contemplar contactos por separado con las municipalidades, sino debe ser a partir de grupos de municipios que integren territorios de manera de fortalecer y desarrollar las macrozonas urbanas, lo que además hará más eficiente la entrega de recursos. Para apoyar el desarrollo de estos planes y programas se instalarán fondos regionales que buscarán asociar recursos públicos centrales, comunales y privados como parte de los instrumentos del Plan de Desarrollo Regional. Necesitamos polos de desarrollo, trabajo y empleo decente en los territorios. Los microproyectos que hoy están en poder de los Cores deben dar cabida a macroproyectos que por ejemplo generen empleabilidad, trabajo, desarrollo sustentable, emprendimiento. La idea de proyecto que se consigue a través de los cores solo se presta para alianzas politicas y financiamiento de candidaturas locales que no sirven de mucho para el desarrollo de la ciudad. 18&quot; (Ejercicio b) Crear una receta/función para esto Entonces estos son los pasos que queremos hacer: cargar el texto con pdftools::pdf_text() desde el nombre del archivo y luego límpialos con los pasos de antes (arreglar problema de guiones, eliminar espacios extra, dejar todo en un elemento). Genera una receta/función para hacer esto, que debería devolver el texto “limpio” con el siguiente comando: ## f_extraer_texto_limpio(&quot;datos/programas_gob_rm_2021/13_PABLO_ANTONIO_ANDRES_MALTES_BISKUPOVIC.PDF&quot;) Ahora deberíamos tener una función, f_extraer_texto_limpio(), que carga el texto de cualquier pdf y conecta las palabras separadas por guión + salto de línea. Iterar para todos los programas Podemos obtener los archivos de una carpeta con la función list.files(), de R base: vector_archivos_programas &lt;- list.files(&quot;datos/programas_gob_rm_2021/&quot;, full.names = T) vector_archivos_programas ## [1] &quot;datos/programas_gob_rm_2021//13_CATALINA_PAROT_DONOSO.pdf&quot; &quot;datos/programas_gob_rm_2021//13_CLAUDIO_ORREGO_LARRAIN.pdf&quot; &quot;datos/programas_gob_rm_2021//13_FRESIA_MONICA_QUILODRAN_RAMOS.pdf&quot; ## [4] &quot;datos/programas_gob_rm_2021//13_KARINA_LORETTA_OLIVA_PEREZ.pdf&quot; &quot;datos/programas_gob_rm_2021//13_NATHALIE_JOIGNANT_PACHECO.pdf&quot; &quot;datos/programas_gob_rm_2021//13_PABLO_ANTONIO_ANDRES_MALTES_BISKUPOVIC.pdf&quot; ## [7] &quot;datos/programas_gob_rm_2021//13_RICARDO_JAVIER_MARTINEZ_VALENCIA.pdf&quot; &quot;datos/programas_gob_rm_2021//13_ROJO_EDWARDS_SILVA.pdf&quot; Ahora podemos iterar nuestra función en este objeto para obtener un vector con todos los textos (limpios): vector_textos_programas &lt;- map_chr(.x = vector_archivos_programas, .f = ~ f_extraer_texto_limpio(.x)) Ahora creemos nuestra base tidy, a partir de los dos vectores: df_programas &lt;- tibble(archivo = vector_archivos_programas, texto = vector_textos_programas) %&gt;% mutate(nombre = archivo %&gt;% str_remove(&quot;13_&quot;) %&gt;% str_replace_all(&quot;_&quot;, &quot; &quot;) %&gt;% str_to_title() %&gt;% str_remove(&quot;\\\\.pdf&quot;)) %&gt;% select(archivo, nombre, texto) df_programas ## # A tibble: 8 x 3 ## archivo nombre texto ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 datos/programas_gob_rm_2021//13_CATALINA_PAROT_D… Datos/Programas Gob Rm 2021//Catalina Paro… &quot;Programa Gobernación de la Región Metropolitana 1Índice 1. Presentación • Principios inspiradores • Estudios guía 2. Introducción 3. Datos • Datos demog… ## 2 datos/programas_gob_rm_2021//13_CLAUDIO_ORREGO_L… Datos/Programas Gob Rm 2021//Claudio Orreg… &quot;Índice Mensaje 3 Cinco grandes desafíos y el imperativo de emparejar la cancha de las comunas. 4 Primer desafío: Seguridad 6 Prevención de los delitos 6… ## 3 datos/programas_gob_rm_2021//13_FRESIA_MONICA_QU… Datos/Programas Gob Rm 2021//Fresia Monica… &quot;Programa Mínimo para el Gobierno Regional de la Región Metropolitana. Introducción. Las indicaciones sobre las atribuciones de la Gobernadora, o Goberna… ## 4 datos/programas_gob_rm_2021//13_KARINA_LORETTA_O… Datos/Programas Gob Rm 2021//Karina Lorett… &quot;Somos Comunes. La degradación de la política chilena, la crisis de la institucionalidad de la transición, los abusos y las injusticias en contra de nues… ## 5 datos/programas_gob_rm_2021//13_NATHALIE_JOIGNAN… Datos/Programas Gob Rm 2021//Nathalie Joig… &quot;PROGRAMA PRELIMINAR PARTICIPATIVO GOBERNACION DE LA REGIÓN METROPOLITANA DE SANTIAGO SALUDO INICIAL A tod@s y cada un@: Me presentare brevemente, ya que… ## 6 datos/programas_gob_rm_2021//13_PABLO_ANTONIO_AN… Datos/Programas Gob Rm 2021//Pablo Antonio… &quot;Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA PARTIDO HUMANISTA DE CHILE 2021 – 2025Pablo Maltés Biskupovic GOBERNADOR REGIÓN METROPOLITANA / … ## 7 datos/programas_gob_rm_2021//13_RICARDO_JAVIER_M… Datos/Programas Gob Rm 2021//Ricardo Javie… &quot;PROGRAMA CANDIDATURA GOBERNADOR RICARDO JAVIER MARTINEZ VALENCIA. POR UNA REGION METROPOLITANA JUSTA, VERDE Y FRATERNA AYÚDAME A DESCENTRALIZAR SANTIAGO… ## 8 datos/programas_gob_rm_2021//13_ROJO_EDWARDS_SIL… Datos/Programas Gob Rm 2021//Rojo Edwards … &quot;Programa ROJO EDWARDS GOBERNACIÓN REGIÓN METROPOLITANAÍndice: Carta del Candidato. Rojo Edwards 2 Recuperar el Control sobre nuestras vidas 4 Recuperar … Aplicación 2: varios archivos Excel Es muy común que datos gubernamentales estén en múltiples planillas con el mismo formato, que queramos unir. Por ejemplo, así están las estadísticas delictuales para las comunas de la Región de Magallanes. Descargué esos Excel en la carpeta “datos/delitos_comunales/”. Queremos llegar a una sola base. Obtengamos la base con la tasa de delitos para la comuna de Punta Arenas: readxl::read_excel(&quot;datos/delitos_comunales/Punta Arenas.xlsx&quot;, sheet = &quot;Pag7&quot;, range = &quot;B13:G26&quot;, # dónde está la info que queremos col_names = c(&quot;tipo_delito&quot;, 2012:2016)) %&gt;% # creamos nombres de variables &quot;a mano&quot; filter(!is.na(tipo_delito)) %&gt;% # eliminamos la fila de más # ahora pasamos la base a long: pivot_longer(cols = -tipo_delito, names_to = &quot;anio&quot;, values_to = &quot;tasa_casos&quot;) %&gt;% mutate(anio = as.numeric(anio)) ## # A tibble: 65 x 3 ## tipo_delito anio tasa_casos ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Robo con violencia o intimidación 2012 95.6 ## 2 Robo con violencia o intimidación 2013 80.3 ## 3 Robo con violencia o intimidación 2014 73.8 ## 4 Robo con violencia o intimidación 2015 58.6 ## 5 Robo con violencia o intimidación 2016 78.3 ## 6 Robo por sorpresa 2012 15.1 ## 7 Robo por sorpresa 2013 19.1 ## 8 Robo por sorpresa 2014 15.9 ## 9 Robo por sorpresa 2015 18.2 ## 10 Robo por sorpresa 2016 20.6 ## # … with 55 more rows (Ejercicio c) Genera una función f_procesar_excel_delitos() y testea que funcione con el Excel de la comuna de Porvenir. Tu código: (Ejercicio d) Obtén la lista de archivos Excel que queremos procesar, como un vector llamado “vector_archivos_delitos”. Iteración Podemos generar la iteración con map_dfr(): map_dfr(.x = vector_archivos_delitos, .f = ~f_procesar_excel_delitos(.x)) ## # A tibble: 715 x 3 ## tipo_delito anio tasa_casos ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Robo con violencia o intimidación 2012 0 ## 2 Robo con violencia o intimidación 2013 0 ## 3 Robo con violencia o intimidación 2014 0 ## 4 Robo con violencia o intimidación 2015 0 ## 5 Robo con violencia o intimidación 2016 0 ## 6 Robo por sorpresa 2012 0 ## 7 Robo por sorpresa 2013 0 ## 8 Robo por sorpresa 2014 0 ## 9 Robo por sorpresa 2015 0 ## 10 Robo por sorpresa 2016 0 ## # … with 705 more rows En efecto se pegaron “hacia abajo” todos nuestros resultados, pero no es posible distinguir entre ellos. Lo que querríamos es una fila “comuna” que nos permita saber a qué comuna pertenecen los datos de la fila. Comencemos creando, a partir del vector de los archivos, otro vector con los nombres de las comunas: vector_comunas &lt;- vector_archivos_delitos %&gt;% str_extract(&quot;[\\\\w\\\\s]+\\\\.xlsx$&quot;) %&gt;% str_remove(&quot;\\\\.xlsx&quot;) vector_comunas ## [1] &quot;Antartica&quot; &quot;Cabo de Hornos&quot; &quot;Laguna Blanca&quot; &quot;Natales&quot; &quot;Porvenir&quot; &quot;Primavera&quot; &quot;Punta Arenas&quot; &quot;Rio Verde&quot; &quot;San Gregorio&quot; &quot;Timaukel&quot; &quot;Torres del Paine&quot; Ahora hagamos que estos sean los nombres del objeto en el que estamos iterando, “vector_archivos_delitos”: names(vector_archivos_delitos) &lt;- vector_comunas vector_archivos_delitos ## Antartica Cabo de Hornos Laguna Blanca Natales Porvenir ## &quot;datos/delitos_comunales//Antartica.xlsx&quot; &quot;datos/delitos_comunales//Cabo de Hornos.xlsx&quot; &quot;datos/delitos_comunales//Laguna Blanca.xlsx&quot; &quot;datos/delitos_comunales//Natales.xlsx&quot; &quot;datos/delitos_comunales//Porvenir.xlsx&quot; ## Primavera Punta Arenas Rio Verde San Gregorio Timaukel ## &quot;datos/delitos_comunales//Primavera.xlsx&quot; &quot;datos/delitos_comunales//Punta Arenas.xlsx&quot; &quot;datos/delitos_comunales//Rio Verde.xlsx&quot; &quot;datos/delitos_comunales//San Gregorio.xlsx&quot; &quot;datos/delitos_comunales//Timaukel.xlsx&quot; ## Torres del Paine ## &quot;datos/delitos_comunales//Torres del Paine.xlsx&quot; Listo, ahora podremos realizar la iteración y en el resultado incluir una columna con la comuna, gracias al argumento .id =: df_delitos_magallanes &lt;- map_dfr( .x = vector_archivos_delitos, .f = ~f_procesar_excel_delitos(.x), .id = &quot;comuna&quot; ) df_delitos_magallanes ## # A tibble: 715 x 4 ## comuna tipo_delito anio tasa_casos ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Antartica Robo con violencia o intimidación 2012 0 ## 2 Antartica Robo con violencia o intimidación 2013 0 ## 3 Antartica Robo con violencia o intimidación 2014 0 ## 4 Antartica Robo con violencia o intimidación 2015 0 ## 5 Antartica Robo con violencia o intimidación 2016 0 ## 6 Antartica Robo por sorpresa 2012 0 ## 7 Antartica Robo por sorpresa 2013 0 ## 8 Antartica Robo por sorpresa 2014 0 ## 9 Antartica Robo por sorpresa 2015 0 ## 10 Antartica Robo por sorpresa 2016 0 ## # … with 705 more rows Ahora podemos ocupar esta base para hacer nuestros análisis. (Ejercicio e) Realiza un gráfico para explorar la base de datos que creamos. "],["web-scraping.html", "07B - Web scraping Inicio: cargar paquetes Web scraping Descargar múltiples páginas con una iteración Generalizar el proceso de limpieza de los datos con una función", " 07B - Web scraping Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos en RStudio Cloud con Session &gt; Restart R y clickeando en la escoba del panel de “Environment” (superior derecho). Inicio: cargar paquetes library(tidyverse) library(xml2) # viene con el tidyverse library(glue) # viene con el tidyverse library(rvest) # viene con el tidyverse; para hacer web scraping Interpolación con glue::glue() color &lt;- &quot;azul&quot; glue(&quot;Hola, el cielo es {color}&quot;) ## Hola, el cielo es azul glue(&quot;HOLA, EL CIELO ES {str_to_upper(color)}&quot;) ## HOLA, EL CIELO ES AZUL Web scraping El web scraping es la extracción automatizada de información a partir de sitios web. Aparte de alimentar sitios como Knasta, que lo realizan periódicamente, nos permite obtener datos de fuentes no tradicionales (¡cualquier sitio web!). La información que podemos obtener es igual a la que podríamos hacer manualmente (copiando y pegando a un Excel, por ejemplo), pero podemos automatizar tareas muy tediosas. Hoy veremos web scraping para páginas “estáticas” en vez de “dinámicas”. Descargar un sitio web Comenzaremos trabajando con las columnas de El Mostrador. Dejé el código comentado porque ya hice la descarga y no tenemos para qué correr todos/as esto (no queremos colapsar un sitio haciendo web scraping). ## download_html( ## url = &quot;https://www.elmostrador.cl/noticias/opinion/columnas/page/1/&quot;, ## file = &quot;webs/mostrador_1.html&quot; ## ) Cargar el html web_mostrador_p1 &lt;- read_html(&quot;webs/mostrador_1.html&quot;, encoding = &quot;UTF-8&quot;) # buena idea para páginas en español Extraer la información a partir de la estructura de la página, con rvest El primer paso es encontrar el “selector” de CSS que contiene nuestra información. En la mayoría de los casos nos bastará con usar SelectorGadget. Tus apuntes sobre cómo usar SelectorGadget: Comencemos con los títulos: titulos_mostrador_p1 &lt;- web_mostrador_p1 %&gt;% html_nodes(&quot;h4 a&quot;) %&gt;% html_text() titulos_mostrador_p1 ## [1] &quot;Convención y participación: un camino sin retorno&quot; &quot;Arrebol de nuevos amaneceres&quot; ## [3] &quot;IVA diferenciado: ¿transitorio o permanente?&quot; &quot;Oposición: la teleserie más mala de todas&quot; ## [5] &quot;Más allá de la “emergencia”: pensar una Renta Básica Universal como política permanente&quot; &quot;La Convención constituyente y el camino de regreso a una sociedad más justa&quot; ## [7] &quot;¡Distanciamiento físico, no social…por favor!&quot; &quot;Por fin: comenzó la competencia de medios de pago&quot; ## [9] &quot;Boric versus Jadue&quot; &quot;Nuestro mayor poder: la ciudadanía independiente&quot; Para sacar los links de un elemento, en vez de su texto, debemos reemplazar html_text() por html_attr(\"href\"): links_mostrador_p1 &lt;- web_mostrador_p1 %&gt;% html_nodes(&quot;h4 a&quot;) %&gt;% html_attr(&quot;href&quot;) links_mostrador_p1 ## [1] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/convencion-y-participacion-un-camino-sin-retorno/&quot; ## [2] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/arrebol-de-nuevos-amaneceres/&quot; ## [3] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/iva-diferenciado-transitorio-o-permanente/&quot; ## [4] &quot;https://www.elmostrador.cl/destacado/2021/05/24/oposicion-la-teleserie-mas-mala-de-todas/&quot; ## [5] &quot;https://www.elmostrador.cl/destacado/2021/05/24/mas-alla-de-la-emergencia-pensar-una-renta-basica-universal-como-politica-permanente/&quot; ## [6] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/la-convencion-constituyente-y-el-camino-de-regreso-a-una-sociedad-mas-justa/&quot; ## [7] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/distanciamiento-fisico-no-socialpor-favor/&quot; ## [8] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/por-fin-comenzo-la-competencia-de-medios-de-pago/&quot; ## [9] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/boric-versus-jadue/&quot; ## [10] &quot;https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/nuestro-mayor-poder-la-ciudadania-independiente/&quot; (Ejercicio a) Obtén el autor/a de cada artículo. Llama al vector “autores_mostrador_p1”. Tu código: Ahora podemos crear un data frame con toda información: df_mostrador_p1 &lt;- tibble( titulo = titulos_mostrador_p1, link = links_mostrador_p1, autor = autores_mostrador_p1, ) df_mostrador_p1 ## # A tibble: 10 x 3 ## titulo link autor ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Convención y participación: un camino sin retorno https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/convencion-y-participacion-un-camino-sin-retorno/ Vicente Gerlach ## 2 Arrebol de nuevos amaneceres https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/arrebol-de-nuevos-amaneceres/ María Ignacia Ibarra ## 3 IVA diferenciado: ¿transitorio o permanente? https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/iva-diferenciado-transitorio-o-permanente/ Hernán Calderón ## 4 Oposición: la teleserie más mala de todas https://www.elmostrador.cl/destacado/2021/05/24/oposicion-la-teleserie-mas-mala-de-todas/ Germán Silva Cuadra ## 5 Más allá de la “emergencia”: pensar una Renta Básica Universal como política permane… https://www.elmostrador.cl/destacado/2021/05/24/mas-alla-de-la-emergencia-pensar-una-renta-basica-universal-como-politica-permanente/ Carolina Rojas Lash ## 6 La Convención constituyente y el camino de regreso a una sociedad más justa https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/la-convencion-constituyente-y-el-camino-de-regreso-a-una-sociedad-mas-ju… Enrique Fernández Darr… ## 7 ¡Distanciamiento físico, no social…por favor! https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/distanciamiento-fisico-no-socialpor-favor/ Mauricio Vial ## 8 Por fin: comenzó la competencia de medios de pago https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/por-fin-comenzo-la-competencia-de-medios-de-pago/ Diego Soffia ## 9 Boric versus Jadue https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/boric-versus-jadue/ Eugenio Rivera Urrutia ## 10 Nuestro mayor poder: la ciudadanía independiente https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/nuestro-mayor-poder-la-ciudadania-independiente/ Aleka Vial Descargar múltiples páginas con una iteración (yo ya corrí esto antes, por eso lo dejo comentado) ## walk(.x = 2:5, ## .f = ~ { ## download_html(url = glue(&quot;https://www.elmostrador.cl/noticias/opinion/columnas/page/{.x}/&quot;), ## file = glue(&quot;webs/mostrador_{.x}.html&quot;)) ## Sys.sleep(2) # pausa ## }) Nuestros pasos siguientes tendrán el objetivo de procesar estos sitios web (5, pero podrían ser muchos más) para crear una base de datos única. Ocuparemos funciones personalizadas e iteraciones en el proceso. Generalizar el proceso de limpieza de los datos con una función Lo que hicimos para obtener nuestro data frame con información (df_mostrador_p1) se puede resumir en los siguientes pasos: Descargar el sitio (ya está hecho) Cargar el html a R Extraer los vectores para título, link y autor(a), usando selectores. Crear el data frame con estos vectores. Esto puede pensarse como una “receta”, que debería funcionar para cualquier archivo (página de columnas descargada desde El Mostrador). La vamos a crear como una función personalizada: f_procesar_sitio &lt;- function(archivo){ web &lt;- read_html(archivo, encoding = &quot;UTF-8&quot;) titulos &lt;- web %&gt;% html_nodes(&quot;h4 a&quot;) %&gt;% html_text() links &lt;- web %&gt;% html_nodes(&quot;h4 a&quot;) %&gt;% html_attr(&quot;href&quot;) autores &lt;- web %&gt;% html_nodes(&quot;.col-md-10 p&quot;) %&gt;% html_text() %&gt;% str_remove(&quot;^por &quot;) df_info &lt;- tibble( titulo = titulos, link = links, autor = autores ) return(df_info) # lo que devuelve/entrega la función } Ahora la función toma cualquier archivo como argumento y nos entrega lo que esperamos: f_procesar_sitio(archivo = &quot;webs/mostrador_3.html&quot;) ## # A tibble: 10 x 3 ## titulo link autor ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Convención y participación: un camino sin retorno https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/convencion-y-participacion-un-camino-sin-retorno/ Vicente Gerlach ## 2 Arrebol de nuevos amaneceres https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/arrebol-de-nuevos-amaneceres/ María Ignacia Ibarra ## 3 IVA diferenciado: ¿transitorio o permanente? https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/iva-diferenciado-transitorio-o-permanente/ Hernán Calderón ## 4 Oposición: la teleserie más mala de todas https://www.elmostrador.cl/destacado/2021/05/24/oposicion-la-teleserie-mas-mala-de-todas/ Germán Silva Cuadra ## 5 Más allá de la “emergencia”: pensar una Renta Básica Universal como política permane… https://www.elmostrador.cl/destacado/2021/05/24/mas-alla-de-la-emergencia-pensar-una-renta-basica-universal-como-politica-permanente/ Carolina Rojas Lash ## 6 La Convención constituyente y el camino de regreso a una sociedad más justa https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/la-convencion-constituyente-y-el-camino-de-regreso-a-una-sociedad-mas-ju… Enrique Fernández Darr… ## 7 ¡Distanciamiento físico, no social…por favor! https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/distanciamiento-fisico-no-socialpor-favor/ Mauricio Vial ## 8 Por fin: comenzó la competencia de medios de pago https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/por-fin-comenzo-la-competencia-de-medios-de-pago/ Diego Soffia ## 9 Boric versus Jadue https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/boric-versus-jadue/ Eugenio Rivera Urrutia ## 10 Nuestro mayor poder: la ciudadanía independiente https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/nuestro-mayor-poder-la-ciudadania-independiente/ Aleka Vial Así, podemos iterar esta función en nuestros cinco archivos para crear una base completa (páginas 1-5). Ahora no utilizaremos walk(), sino que map_dfr() (aquí decidí no conservar el número de página). archivos &lt;- list.files(&quot;webs/&quot;, full.names = T) archivos ## [1] &quot;webs//mostrador_1.html&quot; &quot;webs//mostrador_2.html&quot; &quot;webs//mostrador_3.html&quot; &quot;webs//mostrador_4.html&quot; &quot;webs//mostrador_5.html&quot; df_mostrador_1_5 &lt;- map_dfr(.x = archivos, .f = ~ {f_procesar_sitio(.x)}) df_mostrador_1_5 ## # A tibble: 50 x 3 ## titulo link autor ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Convención y participación: un camino sin retorno https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/convencion-y-participacion-un-camino-sin-retorno/ Vicente Gerlach ## 2 Arrebol de nuevos amaneceres https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/arrebol-de-nuevos-amaneceres/ María Ignacia Ibarra ## 3 IVA diferenciado: ¿transitorio o permanente? https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/24/iva-diferenciado-transitorio-o-permanente/ Hernán Calderón ## 4 Oposición: la teleserie más mala de todas https://www.elmostrador.cl/destacado/2021/05/24/oposicion-la-teleserie-mas-mala-de-todas/ Germán Silva Cuadra ## 5 Más allá de la “emergencia”: pensar una Renta Básica Universal como política permane… https://www.elmostrador.cl/destacado/2021/05/24/mas-alla-de-la-emergencia-pensar-una-renta-basica-universal-como-politica-permanente/ Carolina Rojas Lash ## 6 La Convención constituyente y el camino de regreso a una sociedad más justa https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/la-convencion-constituyente-y-el-camino-de-regreso-a-una-sociedad-mas-ju… Enrique Fernández Darr… ## 7 ¡Distanciamiento físico, no social…por favor! https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/distanciamiento-fisico-no-socialpor-favor/ Mauricio Vial ## 8 Por fin: comenzó la competencia de medios de pago https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/por-fin-comenzo-la-competencia-de-medios-de-pago/ Diego Soffia ## 9 Boric versus Jadue https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/boric-versus-jadue/ Eugenio Rivera Urrutia ## 10 Nuestro mayor poder: la ciudadanía independiente https://www.elmostrador.cl/noticias/opinion/columnas/2021/05/23/nuestro-mayor-poder-la-ciudadania-independiente/ Aleka Vial ## # … with 40 more rows (Ejercicio b) Obtén el texto de la columna más reciente. Generaliza lo anterior en una función que tome una URL (columna de El Mostrador) y devuelva su texto. Itera la función para completar “df_mostrador_p1” con una nueva columna de texto. "]]
