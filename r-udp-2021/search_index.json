[["index.html", "Programación en Ciencias Sociales Inicio Links importantes Cronograma y materiales del curso", " Programación en Ciencias Sociales Andrés Cruz 2021-03-15 Inicio Este es el sitio web del curso Programación en Ciencias Sociales (CPO3523), dictado en el Escuela de Ciencia Política UDP durante el primer semestre de 2021. El objetivo del sitio es servir como material de consulta. Todos los proyectos que ejecutemos en RStudio Cloud estarán también compilados aquí, para facilitar su revisión. Links importantes Programa del curso Clases grabadas (acceso con cuenta UDP) RStudio Cloud (acceso con cuenta UDP) Cronograma y materiales del curso I. Introducción L 2021-03-08 Presentación del programa Ciencia de datos y programación Introducción a R, RStudio y R Markdown Material mínimo Material complementario RStudio. 2018a. Introducción al Lenguaje R: Guía Rápida. RStudio. 2018b. RStudio IDE: Guía Rápida. RStudio. 2014. RMarkdown: Hoja de Referencia. II. Manejo de bases de datos L 2021-03-15, L 2021-03-22 Introducción al tidyverse Carga de bases de datos Manejo de bases de datos Limpieza de bases Material mínimo Material complementario Cruz, A. 2020. Manejo de Datos. RStudio. 2017. Importar Datos: Guía Rápida RStudio. 2018. Transformación de Datos con dplyr: Hoja de referencia. III. Visualización de datos L 2021-03-29, L 2021-04-05 Principios de visualización de datos Introducción a la gramática de gráficos Generación de gráficos en ggplot2 Material mínimo Material complementario Healy, K. 2018. Data Visualization: A Practical Introduction. Cap. 1. Araya, S. 2020. Visualización de Datos. RStudio. 2016. Visualización de Datos usando ggplot2: Guía Rápida. Semana de receso 1: L 2021-04-12 IV. Búsqueda efectiva de ayuda L 2021-04-19 Archivos de ayuda en R. Recursos de apoyo: Google, StackOverflow, GitHub. Construcción de ejemplos mínimos reproducibles (reprex). Material mínimo Material complementario Healy, K. 2018. Data Visualization: A Practical Introduction. Anexo 1.1 Wickham, H. y Grolemund, G. 2017. R for Data Science. Sección 1.6. Mostipak, J. 2018. So Youve Been Asked to Make a Reprex. Entrega Solemne 1: L 2021-04-26 V. Manejo avanzado de bases de datos L 2021-05-03 Reformulación (pivot) de bases de datos. Recodificación de variables. Combinación (merge) de bases. Material mínimo Material complementario Urdinez, F. y Cruz, A. 2020. Manejo Avanzado de Datos Políticos. RStudio. 2017b. Importar Datos: Guía Rápida. Pág. 2. Bryan, J. 2018. Cheatsheet for dplyr join functions. VI. Análisis de texto L 2021-05-10, L 2021-05-17 Manipulación de cadenas de texto. Expresiones regulares. Introducción al análisis cuantitativo de textos (QTA). Material mínimo Material complementario Wickham, H., y Grolemund, G. 2017. R for Data Science. Cap. 14. Silge, J. y Robinson, D. 2018. Text Mining with R. Caps. 1-3. RStudio. 2017c. Trabajar con Cadenas con stringr: Guía Rápida VII. Minería de datos web y R avanzado L 2021-05-24 Tipos de objeto en R Funciones personalizadas. Iteraciones Material mínimo Material complementario Wickham, H., y Grolemund, G. 2017. R for Data Science. Caps. 19 y 21. Barría, G. 2021. Minería de Datos Web. Densmore, J. 2017. Ethics in web scraping. RStudio. 2017a. Aplicar Funciones con purrr: Guía Rápida. Entrega Ensayo Breve: L 2021-05-24 Semana de receso 2: L 2021-05-31 VIII. Replicación y generación de reportes L 2021-06-07 Replicación en ciencias sociales. R Markdown para reportes y presentaciones. Material mínimo Material complementario King, G. 1995. Replication, Replication. RStudio. 2014. RMarkdown: Hoja de Referencia. Entrega Solemne 2: L 2021-06-14 Presentaciones y retroalimentación para el trabajo final: L 2021-06-21 Feriado: L 2021-06-28 Prueba recuperativa: A fijar entre M 2021-06-29 y V 2021-07-02 IX. Datos espaciales y mapas / X. Cierre L 2021-07-05 Introducción a los datos espaciales con sf. Mapas en ggplot2. Ciencia social computacional. La comunidad de R. RStudio de escritorio. Material mínimo Material complementario Escobar, A. y Ortiz, G. 2021. Mapas y Datos Espaciales. Grimmer, J. 2015. We Are All Social Scientists Now. Frick, H., y Daish, A. 2017. R-Ladies Global Community. Garnett, R. 2018. Spatial Manipulation with sf: Cheatsheet. Entrega del trabajo escrito final: M 2021-07-06 Examen: L 2021-07-12 "],["rbasico.html", "01A - R básico Introducción: comandos y código Paquetes Comandos básicos y tipos de objeto en R Sintaxis de R Markdown Título de prueba Siguiente script", " 01A - R básico Diapositivas de introducción Si quieres correr este script localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar: tidyverse. Este es un script de R Markdown, una forma de registrar nuestro código de R. Sabemos esto por por la extensión .Rmd y todas las opciones que están fijadas más arriba (por ahora no nos concentraremos demasiado en ellas). Antes de comenzar, juguemos un poco con las opciones de RStudio. Vamos a Tools &gt; Global Options &gt; Appearance. Introducción: comandos y código En los scripts de R Markdown el texto plano (como este) nos permite añadir comentarios, explicaciones, etc. Cuando ocupemos código debemos insertarlo en chunks o bloques de código, como veremos a continuación. Haremos un bloque de código para ocupar R como una calculadora simple. Podemos correr el código línea por línea con Ctrl/Cmd + Enter, si nuestro teclado está en dicha parte del script. Para correr el chunk completo puedes presionar en el pequeño botón de Play en la parte superior derecha o presionar Ctrl/Cmd + Shift + Enter. 1 + 5 ## [1] 6 78878.12 * 8e05 / (12 - 7 + 87.2) # este es un comentario &quot;en línea&quot;, se antecede con un # ## [1] 684408850 Para crear un chunk, debes presionar Ctrl/Cmd + Alt + i. Prueba a crear un chunk y calcula alguna operación aritmética. Tu código: En R podemos crear objetos, que guardarán información para ser utilizada en operaciones siguientes: mi_objeto &lt;- 5 mi_objeto # poner su nombre lo imprime, sin más ## [1] 5 Por ejemplo, podemos hacer aritmética con este nuevo objeto: mi_objeto - 17 ## [1] -12 ¿Cuál es la diferencia entre este último comando y el siguiente? mi_objeto_b &lt;- mi_objeto - 17 Eliminemos este segundo objeto, utilizando la funcion rm() (remove): rm(mi_objeto_b) Si quisiéramos reiniciar la sesión (comenzando todo desde cero), podríamos presionar Session &gt; Restart R) y clickear en la escoba del panel Environment de RStudio (superior derecho). Paquetes Los paquetes añaden nuevas funciones a R. Hay que cargarlos en cada nueva sesión, con el comando library(). library(tidyverse) El tidyverse es un paquete que ocuparemos en todas nuestras clases, que añade una gran cantidad de funciones al lenguaje. Ojo! library() solo nos permite cargar paquetes que hayamos instalado. Aquí en RStudio Cloud yo instalé el tidyverse para todas/os, pero por defecto habría que instalarlo. Probemos a utilizar otro paquete, fun: library(fun) Debemos instalarlo. Basta con instalar los paquetes una vez, luego podremos cargarlos en cada sesión que queramos. La mayoría de los paquetes se instalan con el comando install.packages(\"paquete\"): install.packages(&quot;fun&quot;) Por cierto, podemos saber que R está trabajando gracias a RStudio. Mientras el paquete se instala, fíjate que hay una pequeña línea (¿color?) en la parte izquierda del código. Terminada la instalación, carguemos el nuevo paquete: library(fun) # ahora el paquete está instalado, por lo que carga sin problemas (Ejercicio A) Prueba a instalar un paquete llamado fun. Luego, cárgalo y corre el siguiente comando: random_password(). ¿Qué hace? Recuerda registrar todo el proceso en el script! Tu código: Comandos básicos y tipos de objeto en R En esta sección veremos vectores, data frames (marcos de datos) y listas. Vectores Lo siguiente es un vector numérico: c(7, 9, 19, 2, 9) ## [1] 7 9 19 2 9 El siguiente comando creará un objeto (mi_vector). ¿Qué contendrá este nuevo objeto? mi_vector &lt;- c(2, -3, mi_objeto, 6:9) Veamos algunos comandos básicos a aplicar en números y vectores numéricos. mi_vector[2] # acceder al segundo elemento del vector ## [1] -3 sqrt(x = mi_objeto) # la raíz cuadrada es una función! ## [1] 2.236068 log(x = mi_objeto) # logaritmo natural ## [1] 1.609438 mean(x = mi_vector) # media del vector ## [1] 4.857143 media_mi_vector &lt;- mean(x = mi_vector) # si quisiéramos guardarla como objeto! median(x = mi_vector) # mediana del vector ## [1] 6 quantile(x = mi_vector, probs = c(0.25, 0.5, 0.75)) # q1, q2, q3 ## 25% 50% 75% ## 3.5 6.0 7.5 sd(x = mi_vector) # desviación estándar del vector ## [1] 4.140393 length(x = mi_vector) # número de elementos del vector ## [1] 7 sum(x = mi_vector) # suma del vector ## [1] 34 min(x = mi_vector) # ¿qué hace esta función? ## [1] -3 max(x = mi_vector) # ¿y esta? ## [1] 9 Todas las funciones que hemos visto simplemente tomaban un objeto, sin más. La mayoría de las funciones son más complejas: requieren más de un objeto o nos permiten integrar más opciones. Les damos instrucciones específicas a las funciones por medio de argumentos (hasta ahora, solo vimos funciones con el inicio de argumento x =). sort(x = mi_vector) # ordena el vector de menor a mayor ## [1] -3 2 5 6 7 8 9 sort(x = mi_vector, decreasing = TRUE) # ¿qué cambia con este argumento? ## [1] 9 8 7 6 5 2 -3 Nota que podemos añadir saltos de línea entre argumentos: sort(x = mi_vector, decreasing = TRUE) ## [1] 9 8 7 6 5 2 -3 Importante. Si ponemos los valores de los argumentos en orden, podemos evitar escribir los argumentos mismos: sort(mi_vector, TRUE) # igual resultado que nuestros comandos anteriores ## [1] 9 8 7 6 5 2 -3 Por cierto, podemos consultar el archivo de ayuda de una función fácilmente. Ahí encontraremos los distintos argumentos explicados: ?sort Los vectores también pueden ser de otros tipos: c(&quot;Manzana&quot;, &quot;Pera&quot;, &quot;Naranja&quot;, &quot;Damasco&quot;) # vector de caracteres. Nota las comillas! ## [1] &quot;Manzana&quot; &quot;Pera&quot; &quot;Naranja&quot; &quot;Damasco&quot; nchar(&quot;Manzana&quot;) # cuenta los caracteres de un elemento ## [1] 7 c(TRUE, FALSE, TRUE, TRUE) # vector lógico ## [1] TRUE FALSE TRUE TRUE c(T, F, T, T) ## [1] TRUE FALSE TRUE TRUE (Ejercicio B) De nuevo ocupa la función random_password() del paquete fun, pero esta vez con el argumento length = 10. Prueba con diferentes valores del argumento! Tu código: Data frames (marcos de datos) Los data frames son objetos centrales en R, sin duda los que más utilizaremos. Vamos a cargar uno simple: df_trump_scores &lt;- read_csv(&quot;datos/trump_scores_202003_cong116.csv&quot;) # esta función es del tidyverse! ## Parsed with column specification: ## cols( ## last_name = col_character(), ## state = col_character(), ## party = col_character(), ## trump_score = col_double(), ## trump_margin = col_double() ## ) El Trump Score es el porcentaje de votaciones en las que un senador/a ha estado alineado/a con Donald Trump. El Trump Margin es el margen que Trump obtuvo en el estado del senador/a en cuestión. Fuente: FiveThirtyEight (2020). Descargado el 11 de marzo de 2020. df_trump_scores # imprime un vistazo rápido ## # A tibble: 100 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 ## 7 Blackburn TN R 93.9 26.0 ## 8 Barrasso WY R 91.2 46.3 ## 9 Bennet CO D 15.4 -4.91 ## 10 Blumenth~ CT D 11.8 -13.6 ## # ... with 90 more rows head(df_trump_scores) # imprime solo las seis primeras filas ## # A tibble: 6 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 También podemos inspeccionar un data frame clickeando su nombre en el panel superior derecho, pestaña Environment. Las columnas de un data frame son vectores! df_trump_scores$last_name ## [1] &quot;Alexander&quot; &quot;Blunt&quot; ## [3] &quot;Brown&quot; &quot;Burr&quot; ## [5] &quot;Baldwin&quot; &quot;Boozman&quot; ## [7] &quot;Blackburn&quot; &quot;Barrasso&quot; ## [9] &quot;Bennet&quot; &quot;Blumenthal&quot; ## [11] &quot;Booker&quot; &quot;Braun&quot; ## [13] &quot;Cantwell&quot; &quot;Cardin&quot; ## [15] &quot;Carper&quot; &quot;Crapo&quot; ## [17] &quot;Collins&quot; &quot;Capito&quot; ## [19] &quot;Cornyn&quot; &quot;Casey&quot; ## [21] &quot;Cassidy&quot; &quot;Coons&quot; ## [23] &quot;Cotton&quot; &quot;Cramer&quot; ## [25] &quot;Cruz&quot; &quot;Cortez Masto&quot; ## [27] &quot;Durbin&quot; &quot;Daines&quot; ## [29] &quot;Duckworth&quot; &quot;Enzi&quot; ## [31] &quot;Ernst&quot; &quot;Feinstein&quot; ## [33] &quot;Fischer&quot; &quot;Graham&quot; ## [35] &quot;Grassley&quot; &quot;Gillibrand&quot; ## [37] &quot;Gardner&quot; &quot;Hirono&quot; ## [39] &quot;Heinrich&quot; &quot;Hoeven&quot; ## [41] &quot;Harris&quot; &quot;Hassan&quot; ## [43] &quot;Hyde-Smith&quot; &quot;Hawley&quot; ## [45] &quot;Inhofe&quot; &quot;Johnson&quot; ## [47] &quot;Jones&quot; &quot;Klobuchar&quot; ## [49] &quot;King&quot; &quot;Kaine&quot; ## [51] &quot;Kennedy&quot; &quot;Leahy&quot; ## [53] &quot;Lankford&quot; &quot;Lee&quot; ## [55] &quot;Loeffler&quot; &quot;Markey&quot; ## [57] &quot;McConnell&quot; &quot;Menendez&quot; ## [59] &quot;Moran&quot; &quot;Murray&quot; ## [61] &quot;Murkowski&quot; &quot;Murphy&quot; ## [63] &quot;Merkley&quot; &quot;Manchin&quot; ## [65] &quot;McSally&quot; &quot;Portman&quot; ## [67] &quot;Peters&quot; &quot;Paul&quot; ## [69] &quot;Perdue&quot; &quot;Reed&quot; ## [71] &quot;Roberts&quot; &quot;Risch&quot; ## [73] &quot;Rubio&quot; &quot;Rounds&quot; ## [75] &quot;Rosen&quot; &quot;Romney&quot; ## [77] &quot;Sanders&quot; &quot;Schumer&quot; ## [79] &quot;Shelby&quot; &quot;Stabenow&quot; ## [81] &quot;Shaheen&quot; &quot;Scott&quot; ## [83] &quot;Sinema&quot; &quot;Schatz&quot; ## [85] &quot;Sasse&quot; &quot;Sullivan&quot; ## [87] &quot;Smith&quot; &quot;Scott&quot; ## [89] &quot;Thune&quot; &quot;Toomey&quot; ## [91] &quot;Tester&quot; &quot;Tillis&quot; ## [93] &quot;Udall&quot; &quot;Van Hollen&quot; ## [95] &quot;Wicker&quot; &quot;Wyden&quot; ## [97] &quot;Whitehouse&quot; &quot;Warner&quot; ## [99] &quot;Warren&quot; &quot;Young&quot; df_trump_scores$trump_score ## [1] 80.000000 84.848485 14.705882 90.322581 ## [5] 14.705882 88.235294 93.939394 91.176471 ## [9] 15.384615 11.764706 4.166667 94.117647 ## [13] 15.151515 15.151515 11.764706 93.548387 ## [17] 41.176471 93.939394 91.176471 20.588235 ## [21] 84.848485 14.705882 82.352941 90.909091 ## [25] 93.750000 11.764706 18.181818 79.411765 ## [29] 16.129032 90.909091 91.176471 14.705882 ## [33] 88.235294 76.666667 91.176471 7.692308 ## [37] 83.870968 14.705882 20.588235 91.176471 ## [41] 4.545455 14.705882 91.176471 85.294118 ## [45] 90.909091 91.176471 21.212121 7.692308 ## [49] 17.647059 14.705882 88.235294 14.705882 ## [53] 88.235294 63.636364 100.000000 8.823529 ## [57] 91.176471 11.764706 57.575758 14.705882 ## [61] 56.250000 17.647059 11.764706 32.352941 ## [65] 91.176471 84.848485 14.705882 60.714286 ## [69] 92.857143 8.823529 91.176471 90.625000 ## [73] 81.250000 92.857143 12.500000 79.411765 ## [77] 5.263158 11.764706 91.176471 14.705882 ## [81] 14.705882 87.500000 24.242424 11.764706 ## [85] 87.500000 90.322581 17.647059 91.176471 ## [89] 91.176471 84.375000 11.764706 88.235294 ## [93] 17.647059 14.705882 85.294118 8.823529 ## [97] 9.375000 14.705882 9.090909 64.705882 Producto de esto, podemos operar en ellas usando las funciones que aprendimos antes. (Ejercicio C) Calcula la mediana de los Trumps Scores y la mediana de los Trump Margins. Tu código: Ejemplos de análisis con data frames En general, la forma de data frame nos es útil para correr análisis. Aquí un gráfico exploratorio (no miraremos demasiado la sintaxis): ggplot(data = df_trump_scores, mapping = aes(x = trump_margin, trump_score, color = party)) + geom_point() + scale_color_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) Aquí una regresión lineal, que busca estimar el Trump Score de un senador/a de acuerdo a dos predictores: el margen de Trump en su estado y su partido político: mi_modelo &lt;- lm(trump_score ~ trump_margin + party, data = df_trump_scores) summary(mi_modelo) ## ## Call: ## lm(formula = trump_score ~ trump_margin + party, data = df_trump_scores) ## ## Residuals: ## Min 1Q Median 3Q Max ## -40.151 -1.952 1.599 4.487 17.239 ## ## Coefficients: ## Estimate Std. Error t value ## (Intercept) 15.71390 1.40190 11.209 ## trump_margin 0.17650 0.06248 2.825 ## partyR 66.13619 2.50530 26.399 ## Pr(&gt;|t|) ## (Intercept) &lt; 2e-16 *** ## trump_margin 0.00574 ** ## partyR &lt; 2e-16 *** ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.623 on 97 degrees of freedom ## Multiple R-squared: 0.9463, Adjusted R-squared: 0.9452 ## F-statistic: 854.5 on 2 and 97 DF, p-value: &lt; 2.2e-16 Listas Las listas son objetos que pueden contener otros objetos, sin importar su tipo! mi_lista &lt;- list(mi_objeto, mi_vector, df_trump_scores, mi_modelo) De la siguiente forma podemos acceder a los elementos de una lista, similar a lo que hicimos antes con vectores: mi_lista[3] ## [[1]] ## # A tibble: 100 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 ## 7 Blackburn TN R 93.9 26.0 ## 8 Barrasso WY R 91.2 46.3 ## 9 Bennet CO D 15.4 -4.91 ## 10 Blumenth~ CT D 11.8 -13.6 ## # ... with 90 more rows mi_lista[[3]] ## # A tibble: 100 x 5 ## last_name state party trump_score trump_margin ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Alexander TN R 80 26.0 ## 2 Blunt MO R 84.8 18.6 ## 3 Brown OH D 14.7 8.13 ## 4 Burr NC R 90.3 3.66 ## 5 Baldwin WI D 14.7 0.764 ## 6 Boozman AR R 88.2 26.9 ## 7 Blackburn TN R 93.9 26.0 ## 8 Barrasso WY R 91.2 46.3 ## 9 Bennet CO D 15.4 -4.91 ## 10 Blumenth~ CT D 11.8 -13.6 ## # ... with 90 more rows ¿Cuál es la diferencia entre estos dos últimos comandos? El primero devuelve una nueva lista con solo un elemento, el tercero de la lista original. El segundo, en tanto, devuelve el contenido del tercer elemento de la lista. Sintaxis de R Markdown En el texto de nuestros documentos podemos escribir en cursiva o negrita. También podemos insertar links. Usualmente cuando queremos hablar de paquetes o funciones dentro de nuestro texto los escribimos entre tildes invertidos: tidyverse, mean(). Crear tablas también es relativamente simple. Con texto: Nombre Descripción Juan Un estudiante Marta Una estudiante O a partir de un data frame, con código: library(knitr) kable(head(df_trump_scores)) last_name state party trump_score trump_margin Alexander TN R 80.00000 26.0057009 Blunt MO R 84.84848 18.6371170 Brown OH D 14.70588 8.1295744 Burr NC R 90.32258 3.6552285 Baldwin WI D 14.70588 0.7643432 Boozman AR R 88.23529 26.9209780 Importante. Por favor noten que la primera tabla ocupa sintaxis de R Markdown en vez de código de R, por lo que no está dentro de un chunk! También podemos incluir ecuaciones, escritas entre signos de peso con la sintaxis de \\(\\LaTeX\\). Un ejemplo: \\(\\hat{\\beta}=(X&#39;X)^{-1}X&#39;Y\\). Título de prueba Subtítulo Una lista Artículo de lista uno Artículo de lista dos Artículo derivado (nota los cuatro espacios antes del símbolo +). Artículo de lista tres Otra lista (ahora ordenada) Artículo de lista uno Artículo de lista dos Artículo de lista tres Nota que los números de la lista aparecerán solos en el documento compilado. Una imagen Podemos insertar una imagen, referenciando su ubicación en nuestra carpeta del proyecto: Compilar nuestro documento Podemos compilar nuestro código a un documento utilizando el botón Knit en RStudio, o presionando Ctrl/Cmd + Shift + K. (Ejercicio D) Crea un vector numérico, que vaya desde 4 hasta 109. Luego, calcula su media y mediana. Recuerda crear tu(s) chunk(s) con Ctrl/Cmd + Alt + i. Siguiente script Pasemos brevemente a ver el script 01b. "],["manejo-02a.html", "02A - Manejo de datos Manejo de bases de datos La base de datos ideal: tidy Operaciones básicas en bases de datos (Wickham, 2014) Trabajo con R Manejo de datos: operaciones básicas Agregar/colapsar con summarize() / hacer operaciones por grupos con group_by() Hacer cadenas de operaciones con las pipes (%&gt;%)", " 02A - Manejo de datos Si quieres correr este script localmente, acá puedes descargar el proyecto comprimido en .zip. Paquetes que necesitas tener instalados antes de comenzar con el proyecto (2A, 2B, 2C, 2D): tidyverse, janitor, writexl, learnr. Manejo de bases de datos Manejo de datos = limpiar y ordenar datos para poder analizarlos. Se suele decir que el 80% del análisis de datos es solo manejo (Wickham, 2014). Fuente: Wickham &amp; Grolemund (2017) Partes de una base de datos tabular Encabezado (header) Fila (row) Columna (column) Celda (cell) Una pequeña mnemotecnia: La base de datos ideal: tidy En el paradigma tidy (Wickham, 2014): Cada variable es una columna Cada observación es una fila Cada valor es una celda Existe una base de datos para cada unidad observacional (Ejercicio A) Por favor revisar este link. Contiene un panel para las emisiones anuales de CO2 de los países americanos (unidad de medida: toneladas per capita). Hay tres bases con la misma información, una por cada hoja. ¿Cuál es la tidy? Operaciones básicas en bases de datos (Wickham, 2014) Transformar columnas (añadir o modificar existentes) Puede ser en una sola columna o en múltiples columnas En el tidyverse, mutate() Seleccionar columnas (y excluir otras) En el tidyverse, select() Filtrar observaciones en base a una condición En el tidyverse, filter() Ordenar la base de datos, en base a una(s) variable(s) En el tidyverse, arrange() Agregar/colapsar la base de datos Colapsar múltiples valores en algún resumen (por ejemplo, media o suma) Puede ser para toda la base o por subgrupos En el tidyverse, summarize() (Ejercicio B) Favor ir a este link ¿Qué operaciones básicas pueden ser interesantes para comenzar a analizar estos datos? Contesta con dos ejemplos: Trabajo con R Comenzaremos cargando el tidyverse: library(tidyverse) Base de datos: aprobación de presidentes/as en Latinoamérica Tenemos una base de datos ligeramente editada a partir de Reyes-Housholder (2019). Incluye también un par de variables de los World Development Indicators, recopiladas por Quality of Government. La base de datos se encuentra en datos/base_aprob_reyes-housholder.csv. Contiene información de la aprobación de presidentes/as en 17 países de América Latina por trimestre (2000-2014), además de variables de control. ¿Cuál es la unidad de análisis de la base? ¿Cuántas observaciones tendrá, asumiendo un panel balanceado? Carga de base en formato csv df_aprob &lt;- read_csv(&quot;datos/base_aprob_reyes-housholder.csv&quot;) ## Parsed with column specification: ## cols( ## country = col_character(), ## year = col_double(), ## quarter = col_double(), ## president = col_character(), ## net_approval = col_double(), ## pres_sex = col_character(), ## pres_sex_d = col_double(), ## exec_corr = col_double(), ## gdp_growth = col_double(), ## unemp = col_double(), ## wdi_gdp = col_double(), ## wdi_pop = col_double() ## ) Resúmenes simples para data frames El resumen más simple de un objeto en R suele poder obtenerse con su nombre comando. Nota cómo debajo de cada nombre, algunas variables tienen &lt;dbl&gt; y otras &lt;chr&gt;. ¿Qué significa esto? df_aprob ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Por cierto, podemos obtener un resumen similar clickeando nuestro objeto en el panel Environment (superior derecho) de RStudio. Esto es lo mismo que ocupar el comando View(): View(df_aprob) Otro resumen útil es la función glimpse() del tidyverse, que nos da otra perspectiva: glimpse(df_aprob) ## Rows: 1,020 ## Columns: 12 ## $ country &lt;chr&gt; &quot;Argentina&quot;, &quot;Argentina... ## $ year &lt;dbl&gt; 2000, 2000, 2000, 2000,... ## $ quarter &lt;dbl&gt; 1, 2, 3, 4, 1, 2, 3, 4,... ## $ president &lt;chr&gt; &quot;Fernando de la Rúa&quot;, &quot;... ## $ net_approval &lt;dbl&gt; 40.126, 16.390, 23.968,... ## $ pres_sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;, &quot;male&quot;,... ## $ pres_sex_d &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0,... ## $ exec_corr &lt;dbl&gt; 14.01525, 14.01525, 14.... ## $ gdp_growth &lt;dbl&gt; -0.8, -0.8, -0.8, -0.8,... ## $ unemp &lt;dbl&gt; 15.0000, 15.0000, 15.00... ## $ wdi_gdp &lt;dbl&gt; 552151219031, 552151219... ## $ wdi_pop &lt;dbl&gt; 37057452, 37057452, 370... ¿Qué significan las variables de esta base de datos? Completa la siguiente tabla: Variable Descripción country País. year Año. quarter Trimestre. president Presidente/a. net_approval Aprobación neta del presidente/a (% aprobación - % rechazo). pres_sex pres_sex_d exec_corr Corrupción en el Ejecutivo, según V-Dem. De 0 a 100 (mayor es más corrupción). gdp_growth unemp wdi_gdp Producto interno bruto del país, ajustado por paridad de cambio (PPP) y constante en dólares del 2011. wdi_pop Manejo de datos: operaciones básicas En todas las operaciones básicas que veremos hoy el primer argumento en la función será el data frame a editar. Seleccionar columnas con select() Seleccionemos solo la columna de países: select(df_aprob, country) ## # A tibble: 1,020 x 1 ## country ## &lt;chr&gt; ## 1 Argentina ## 2 Argentina ## 3 Argentina ## 4 Argentina ## 5 Argentina ## 6 Argentina ## 7 Argentina ## 8 Argentina ## 9 Argentina ## 10 Argentina ## # ... with 1,010 more rows Recuerda que esto no creó ningún objeto nuevo, es solo un comando que estamos ejecutando en la consola. Si quisiéramos crear un objeto nuevo, tendríamos que asignarlo: df_aprob_reducida &lt;- select(df_aprob, country) df_aprob_reducida ## # A tibble: 1,020 x 1 ## country ## &lt;chr&gt; ## 1 Argentina ## 2 Argentina ## 3 Argentina ## 4 Argentina ## 5 Argentina ## 6 Argentina ## 7 Argentina ## 8 Argentina ## 9 Argentina ## 10 Argentina ## # ... with 1,010 more rows Podemos seleccionar múltiples columnas a la vez, separadas por comas: select(df_aprob, country, year, unemp) ## # A tibble: 1,020 x 3 ## country year unemp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 2000 15 ## 2 Argentina 2000 15 ## 3 Argentina 2000 15 ## 4 Argentina 2000 15 ## 5 Argentina 2001 18.3 ## 6 Argentina 2001 18.3 ## 7 Argentina 2001 18.3 ## 8 Argentina 2001 18.3 ## 9 Argentina 2002 17.9 ## 10 Argentina 2002 17.9 ## # ... with 1,010 more rows Supongamos que queremos las primeras cinco variables de la base de datos. Las siguientes tres formas nos permitirán obtenerlas: select(df_aprob, country, year, quarter, president, net_approval) ## # A tibble: 1,020 x 5 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando ~ 40.1 ## 2 Argenti~ 2000 2 Fernando ~ 16.4 ## 3 Argenti~ 2000 3 Fernando ~ 24.0 ## 4 Argenti~ 2000 4 Fernando ~ -18.3 ## 5 Argenti~ 2001 1 Fernando ~ -6.97 ## 6 Argenti~ 2001 2 Fernando ~ -20.1 ## 7 Argenti~ 2001 3 Fernando ~ -19.4 ## 8 Argenti~ 2001 4 Fernando ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo A~ -2.01 ## 10 Argenti~ 2002 2 Eduardo A~ -20.1 ## # ... with 1,010 more rows select(df_aprob, country:net_approval) # esta es la forma recomendada para la mayoría de los casos ## # A tibble: 1,020 x 5 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando ~ 40.1 ## 2 Argenti~ 2000 2 Fernando ~ 16.4 ## 3 Argenti~ 2000 3 Fernando ~ 24.0 ## 4 Argenti~ 2000 4 Fernando ~ -18.3 ## 5 Argenti~ 2001 1 Fernando ~ -6.97 ## 6 Argenti~ 2001 2 Fernando ~ -20.1 ## 7 Argenti~ 2001 3 Fernando ~ -19.4 ## 8 Argenti~ 2001 4 Fernando ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo A~ -2.01 ## 10 Argenti~ 2002 2 Eduardo A~ -20.1 ## # ... with 1,010 more rows select(df_aprob, 1:5) ## # A tibble: 1,020 x 5 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argenti~ 2000 1 Fernando ~ 40.1 ## 2 Argenti~ 2000 2 Fernando ~ 16.4 ## 3 Argenti~ 2000 3 Fernando ~ 24.0 ## 4 Argenti~ 2000 4 Fernando ~ -18.3 ## 5 Argenti~ 2001 1 Fernando ~ -6.97 ## 6 Argenti~ 2001 2 Fernando ~ -20.1 ## 7 Argenti~ 2001 3 Fernando ~ -19.4 ## 8 Argenti~ 2001 4 Fernando ~ -23.2 ## 9 Argenti~ 2002 1 Eduardo A~ -2.01 ## 10 Argenti~ 2002 2 Eduardo A~ -20.1 ## # ... with 1,010 more rows El comando select() también nos sirve para reordenar las columnas. Supongamos que queremos que la variable president sea la primera. Podemos hacer algo como esto: select(df_aprob, president, country:year, net_approval:unemp) ## # A tibble: 1,020 x 9 ## president country year net_approval pres_sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Fernando~ Argent~ 2000 40.1 male ## 2 Fernando~ Argent~ 2000 16.4 male ## 3 Fernando~ Argent~ 2000 24.0 male ## 4 Fernando~ Argent~ 2000 -18.3 male ## 5 Fernando~ Argent~ 2001 -6.97 male ## 6 Fernando~ Argent~ 2001 -20.1 male ## 7 Fernando~ Argent~ 2001 -19.4 male ## 8 Fernando~ Argent~ 2001 -23.2 male ## 9 Eduardo ~ Argent~ 2002 -2.01 male ## 10 Eduardo ~ Argent~ 2002 -20.1 male ## # ... with 1,010 more rows, and 4 more ## # variables: pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt; Esta forma es un poco tediosa. Hay una función de ayuda que nos será útil en este caso, se llama everything() select(df_aprob, president, everything()) # selecciona &quot;president&quot; y todo lo demás ## # A tibble: 1,020 x 12 ## president country year quarter net_approval ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Fernando~ Argent~ 2000 1 40.1 ## 2 Fernando~ Argent~ 2000 2 16.4 ## 3 Fernando~ Argent~ 2000 3 24.0 ## 4 Fernando~ Argent~ 2000 4 -18.3 ## 5 Fernando~ Argent~ 2001 1 -6.97 ## 6 Fernando~ Argent~ 2001 2 -20.1 ## 7 Fernando~ Argent~ 2001 3 -19.4 ## 8 Fernando~ Argent~ 2001 4 -23.2 ## 9 Eduardo ~ Argent~ 2002 1 -2.01 ## 10 Eduardo ~ Argent~ 2002 2 -20.1 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Finalmente, también podemos excluir variables con un signo -: select(df_aprob, -president) ## # A tibble: 1,020 x 11 ## country year quarter net_approval pres_sex ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Argent~ 2000 1 40.1 male ## 2 Argent~ 2000 2 16.4 male ## 3 Argent~ 2000 3 24.0 male ## 4 Argent~ 2000 4 -18.3 male ## 5 Argent~ 2001 1 -6.97 male ## 6 Argent~ 2001 2 -20.1 male ## 7 Argent~ 2001 3 -19.4 male ## 8 Argent~ 2001 4 -23.2 male ## 9 Argent~ 2002 1 -2.01 male ## 10 Argent~ 2002 2 -20.1 male ## # ... with 1,010 more rows, and 6 more ## # variables: pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Renombrar columnas con rename() Podemos cambiar el nombre de una columna con el comando rename(). Por ejemplo: rename(df_aprob, trimeste = quarter) # noten que no estoy modificando la base, solo imprimiéndola! ## # A tibble: 1,020 x 12 ## country year trimeste president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Filtrar observaciones con filter() A menudo queremos quedarnos solo con algunas observaciones de nuestra base de datos, filtrando de acuerdo a características específicas. Podemos hacer esto gracias a la función filter() y algo llamado operadores lógicos. Para comenzar, quedémonos solo con las observaciones de Chile: filter(df_aprob, country == &quot;Chile&quot;) ## # A tibble: 60 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Chile 2000 1 Eduardo ~ 6.22 ## 2 Chile 2000 2 Ricardo ~ 19.8 ## 3 Chile 2000 3 Ricardo ~ 19.5 ## 4 Chile 2000 4 Ricardo ~ 14.8 ## 5 Chile 2001 1 Ricardo ~ 7.99 ## 6 Chile 2001 2 Ricardo ~ 1.81 ## 7 Chile 2001 3 Ricardo ~ -1.40 ## 8 Chile 2001 4 Ricardo ~ 6.90 ## 9 Chile 2002 1 Ricardo ~ 6.60 ## 10 Chile 2002 2 Ricardo ~ 3.65 ## # ... with 50 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Le estamos diciendo a filter(), por medio del segundo argumento, que solo se quede con observaciones en las que la variable country es igual a Chile. Este es igual a es un operador lógico, que se escribe como == en R. Aquí hay una lista de operadores lógicos comunes: operador descripción == es igual a != es distinto a &gt; es mayor a &lt; es menor a &gt;= es mayor o igual a &lt;= es menor o igual a &amp; intersección | unión %in% está contenido en Por ejemplo, podemos obtener todas las observaciones (país-año-trimestre) en las que la aprobación presidencial neta es positiva: filter(df_aprob, net_approval &gt; 0) ## # A tibble: 709 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2003 2 Eduardo ~ 26.5 ## 5 Argent~ 2003 3 Néstor C~ 53.7 ## 6 Argent~ 2003 4 Néstor C~ 53.0 ## 7 Argent~ 2004 1 Néstor C~ 57.1 ## 8 Argent~ 2004 2 Néstor C~ 52.8 ## 9 Argent~ 2004 3 Néstor C~ 39.1 ## 10 Argent~ 2004 4 Néstor C~ 44.9 ## # ... with 699 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Podemos también realizar filtros más complejos. Obtengamos solo las observaciones del Cono Sur: filter(df_aprob, country == &quot;Argentina&quot; | country == &quot;Chile&quot; | country == &quot;Uruguay&quot;) ## # A tibble: 180 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 170 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; filter(df_aprob, country %in% c(&quot;Argentina&quot;, &quot;Chile&quot;, &quot;Uruguay&quot;)) # lo mismo, con otro op. lógico ## # A tibble: 180 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 170 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Podemos también incluir pequeñas operaciones en nuestros filtros. Obtengamos todas las observaciones en las que la corrupción ejecutiva es mayor a la del promedio de toda la base: filter(df_aprob, exec_corr &gt; mean(exec_corr)) ## # A tibble: 456 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2003 1 Eduardo ~ -2.78 ## 2 Argent~ 2003 2 Eduardo ~ 26.5 ## 3 Argent~ 2003 3 Néstor C~ 53.7 ## 4 Argent~ 2003 4 Néstor C~ 53.0 ## 5 Argent~ 2004 1 Néstor C~ 57.1 ## 6 Argent~ 2004 2 Néstor C~ 52.8 ## 7 Argent~ 2004 3 Néstor C~ 39.1 ## 8 Argent~ 2004 4 Néstor C~ 44.9 ## 9 Argent~ 2005 1 Néstor C~ 45.7 ## 10 Argent~ 2005 2 Néstor C~ 45.4 ## # ... with 446 more rows, and 7 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; (Ejercicios C) (C1) Selecciona solo las dos columnas que registran el sexo del presidente/a en la base de datos. Recuerda que los chunks se insertan con Ctrl/Cmd + Alt + i. Tu código: (C2) Filtra la base de datos para que solo tenga las observaciones del año 2000. Tu código: (C3) Filtra la base de datos para que solo incluya observaciones de crisis económica: cuando el crecimiento del PIB sea negativo y/o el desempleo sea mayor al 20%. Tu código: Ordenar el data frame con arrange() Podemos cambiar el orden de las observaciones con el comando arrange(). Por ejemplo, ordenémoslas desde el país-año-trimestre menos corrupto al más corrupto: arrange(df_aprob, exec_corr) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Uruguay 2000 1 Julio Sa~ 41.2 ## 2 Uruguay 2000 2 Jorge Ba~ 45.4 ## 3 Uruguay 2000 3 Jorge Ba~ 31.4 ## 4 Uruguay 2000 4 Jorge Ba~ 18.1 ## 5 Uruguay 2001 1 Jorge Ba~ 18.5 ## 6 Uruguay 2001 2 Jorge Ba~ 17.8 ## 7 Uruguay 2001 3 Jorge Ba~ 15.9 ## 8 Uruguay 2001 4 Jorge Ba~ 14.5 ## 9 Uruguay 2002 1 Jorge Ba~ 6.36 ## 10 Uruguay 2002 2 Jorge Ba~ -6.37 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Si quisiéramos ordenarlo inversamente, tendríamos que añadir un - (signo menos) antes de la variable: arrange(df_aprob, -exec_corr) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Venezu~ 2013 1 Hugo Chá~ -12.6 ## 2 Venezu~ 2013 2 Nicolás ~ -13.7 ## 3 Venezu~ 2013 3 Nicolás ~ -16.8 ## 4 Venezu~ 2013 4 Nicolás ~ -16.6 ## 5 Venezu~ 2014 1 Nicolás ~ -18.1 ## 6 Venezu~ 2014 2 Nicolás ~ -19.4 ## 7 Venezu~ 2014 3 Nicolás ~ -22.1 ## 8 Venezu~ 2014 4 Nicolás ~ -24.9 ## 9 Venezu~ 2007 1 Hugo Chá~ -10.2 ## 10 Venezu~ 2007 2 Hugo Chá~ -11.0 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Atención, lo anterior solo sirve en columnas numéricas. Para ordenar una categórica inversamente, debemos usar el comando desc(): arrange(df_aprob, desc(country)) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Venezu~ 2000 1 Hugo Chá~ -7.14 ## 2 Venezu~ 2000 2 Hugo Chá~ -10.6 ## 3 Venezu~ 2000 3 Hugo Chá~ -11.2 ## 4 Venezu~ 2000 4 Hugo Chá~ -11.1 ## 5 Venezu~ 2001 1 Hugo Chá~ -10.4 ## 6 Venezu~ 2001 2 Hugo Chá~ -11.7 ## 7 Venezu~ 2001 3 Hugo Chá~ -14.5 ## 8 Venezu~ 2001 4 Hugo Chá~ -19.5 ## 9 Venezu~ 2002 1 Hugo Chá~ -21.5 ## 10 Venezu~ 2002 2 Hugo Chá~ -20.8 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Podemos ordenar por más de una variable. Esto es, ordenar a partir de una primera variable y luego ordenar los empates a partir de otra segunda variable. Veamos el siguiente ejemplo: arrange(df_aprob, pres_sex, -net_approval) ## # A tibble: 1,020 x 12 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Brazil 2013 1 Dilma Va~ 62.5 ## 2 Brazil 2012 4 Dilma Va~ 60.9 ## 3 Brazil 2012 2 Dilma Va~ 60.5 ## 4 Brazil 2012 3 Dilma Va~ 58.7 ## 5 Brazil 2012 1 Dilma Va~ 57.2 ## 6 Brazil 2011 4 Dilma Va~ 54.3 ## 7 Brazil 2011 1 Dilma Va~ 47.7 ## 8 Brazil 2011 3 Dilma Va~ 45.6 ## 9 Brazil 2013 2 Dilma Va~ 44.4 ## 10 Argent~ 2011 4 Cristina~ 44.3 ## # ... with 1,010 more rows, and 7 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt; Transformar variables con mutate() Transformaciones con una variable Supongamos que queremos crear una variable con el PIB en versión logarítmica: mutate(df_aprob, wdi_gdp_log = log(wdi_gdp)) ## # A tibble: 1,020 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 1,010 more rows, and 8 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_gdp_log &lt;dbl&gt; Podemos realizar cualquier tipo de operación en las variables. Por ejemplo, transformemos la escala de wdi_pop a millones: mutate(df_aprob, wdi_pop_mill = wdi_pop / 1000000) ## # A tibble: 1,020 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 1,010 more rows, and 8 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_pop_mill &lt;dbl&gt; Transformaciones con múltiples variables Crucialmente, podemos generar operaciones entre las variables. Por ejemplo, calculemos el GDP per capita: mutate(df_aprob, wdi_gdp_pc = wdi_gdp / wdi_pop) ## # A tibble: 1,020 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 1,010 more rows, and 8 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_gdp_pc &lt;dbl&gt; Varias transformaciones a la vez: Algo como lo siguiente funcionará: mutate(df_aprob, wdi_pop_mill = wdi_pop / 1000000, wdi_gdp_pc = wdi_gdp / wdi_pop) ## # A tibble: 1,020 x 14 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 1,010 more rows, and 9 more ## # variables: pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # wdi_pop_mill &lt;dbl&gt;, wdi_gdp_pc &lt;dbl&gt; (Ejercicio D) Crea un nuevo data frame, que esté ordenado desde el país-año-trimeste con menor aprobación presidencial al con mayor aprobación presidencial (recuerda crear el nuevo objeto y ponerle un buen nombre!). Tu código: En tu nuevo objeto, obtén solo con las observaciones que tengan presidentas. Tu código: Crea una nueva variable, que registre el desempleo como proporción en vez de porcentaje. Tu código: Agregar/colapsar con summarize() / hacer operaciones por grupos con group_by() Podemos hacer resúmenes para la base de datos con summarize: summarize(df_aprob, prom_desemp = mean(unemp)) ## # A tibble: 1 x 1 ## prom_desemp ## &lt;dbl&gt; ## 1 7.04 Como antes, podemos hacer varios a la vez: summarize(df_aprob, prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## # A tibble: 1 x 3 ## prom_desemp prom_crec prom_aprob ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7.04 3.77 15.3 Resúmenes agrupados Lo realmente interesante es hacer resúmenes por grupos. Primero debemos tener una versión agrupada de la base de datos. Esta es igual que nuestra base original, pero R sabe que las siguientes operaciones que realicemos en ella deberán ser agrupadas (veamos la ligera diferencia cuando hacemos un resumen con glimpse()) df_aprob_por_pais &lt;- group_by(df_aprob, country) glimpse(df_aprob_por_pais) ## Rows: 1,020 ## Columns: 12 ## Groups: country [17] ## $ country &lt;chr&gt; &quot;Argentina&quot;, &quot;Argentina... ## $ year &lt;dbl&gt; 2000, 2000, 2000, 2000,... ## $ quarter &lt;dbl&gt; 1, 2, 3, 4, 1, 2, 3, 4,... ## $ president &lt;chr&gt; &quot;Fernando de la Rúa&quot;, &quot;... ## $ net_approval &lt;dbl&gt; 40.126, 16.390, 23.968,... ## $ pres_sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;, &quot;male&quot;,... ## $ pres_sex_d &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0,... ## $ exec_corr &lt;dbl&gt; 14.01525, 14.01525, 14.... ## $ gdp_growth &lt;dbl&gt; -0.8, -0.8, -0.8, -0.8,... ## $ unemp &lt;dbl&gt; 15.0000, 15.0000, 15.00... ## $ wdi_gdp &lt;dbl&gt; 552151219031, 552151219... ## $ wdi_pop &lt;dbl&gt; 37057452, 37057452, 370... Hagamos una operación de resumen en esta nueva base: summarize(df_aprob_por_pais, prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 17 x 4 ## country prom_desemp prom_crec prom_aprob ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 11.0 2.72 16.7 ## 2 Bolivia 3.70 4.24 11.3 ## 3 Brazil 8.35 3.4 34.2 ## 4 Chile 8.18 4.33 5.71 ## 5 Colombia 12.5 4.35 27.1 ## 6 Costa Rica 6.73 4.15 14.5 ## 7 Ecuador 6.76 4.31 37.1 ## 8 El Salvador 5.75 1.87 39.1 ## 9 Guatemala 2.80 3.47 5.44 ## 10 Honduras 4.22 4.08 12.7 ## 11 Mexico 3.99 2.10 28.9 ## 12 Nicaragua 6.78 3.73 16.2 ## 13 Panama 8.45 6.31 14.2 ## 14 Paraguay 5.69 3.66 10.9 ## 15 Peru 4.32 5.30 -26.2 ## 16 Uruguay 10.3 3.08 26.9 ## 17 Venezuela 10.3 3.04 -14.8 Hacer cadenas de operaciones con las pipes (%&gt;%) La mayor parte del tiempo queremos hacer más de una operación en una base de datos. Por ejemplo, podríamos querer (1) crear una nueva variable con PIB per capita, y luego (2) filtrar las observaciones con valores iguales o mayores a la media de PIB per capita en toda la base: df_aprob_con_pib_pc &lt;- mutate(df_aprob, pib_pc = wdi_gdp / wdi_pop) filter(df_aprob_con_pib_pc, pib_pc &gt; mean(pib_pc)) ## # A tibble: 492 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 482 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # pib_pc &lt;dbl&gt; Esta misma cadena de operaciones se puede escribir de la siguiente forma: df_aprob %&gt;% mutate(pib_pc = wdi_gdp / wdi_pop) %&gt;% filter(pib_pc &gt; mean(pib_pc)) ## # A tibble: 492 x 13 ## country year quarter president net_approval ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Argent~ 2000 1 Fernando~ 40.1 ## 2 Argent~ 2000 2 Fernando~ 16.4 ## 3 Argent~ 2000 3 Fernando~ 24.0 ## 4 Argent~ 2000 4 Fernando~ -18.3 ## 5 Argent~ 2001 1 Fernando~ -6.97 ## 6 Argent~ 2001 2 Fernando~ -20.1 ## 7 Argent~ 2001 3 Fernando~ -19.4 ## 8 Argent~ 2001 4 Fernando~ -23.2 ## 9 Argent~ 2002 1 Eduardo ~ -2.01 ## 10 Argent~ 2002 2 Eduardo ~ -20.1 ## # ... with 482 more rows, and 8 more variables: ## # pres_sex &lt;chr&gt;, pres_sex_d &lt;dbl&gt;, ## # exec_corr &lt;dbl&gt;, gdp_growth &lt;dbl&gt;, ## # unemp &lt;dbl&gt;, wdi_gdp &lt;dbl&gt;, wdi_pop &lt;dbl&gt;, ## # pib_pc &lt;dbl&gt; ¡Este código es sorprendemente legible! Las pipes (%&gt;%) se leen como luego (o pero luego) y se insertan con Ctrl/Cmd + Shift + M en RStudio. Pueden ver todos los atajos de teclado en Help &gt; Keyboard Shortcuts Help. Uno de los usos más comunes de las pipes es el combo group_by() + summarize(). Repitamos nuestras operaciones de antes para hacer un resumen agrupado: df_aprob %&gt;% group_by(country) %&gt;% summarize(prom_desemp = mean(unemp), prom_crec = mean(gdp_growth), prom_aprob = mean(net_approval)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 17 x 4 ## country prom_desemp prom_crec prom_aprob ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 11.0 2.72 16.7 ## 2 Bolivia 3.70 4.24 11.3 ## 3 Brazil 8.35 3.4 34.2 ## 4 Chile 8.18 4.33 5.71 ## 5 Colombia 12.5 4.35 27.1 ## 6 Costa Rica 6.73 4.15 14.5 ## 7 Ecuador 6.76 4.31 37.1 ## 8 El Salvador 5.75 1.87 39.1 ## 9 Guatemala 2.80 3.47 5.44 ## 10 Honduras 4.22 4.08 12.7 ## 11 Mexico 3.99 2.10 28.9 ## 12 Nicaragua 6.78 3.73 16.2 ## 13 Panama 8.45 6.31 14.2 ## 14 Paraguay 5.69 3.66 10.9 ## 15 Peru 4.32 5.30 -26.2 ## 16 Uruguay 10.3 3.08 26.9 ## 17 Venezuela 10.3 3.04 -14.8 (Ejercicios E-G) E. Calcula, ayudándote de las pipes, la mediana por país de corrupción ejecutiva y PIB. Recuerda que puedes insertar chunks con Ctrl/Cmd + Alt + i y pipes con Ctrl/Cmd + Shift + M. Tu código: F. De nuevo usando pipes, ordena los países en la base desde el que tuvo el mayor PIB per cápita promedio en el período 2010-2014 hasta el que tuvo el menor. Tu código: G. ¿Qué país-año-trimestre, entre los gobernados por mujeres, tuvo la corrupción ejecutiva más alta? ¿Y la aprobación neta más alta? "],["manejo-02b.html", "02B - Manejo de datos (ejercicio) Contexto", " 02B - Manejo de datos (ejercicio) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica en el script 02A. Recomiendo reiniciar R antes de comenzar: Session &gt; Restart R y click en la escoba del panel de Environment (superior derecho). Contexto La base de datos de este ejercicio guarda relación con la política monetaria ante la Gran Depresión. En especial, trata sobre la crisis en Mississippi, donde la administración central de los bancos estaba en manos de Bancos Centrales con distintas políticas: el Banco Central de Atlanta, encargado del Distrito 6, estuvo a favor de prestarle dinero a los bancos en problemas. En cambio, el Banco Central de St. Louis se encargó del Distrito 8 de acuerdo a la Doctrica de las Letras Reales, que sostiene que los Bancos Centrales deben restringir el crédito durante una recesión económica (Angrist &amp; Pischke, 2014, cap. 5) ¿Qué política monetaria fue más efectiva para combatir la crisis desde la perspectiva financiera? Podemos analizar cuántos bancos quebraron a cada lado de la política para entender mejor esto. A. Comienza cargando el tidyverse y la base de datos, que se encuentra en la carpeta datos (recuerda ponerle un buen nombre). El nombre del archivo es banks2.csv. Tu código: B. Analiza la base. ¿Qué información tiene? ¿Cuál es la unidad de análisis? Considera que bib significa banks in business. Tu respuesta: C. Obtén solo las observaciones del primero de julio de cada año. Esto nos permitirá analizar patrones anuales. Crea una nueva base de datos con esta nueva unidad de análisis. Tu código: D. Revisa el archivo de ayuda de la función diff(). Para cada zona de Banco Central, ¿cuál es la diferencia de bancos en operación al comparar 1929 con 1934? Tu código: E. Repite el ejercicio anterior, pero calculando la diferencia en términos proporcionales. Tu código: F. ¿En qué mes del año (enero, febrero, etc.) fueron más pronunciados los cierres de bancos, en promedio? "],["manejo-02c.html", "02C - Manejo de datos (extras) Cargar y guardar bases de datos Versiones iterativas de summarize() y mutate()", " 02C - Manejo de datos (extras) Si quieres correr este script localmente, debe haber descargado el proyecto, como se explica en el script 02A. Como al principio de todo script, recomiendo reiniciar R. Esto lo conseguimos con Session &gt; Restart R y clickeando en la escoba del panel de Environment (superior derecho). Ahora carguemos los paquetes que usaremos: library(tidyverse) library(readxl) # leer datos de Excel ## install.packages(c(&quot;janitor&quot;, &quot;writexl&quot;)) library(janitor) # limpiar bases library(writexl) # guardar bases de Excel Cargar y guardar bases de datos Cargar desde múltiples formatos Hay múltiples formatos en los podemos encontrar bases de datos tabulares. Por suerte, la consistencia del tidyverse nos permite usar funciones muy similares para trabajar con ellas en R (Araya y Cruz, 2019). Extensión Descripción Función .csv Archivo delimitado por comas read_csv() .dta Stata (suele incluir etiquetas) haven::read_stata() .Rdata R (puede tener múltiples objetos) load() .rds R (un solo objeto) read_rds() .sav SPSS (suele incluir etiquetas) haven::read_spss() .xlsx Excel 2007- writexl::read_excel() Limpiar nombres de columnas En esta ocasión cargaremos unos datos en formato Excel. Es muy común encontrar datos que tienen este tipo de extensión, y en general no vienen demasiado limpios (el trabajo con planillas no necesariamente se hace pensando en el procesamiento con código). Inspeccionémoslos visualmente. Son datos de casos policiales en 2016 para 340 comunas de Chile, recolectados desde la Subsecretaría de Prevención del Delito (2017). Habiendo cargando el paquete readxl antes, la sintaxis para cargar los datos será familiar: df_casos_policiales &lt;- read_excel(&quot;datos/casos_delitos_por_comuna.xlsx&quot;) glimpse(df_casos_policiales) ## Rows: 340 ## Columns: 17 ## $ Comuna &lt;chr&gt; ... ## $ `Comuna ID` &lt;dbl&gt; ... ## $ `Región ID` &lt;dbl&gt; ... ## $ `Población (INE 2017)` &lt;dbl&gt; ... ## $ `Robos con violencia o intimidación` &lt;dbl&gt; ... ## $ `Robos por sorpresa` &lt;dbl&gt; ... ## $ `Robos de vehículo motorizado` &lt;dbl&gt; ... ## $ `Robos de objeto de o desde vehículo` &lt;dbl&gt; ... ## $ `Robos en lugar habitado` &lt;dbl&gt; ... ## $ `Robos en lugar no habitado` &lt;dbl&gt; ... ## $ `Otros robos con fuerza` &lt;dbl&gt; ... ## $ Hurtos &lt;dbl&gt; ... ## $ `Lesiones menos graves, graves o gravísimas` &lt;dbl&gt; ... ## $ `Lesiones leves` &lt;dbl&gt; ... ## $ Homicidios &lt;dbl&gt; ... ## $ Violaciones &lt;dbl&gt; ... ## $ VIF &lt;dbl&gt; ... Los nombres de las columnas en la base tienen mayúsculas, espacios y tildes, lo que nos puede generar problemas en el análisis. La convención en el tidyverse es nombrar utilizando snake_case (nombre_de_mi_objeto), sin mayúsculas, espacios ni tildes. Esto nos ahorrará muchos problemas. Si ya tenemos una base de datos y queremos estandarizar sus variables, el paquete janitor provee la función clean_names() para esto: df_casos_policiales_l &lt;- df_casos_policiales %&gt;% clean_names() glimpse(df_casos_policiales_l) ## Rows: 340 ## Columns: 17 ## $ comuna &lt;chr&gt; ... ## $ comuna_id &lt;dbl&gt; ... ## $ region_id &lt;dbl&gt; ... ## $ poblacion_ine_2017 &lt;dbl&gt; ... ## $ robos_con_violencia_o_intimidacion &lt;dbl&gt; ... ## $ robos_por_sorpresa &lt;dbl&gt; ... ## $ robos_de_vehiculo_motorizado &lt;dbl&gt; ... ## $ robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt; ... ## $ robos_en_lugar_habitado &lt;dbl&gt; ... ## $ robos_en_lugar_no_habitado &lt;dbl&gt; ... ## $ otros_robos_con_fuerza &lt;dbl&gt; ... ## $ hurtos &lt;dbl&gt; ... ## $ lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt; ... ## $ lesiones_leves &lt;dbl&gt; ... ## $ homicidios &lt;dbl&gt; ... ## $ violaciones &lt;dbl&gt; ... ## $ vif &lt;dbl&gt; ... (Ejercicios A-B) A. ¿Cuál fue la comuna con más homicidios en Chile en el año 2016? Tu código: B. ¿Cuál fue la comuna con más casos de violencia intrafamiliar por cada 1000 habitantes? Tu código: Crear bases de datos a mano A veces queremos crear un data frame arbitrariamente a partir de vectores. Para esto, la funcióm tibble() es simple y útil: df_ejemplo &lt;- tibble( x = c(1:10), y = c(9, 10, 1:8) ) df_ejemplo ## # A tibble: 10 x 2 ## x y ## &lt;int&gt; &lt;dbl&gt; ## 1 1 9 ## 2 2 10 ## 3 3 1 ## 4 4 2 ## 5 5 3 ## 6 6 4 ## 7 7 5 ## 8 8 6 ## 9 9 7 ## 10 10 8 Guardar bases de datos Guardar una base de datos es necesario para compartirla con colegas o usarla en otros proyectos. La mayoría de las funciones que vimos, que comienzan con read_, tienen su versión write_ para este propósito. Por ejemplo, read_csv() -&gt; write_csv(). El único par de comandos en los que hay algo distinto es readxl::read_excel() -&gt; writexl::write_xlsx(). En general, los mejores formatos para guardar bases son .csv (muy universal) y .rds (nos aseguramos de que cualquier cosa extraña en nuestros datos pueda volver bien a R). Guardemos los datos en formatos .csv, .rds y .xlsx (Excel). Recuerda que ya cargamos antes el paquete writexl, que nos permite hacer esto último. write_csv(df_ejemplo, &quot;datos/df_ejemplo.csv&quot;) write_csv(df_ejemplo, &quot;datos/df_ejemplo.rds&quot;) write_xlsx(df_ejemplo, &quot;datos/df_ejemplo.xlsx&quot;) Podríamos volver a cargarlo con read_excel(): df_ejemplo_comprob &lt;- read_excel(&quot;datos/df_ejemplo.xlsx&quot;) df_ejemplo_comprob ## # A tibble: 10 x 2 ## x y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 9 ## 2 2 10 ## 3 3 1 ## 4 4 2 ## 5 5 3 ## 6 6 4 ## 7 7 5 ## 8 8 6 ## 9 9 7 ## 10 10 8 (Ejercicio) Guarda una versión de la base de datos de delitos, en formato csv. Utiliza la versión con los nombres de columnas limpios y excluye la variable de región. Tu código: Versiones iterativas de summarize() y mutate() Es común necesitar hacer una misma operación en múltiples columnas de una base. Por ejemplo, podríamos querer los totales de delitos específicos por región, como muestra el siguiente chunk. df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize(lesiones_leves_total = sum(lesiones_leves), hurtos_total = sum(hurtos)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 16 x 3 ## region_id lesiones_leves_total hurtos_total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1523 3935 ## 2 2 3014 8257 ## 3 3 1253 2953 ## 4 4 2830 6613 ## 5 5 6955 19537 ## 6 6 3347 8553 ## 7 7 2368 7371 ## 8 8 4549 13698 ## 9 9 3227 9808 ## 10 10 2824 9575 ## 11 11 486 1169 ## 12 12 525 1568 ## 13 13 22796 65621 ## 14 14 1269 3783 ## 15 15 733 1762 ## 16 16 1250 3644 Sin embargo, hacer este código para los 13 tipos de delito es una pérdida de tiempo: generaría código particularmente difícil de leer. Podemos aplicar la función summarize_at() para usar la función de suma en múltiples variables. Noten cómo en el código siguiente . reemplazará a la variable en la definición de la operación (gracias al operador ~). df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = ~sum(.)) ## # A tibble: 16 x 14 ## region_id robos_con_viole~ robos_por_sorpr~ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 1499 ## 2 2 1930 1173 ## 3 3 832 379 ## 4 4 1667 1106 ## 5 5 5777 4537 ## 6 6 1629 1011 ## 7 7 1108 852 ## 8 8 4646 2664 ## 9 9 1547 1331 ## 10 10 1025 728 ## 11 11 71 26 ## 12 12 112 29 ## 13 13 41541 19168 ## 14 14 424 339 ## 15 15 618 451 ## 16 16 605 513 ## # ... with 11 more variables: ## # robos_de_vehiculo_motorizado &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt;, ## # robos_en_lugar_habitado &lt;dbl&gt;, ## # robos_en_lugar_no_habitado &lt;dbl&gt;, ## # otros_robos_con_fuerza &lt;dbl&gt;, hurtos &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt;, ## # lesiones_leves &lt;dbl&gt;, homicidios &lt;dbl&gt;, ## # violaciones &lt;dbl&gt;, vif &lt;dbl&gt; Incluso podemos editar un poco los nombres de los resúmenes, asignándolos como elementos en una lista. Noten cómo van a cambiar dichos nombres, terminando ahora en \"_total\": df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(total = ~sum(.))) ## # A tibble: 16 x 14 ## region_id robos_con_viole~ robos_por_sorpr~ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 1499 ## 2 2 1930 1173 ## 3 3 832 379 ## 4 4 1667 1106 ## 5 5 5777 4537 ## 6 6 1629 1011 ## 7 7 1108 852 ## 8 8 4646 2664 ## 9 9 1547 1331 ## 10 10 1025 728 ## 11 11 71 26 ## 12 12 112 29 ## 13 13 41541 19168 ## 14 14 424 339 ## 15 15 618 451 ## 16 16 605 513 ## # ... with 11 more variables: ## # robos_de_vehiculo_motorizado_total &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_total &lt;dbl&gt;, ## # robos_en_lugar_habitado_total &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_total &lt;dbl&gt;, ## # otros_robos_con_fuerza_total &lt;dbl&gt;, ## # hurtos_total &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_total &lt;dbl&gt;, ## # lesiones_leves_total &lt;dbl&gt;, ## # homicidios_total &lt;dbl&gt;, ## # violaciones_total &lt;dbl&gt;, vif_total &lt;dbl&gt; También podemos utilizar más de una función de resumen a la vez en nuestros datos: df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(total = ~sum(.), max = ~max(.))) ## # A tibble: 16 x 27 ## region_id robos_con_viole~ robos_por_sorpr~ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1554 1499 ## 2 2 1930 1173 ## 3 3 832 379 ## 4 4 1667 1106 ## 5 5 5777 4537 ## 6 6 1629 1011 ## 7 7 1108 852 ## 8 8 4646 2664 ## 9 9 1547 1331 ## 10 10 1025 728 ## 11 11 71 26 ## 12 12 112 29 ## 13 13 41541 19168 ## 14 14 424 339 ## 15 15 618 451 ## 16 16 605 513 ## # ... with 24 more variables: ## # robos_de_vehiculo_motorizado_total &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_total &lt;dbl&gt;, ## # robos_en_lugar_habitado_total &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_total &lt;dbl&gt;, ## # otros_robos_con_fuerza_total &lt;dbl&gt;, ## # hurtos_total &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_total &lt;dbl&gt;, ## # lesiones_leves_total &lt;dbl&gt;, ## # homicidios_total &lt;dbl&gt;, ## # violaciones_total &lt;dbl&gt;, vif_total &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion_max &lt;dbl&gt;, ## # robos_por_sorpresa_max &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_max &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_max &lt;dbl&gt;, ## # robos_en_lugar_habitado_max &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_max &lt;dbl&gt;, ## # otros_robos_con_fuerza_max &lt;dbl&gt;, ## # hurtos_max &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_max &lt;dbl&gt;, ## # lesiones_leves_max &lt;dbl&gt;, ## # homicidios_max &lt;dbl&gt;, violaciones_max &lt;dbl&gt;, ## # vif_max &lt;dbl&gt; Aparte de hacer resúmenes, crear múltiples variables según una misma operación es bastante común. Supongamos que queremos las cifras relativas (tasas) para cada tipo de delito, como en el siguiente ejemplo: df_casos_policiales_l %&gt;% mutate(lesiones_leves_c1000 = lesiones_leves * 1000 / poblacion_ine_2017) %&gt;% select(comuna, poblacion_ine_2017, lesiones_leves, lesiones_leves_c1000) # solo para legibilidad ## # A tibble: 340 x 4 ## comuna poblacion_ine_2~ lesiones_leves ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algar~ 10700 52 ## 2 Alhué 5916 26 ## 3 Alto-~ 5957 24 ## 4 Alto-~ 6519 8 ## 5 Alto-~ 124872 523 ## 6 Ancud 44249 132 ## 7 Andac~ 11555 77 ## 8 Angol 55845 244 ## 9 Antár~ 202 0 ## 10 Antof~ 389812 1528 ## # ... with 330 more rows, and 1 more variable: ## # lesiones_leves_c1000 &lt;dbl&gt; Podemos utilizar mutate_at() para repetir esta operación en todas nuestras variables de interés. df_casos_policiales_l %&gt;% mutate_at(.vars = vars(robos_con_violencia_o_intimidacion:vif), .funs = list(c1000 = ~ . * 1000 / poblacion_ine_2017)) ## # A tibble: 340 x 30 ## comuna comuna_id region_id poblacion_ine_2~ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algar~ 5602 5 10700 ## 2 Alhué 13502 13 5916 ## 3 Alto-~ 8314 8 5957 ## 4 Alto-~ 3302 3 6519 ## 5 Alto-~ 1107 1 124872 ## 6 Ancud 10202 10 44249 ## 7 Andac~ 4103 4 11555 ## 8 Angol 9201 9 55845 ## 9 Antár~ 12202 12 202 ## 10 Antof~ 2101 2 389812 ## # ... with 330 more rows, and 26 more variables: ## # robos_con_violencia_o_intimidacion &lt;dbl&gt;, ## # robos_por_sorpresa &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo &lt;dbl&gt;, ## # robos_en_lugar_habitado &lt;dbl&gt;, ## # robos_en_lugar_no_habitado &lt;dbl&gt;, ## # otros_robos_con_fuerza &lt;dbl&gt;, hurtos &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas &lt;dbl&gt;, ## # lesiones_leves &lt;dbl&gt;, homicidios &lt;dbl&gt;, ## # violaciones &lt;dbl&gt;, vif &lt;dbl&gt;, ## # robos_con_violencia_o_intimidacion_c1000 &lt;dbl&gt;, ## # robos_por_sorpresa_c1000 &lt;dbl&gt;, ## # robos_de_vehiculo_motorizado_c1000 &lt;dbl&gt;, ## # robos_de_objeto_de_o_desde_vehiculo_c1000 &lt;dbl&gt;, ## # robos_en_lugar_habitado_c1000 &lt;dbl&gt;, ## # robos_en_lugar_no_habitado_c1000 &lt;dbl&gt;, ## # otros_robos_con_fuerza_c1000 &lt;dbl&gt;, ## # hurtos_c1000 &lt;dbl&gt;, ## # lesiones_menos_graves_graves_o_gravisimas_c1000 &lt;dbl&gt;, ## # lesiones_leves_c1000 &lt;dbl&gt;, ## # homicidios_c1000 &lt;dbl&gt;, ## # violaciones_c1000 &lt;dbl&gt;, vif_c1000 &lt;dbl&gt; (Ejercicio C) Si queremos obtener un promedio por región en datos como estos, debemos calcular un promedio ponderado: si es que no hacemos esto, comunas con pocos habitantes estarán sobrerrepresentadas en los promedios. Un ejemplo a continuación: df_casos_policiales_l %&gt;% group_by(region_id) %&gt;% summarize(prom_hurtos = weighted.mean(hurtos, w = poblacion_ine_2017)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 16 x 2 ## region_id prom_hurtos ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1968. ## 2 2 3941. ## 3 3 1216. ## 4 4 1543. ## 5 5 2039. ## 6 6 1139. ## 7 7 1305. ## 8 8 1304. ## 9 9 1608. ## 10 10 1826. ## 11 11 513. ## 12 12 990. ## 13 13 2329. ## 14 14 1064. ## 15 15 1711. ## 16 16 938. Para cada tipo de delito, obtén el promedio ponderado por región. Tu código: "],["manejo-02d.html", "02D - Manejo de datos (ejercicio int.)", " 02D - Manejo de datos (ejercicio int.) Este ejercicio interactivo solo se puede ejecutar en RStudio Cloud. Si quieres correrlo localmente, debe haber descargado el proyecto, como se explica en el script 02A. "]]
